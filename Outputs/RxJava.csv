Commit SHA,Java File,Old function signature,New function signature
041eaebedecd9e0e302efd01ba60d80db434ab62,"package rx.performance;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable;
import rx.Observer;
import rx.util.functions.Func1;

public class PerformanceTest {

    /*
     * Example run:
     * 
     * compositionTestTotalTime: 2432
     * nonCompositionalTestWithDirectLoopTotalTime: 2043
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1925
     * 
     * compositionTestTotalTime: 2362
     * nonCompositionalTestWithDirectLoopTotalTime: 1910
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1823
     * 
     * compositionTestTotalTime: 2456
     * nonCompositionalTestWithDirectLoopTotalTime: 2004
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 2014
     */

    /*
     * >>> Statically typed <<<
     * 
     * Without chaining:
     * 
     * Sum: 710082754 Time: 130.683ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 21.011ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 20.84ms
     * 
     * 
     * With chaining (composition collapsing):
     * 
     * Sum: 710082754 Time: 28.787ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 19.525ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 19.175ms
     * 
     * 
     * >>> Dynamically typed <<<
     * 
     * When going via generic Functions.execute even with chained sequence:
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 577.3ms <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< very bad when dynamic
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 31.591ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 38.093ms
     * runCompositionTest
     * 
     * 
     * With Function memoization so we only pay dynamic price during sequence setup, not in onNext:
     * 
     * 
     * Using ArrayList
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 27.078ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.911ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.852ms
     * 
     * 
     * Using LinkedBlockingQueue
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 46.532ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.946ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.746ms
     */

    public static void main(String[] args) {
        PerformanceTest test = new PerformanceTest();
        Integer[] values = new Integer[100001];
        for (int i = 0; i < values.length; i++) {
            values[i] = i;
        }

        AtomicLong compositionTestTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithDirectLoopTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithArrayOfFunctionsTotalTime = new AtomicLong();

        for (int i = 0; i < 100; i++) {
            System.out.println(""-------------------------------"");
            //            test.runCompositionTestWithMultipleOperations(values);
            test.runCompositionTest(compositionTestTotalTime, values);
            test.runNonCompositionalTestWithDirectLoop(nonCompositionalTestWithDirectLoopTotalTime, values);
            test.runNonCompositionalTestWithArrayOfFunctions(nonCompositionalTestWithArrayOfFunctionsTotalTime, values);
        }

        System.out.println(""-------------------------------"");
        System.out.println(""compositionTestTotalTime: "" + compositionTestTotalTime.get());
        System.out.println(""nonCompositionalTestWithDirectLoopTotalTime: "" + nonCompositionalTestWithDirectLoopTotalTime.get());
        System.out.println(""nonCompositionalTestWithArrayOfFunctionsTotalTime: "" + nonCompositionalTestWithArrayOfFunctionsTotalTime.get());
    }

    public void runCompositionTestWithMultipleOperations(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTestWithMultipleOperations"");

        // old code before memoizing
        // Count: 200002 Time: 403.095ms

        // new code with memoizing but no chaining
        // Count: 200002 Time: 103.128ms

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();

        Observable<Integer> a = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        final Observable<Integer> b = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        Observable.merge(a, b).filter(new Func1<Integer, Boolean>() {

            @Override
            public Boolean call(Integer t1) {
                return t1 > 10;
            }

        }).map(new Func1<Integer, String>() {

            @Override
            public String call(Integer t1) {
                return t1 + ""-value-from-b"";
            }
        }).take(1000000).subscribe(new TestStringObserver(onNextSum, start));

    }

    public void runCompositionTest(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTest"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();
        // 50 levels of composition (same function so that's not the cost)
        Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .subscribe(new TestObserver(onNextSum, start, aggregateTime));
    }

    public void runNonCompositionalTestWithDirectLoop(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithDirectLoop"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (int i = 0; i < 50; i++) {
                    t1 = m.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    public void runNonCompositionalTestWithArrayOfFunctions(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithArrayOfFunctions"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();
        final Func1[] functionCalls = new Func1<?, ?>[50];
        for (int i = 0; i < 50; i++) {
            functionCalls[i] = m;
        }

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (Func1<Integer, Integer> f : functionCalls) {
                    t1 = f.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    private static final class TestObserver implements Observer<Integer> {
        private final AtomicInteger onNextSum;
        private final AtomicLong aggregateTime;
        private final long start;

        private TestObserver(AtomicInteger onNextSum, long start, AtomicLong aggregateTime) {
            this.onNextSum = onNextSum;
            this.start = start;
            this.aggregateTime = aggregateTime;
        }

        @Override
        public void onNext(Integer i) {
            onNextSum.addAndGet(i);
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            double timeInMilliseconds = ((double) (end - start)) / 1000 / 1000;
            aggregateTime.addAndGet(Math.round(timeInMilliseconds));
            System.out.println(""Sum: "" + onNextSum.get() + "" Time: "" + timeInMilliseconds + ""ms"");
        }
    }

    private static final class TestStringObserver implements Observer<String> {
        private final AtomicInteger onNextSum;
        private final long start;

        private TestStringObserver(AtomicInteger onNextSum, long start) {
            this.onNextSum = onNextSum;
            this.start = start;
        }

        @Override
        public void onNext(String i) {
            //            System.out.println(i);
            onNextSum.incrementAndGet();
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            System.out.println(""Count: "" + onNextSum.get() + "" Time: "" + ((double) (end - start)) / 1000 / 1000 + ""ms"");
        }
    }

    private static class MathFunction implements Func1<Integer, Integer> {

        @Override
        public Integer call(Integer t1) {
            return t1 + 1;
        }

    }

}
",    public void runCompositionTestWithMultipleOperations(Integer[] values),"    public void runCompositionTestWithMultipleOperations(AtomicLong aggregateTime, Integer[] values)"
041eaebedecd9e0e302efd01ba60d80db434ab62,"package rx.performance;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable;
import rx.Observer;
import rx.util.functions.Func1;

public class PerformanceTest {

    /*
     * Example run:
     * 
     * compositionTestTotalTime: 2432
     * nonCompositionalTestWithDirectLoopTotalTime: 2043
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1925
     * 
     * compositionTestTotalTime: 2362
     * nonCompositionalTestWithDirectLoopTotalTime: 1910
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1823
     * 
     * compositionTestTotalTime: 2456
     * nonCompositionalTestWithDirectLoopTotalTime: 2004
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 2014
     */

    /*
     * >>> Statically typed <<<
     * 
     * Without chaining:
     * 
     * Sum: 710082754 Time: 130.683ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 21.011ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 20.84ms
     * 
     * 
     * With chaining (composition collapsing):
     * 
     * Sum: 710082754 Time: 28.787ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 19.525ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 19.175ms
     * 
     * 
     * >>> Dynamically typed <<<
     * 
     * When going via generic Functions.execute even with chained sequence:
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 577.3ms <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< very bad when dynamic
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 31.591ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 38.093ms
     * runCompositionTest
     * 
     * 
     * With Function memoization so we only pay dynamic price during sequence setup, not in onNext:
     * 
     * 
     * Using ArrayList
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 27.078ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.911ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.852ms
     * 
     * 
     * Using LinkedBlockingQueue
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 46.532ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.946ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.746ms
     */

    public static void main(String[] args) {
        PerformanceTest test = new PerformanceTest();
        Integer[] values = new Integer[100001];
        for (int i = 0; i < values.length; i++) {
            values[i] = i;
        }

        AtomicLong compositionTestTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithDirectLoopTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithArrayOfFunctionsTotalTime = new AtomicLong();

        for (int i = 0; i < 100; i++) {
            System.out.println(""-------------------------------"");
            //            test.runCompositionTestWithMultipleOperations(values);
            test.runCompositionTest(compositionTestTotalTime, values);
            test.runNonCompositionalTestWithDirectLoop(nonCompositionalTestWithDirectLoopTotalTime, values);
            test.runNonCompositionalTestWithArrayOfFunctions(nonCompositionalTestWithArrayOfFunctionsTotalTime, values);
        }

        System.out.println(""-------------------------------"");
        System.out.println(""compositionTestTotalTime: "" + compositionTestTotalTime.get());
        System.out.println(""nonCompositionalTestWithDirectLoopTotalTime: "" + nonCompositionalTestWithDirectLoopTotalTime.get());
        System.out.println(""nonCompositionalTestWithArrayOfFunctionsTotalTime: "" + nonCompositionalTestWithArrayOfFunctionsTotalTime.get());
    }

    public void runCompositionTestWithMultipleOperations(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTestWithMultipleOperations"");

        // old code before memoizing
        // Count: 200002 Time: 403.095ms

        // new code with memoizing but no chaining
        // Count: 200002 Time: 103.128ms

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();

        Observable<Integer> a = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        final Observable<Integer> b = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        Observable.merge(a, b).filter(new Func1<Integer, Boolean>() {

            @Override
            public Boolean call(Integer t1) {
                return t1 > 10;
            }

        }).map(new Func1<Integer, String>() {

            @Override
            public String call(Integer t1) {
                return t1 + ""-value-from-b"";
            }
        }).take(1000000).subscribe(new TestStringObserver(onNextSum, start));

    }

    public void runCompositionTest(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTest"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();
        // 50 levels of composition (same function so that's not the cost)
        Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .subscribe(new TestObserver(onNextSum, start, aggregateTime));
    }

    public void runNonCompositionalTestWithDirectLoop(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithDirectLoop"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (int i = 0; i < 50; i++) {
                    t1 = m.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    public void runNonCompositionalTestWithArrayOfFunctions(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithArrayOfFunctions"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();
        final Func1[] functionCalls = new Func1<?, ?>[50];
        for (int i = 0; i < 50; i++) {
            functionCalls[i] = m;
        }

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (Func1<Integer, Integer> f : functionCalls) {
                    t1 = f.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    private static final class TestObserver implements Observer<Integer> {
        private final AtomicInteger onNextSum;
        private final AtomicLong aggregateTime;
        private final long start;

        private TestObserver(AtomicInteger onNextSum, long start, AtomicLong aggregateTime) {
            this.onNextSum = onNextSum;
            this.start = start;
            this.aggregateTime = aggregateTime;
        }

        @Override
        public void onNext(Integer i) {
            onNextSum.addAndGet(i);
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            double timeInMilliseconds = ((double) (end - start)) / 1000 / 1000;
            aggregateTime.addAndGet(Math.round(timeInMilliseconds));
            System.out.println(""Sum: "" + onNextSum.get() + "" Time: "" + timeInMilliseconds + ""ms"");
        }
    }

    private static final class TestStringObserver implements Observer<String> {
        private final AtomicInteger onNextSum;
        private final long start;

        private TestStringObserver(AtomicInteger onNextSum, long start) {
            this.onNextSum = onNextSum;
            this.start = start;
        }

        @Override
        public void onNext(String i) {
            //            System.out.println(i);
            onNextSum.incrementAndGet();
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            System.out.println(""Count: "" + onNextSum.get() + "" Time: "" + ((double) (end - start)) / 1000 / 1000 + ""ms"");
        }
    }

    private static class MathFunction implements Func1<Integer, Integer> {

        @Override
        public Integer call(Integer t1) {
            return t1 + 1;
        }

    }

}
",    public void runCompositionTest(Integer[] values),"    public void runCompositionTest(AtomicLong aggregateTime, Integer[] values)"
041eaebedecd9e0e302efd01ba60d80db434ab62,"package rx.performance;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable;
import rx.Observer;
import rx.util.functions.Func1;

public class PerformanceTest {

    /*
     * Example run:
     * 
     * compositionTestTotalTime: 2432
     * nonCompositionalTestWithDirectLoopTotalTime: 2043
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1925
     * 
     * compositionTestTotalTime: 2362
     * nonCompositionalTestWithDirectLoopTotalTime: 1910
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1823
     * 
     * compositionTestTotalTime: 2456
     * nonCompositionalTestWithDirectLoopTotalTime: 2004
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 2014
     */

    /*
     * >>> Statically typed <<<
     * 
     * Without chaining:
     * 
     * Sum: 710082754 Time: 130.683ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 21.011ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 20.84ms
     * 
     * 
     * With chaining (composition collapsing):
     * 
     * Sum: 710082754 Time: 28.787ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 19.525ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 19.175ms
     * 
     * 
     * >>> Dynamically typed <<<
     * 
     * When going via generic Functions.execute even with chained sequence:
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 577.3ms <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< very bad when dynamic
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 31.591ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 38.093ms
     * runCompositionTest
     * 
     * 
     * With Function memoization so we only pay dynamic price during sequence setup, not in onNext:
     * 
     * 
     * Using ArrayList
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 27.078ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.911ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.852ms
     * 
     * 
     * Using LinkedBlockingQueue
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 46.532ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.946ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.746ms
     */

    public static void main(String[] args) {
        PerformanceTest test = new PerformanceTest();
        Integer[] values = new Integer[100001];
        for (int i = 0; i < values.length; i++) {
            values[i] = i;
        }

        AtomicLong compositionTestTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithDirectLoopTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithArrayOfFunctionsTotalTime = new AtomicLong();

        for (int i = 0; i < 100; i++) {
            System.out.println(""-------------------------------"");
            //            test.runCompositionTestWithMultipleOperations(values);
            test.runCompositionTest(compositionTestTotalTime, values);
            test.runNonCompositionalTestWithDirectLoop(nonCompositionalTestWithDirectLoopTotalTime, values);
            test.runNonCompositionalTestWithArrayOfFunctions(nonCompositionalTestWithArrayOfFunctionsTotalTime, values);
        }

        System.out.println(""-------------------------------"");
        System.out.println(""compositionTestTotalTime: "" + compositionTestTotalTime.get());
        System.out.println(""nonCompositionalTestWithDirectLoopTotalTime: "" + nonCompositionalTestWithDirectLoopTotalTime.get());
        System.out.println(""nonCompositionalTestWithArrayOfFunctionsTotalTime: "" + nonCompositionalTestWithArrayOfFunctionsTotalTime.get());
    }

    public void runCompositionTestWithMultipleOperations(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTestWithMultipleOperations"");

        // old code before memoizing
        // Count: 200002 Time: 403.095ms

        // new code with memoizing but no chaining
        // Count: 200002 Time: 103.128ms

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();

        Observable<Integer> a = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        final Observable<Integer> b = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        Observable.merge(a, b).filter(new Func1<Integer, Boolean>() {

            @Override
            public Boolean call(Integer t1) {
                return t1 > 10;
            }

        }).map(new Func1<Integer, String>() {

            @Override
            public String call(Integer t1) {
                return t1 + ""-value-from-b"";
            }
        }).take(1000000).subscribe(new TestStringObserver(onNextSum, start));

    }

    public void runCompositionTest(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTest"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();
        // 50 levels of composition (same function so that's not the cost)
        Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .subscribe(new TestObserver(onNextSum, start, aggregateTime));
    }

    public void runNonCompositionalTestWithDirectLoop(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithDirectLoop"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (int i = 0; i < 50; i++) {
                    t1 = m.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    public void runNonCompositionalTestWithArrayOfFunctions(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithArrayOfFunctions"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();
        final Func1[] functionCalls = new Func1<?, ?>[50];
        for (int i = 0; i < 50; i++) {
            functionCalls[i] = m;
        }

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (Func1<Integer, Integer> f : functionCalls) {
                    t1 = f.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    private static final class TestObserver implements Observer<Integer> {
        private final AtomicInteger onNextSum;
        private final AtomicLong aggregateTime;
        private final long start;

        private TestObserver(AtomicInteger onNextSum, long start, AtomicLong aggregateTime) {
            this.onNextSum = onNextSum;
            this.start = start;
            this.aggregateTime = aggregateTime;
        }

        @Override
        public void onNext(Integer i) {
            onNextSum.addAndGet(i);
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            double timeInMilliseconds = ((double) (end - start)) / 1000 / 1000;
            aggregateTime.addAndGet(Math.round(timeInMilliseconds));
            System.out.println(""Sum: "" + onNextSum.get() + "" Time: "" + timeInMilliseconds + ""ms"");
        }
    }

    private static final class TestStringObserver implements Observer<String> {
        private final AtomicInteger onNextSum;
        private final long start;

        private TestStringObserver(AtomicInteger onNextSum, long start) {
            this.onNextSum = onNextSum;
            this.start = start;
        }

        @Override
        public void onNext(String i) {
            //            System.out.println(i);
            onNextSum.incrementAndGet();
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            System.out.println(""Count: "" + onNextSum.get() + "" Time: "" + ((double) (end - start)) / 1000 / 1000 + ""ms"");
        }
    }

    private static class MathFunction implements Func1<Integer, Integer> {

        @Override
        public Integer call(Integer t1) {
            return t1 + 1;
        }

    }

}
",    public void runNonCompositionalTestWithDirectLoop(Integer[] values),"    public void runNonCompositionalTestWithDirectLoop(AtomicLong aggregateTime, Integer[] values)"
041eaebedecd9e0e302efd01ba60d80db434ab62,"package rx.performance;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable;
import rx.Observer;
import rx.util.functions.Func1;

public class PerformanceTest {

    /*
     * Example run:
     * 
     * compositionTestTotalTime: 2432
     * nonCompositionalTestWithDirectLoopTotalTime: 2043
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1925
     * 
     * compositionTestTotalTime: 2362
     * nonCompositionalTestWithDirectLoopTotalTime: 1910
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1823
     * 
     * compositionTestTotalTime: 2456
     * nonCompositionalTestWithDirectLoopTotalTime: 2004
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 2014
     */

    /*
     * >>> Statically typed <<<
     * 
     * Without chaining:
     * 
     * Sum: 710082754 Time: 130.683ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 21.011ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 20.84ms
     * 
     * 
     * With chaining (composition collapsing):
     * 
     * Sum: 710082754 Time: 28.787ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 19.525ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 19.175ms
     * 
     * 
     * >>> Dynamically typed <<<
     * 
     * When going via generic Functions.execute even with chained sequence:
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 577.3ms <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< very bad when dynamic
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 31.591ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 38.093ms
     * runCompositionTest
     * 
     * 
     * With Function memoization so we only pay dynamic price during sequence setup, not in onNext:
     * 
     * 
     * Using ArrayList
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 27.078ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.911ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.852ms
     * 
     * 
     * Using LinkedBlockingQueue
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 46.532ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.946ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.746ms
     */

    public static void main(String[] args) {
        PerformanceTest test = new PerformanceTest();
        Integer[] values = new Integer[100001];
        for (int i = 0; i < values.length; i++) {
            values[i] = i;
        }

        AtomicLong compositionTestTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithDirectLoopTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithArrayOfFunctionsTotalTime = new AtomicLong();

        for (int i = 0; i < 100; i++) {
            System.out.println(""-------------------------------"");
            //            test.runCompositionTestWithMultipleOperations(values);
            test.runCompositionTest(compositionTestTotalTime, values);
            test.runNonCompositionalTestWithDirectLoop(nonCompositionalTestWithDirectLoopTotalTime, values);
            test.runNonCompositionalTestWithArrayOfFunctions(nonCompositionalTestWithArrayOfFunctionsTotalTime, values);
        }

        System.out.println(""-------------------------------"");
        System.out.println(""compositionTestTotalTime: "" + compositionTestTotalTime.get());
        System.out.println(""nonCompositionalTestWithDirectLoopTotalTime: "" + nonCompositionalTestWithDirectLoopTotalTime.get());
        System.out.println(""nonCompositionalTestWithArrayOfFunctionsTotalTime: "" + nonCompositionalTestWithArrayOfFunctionsTotalTime.get());
    }

    public void runCompositionTestWithMultipleOperations(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTestWithMultipleOperations"");

        // old code before memoizing
        // Count: 200002 Time: 403.095ms

        // new code with memoizing but no chaining
        // Count: 200002 Time: 103.128ms

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();

        Observable<Integer> a = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        final Observable<Integer> b = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        Observable.merge(a, b).filter(new Func1<Integer, Boolean>() {

            @Override
            public Boolean call(Integer t1) {
                return t1 > 10;
            }

        }).map(new Func1<Integer, String>() {

            @Override
            public String call(Integer t1) {
                return t1 + ""-value-from-b"";
            }
        }).take(1000000).subscribe(new TestStringObserver(onNextSum, start));

    }

    public void runCompositionTest(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTest"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();
        // 50 levels of composition (same function so that's not the cost)
        Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .subscribe(new TestObserver(onNextSum, start, aggregateTime));
    }

    public void runNonCompositionalTestWithDirectLoop(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithDirectLoop"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (int i = 0; i < 50; i++) {
                    t1 = m.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    public void runNonCompositionalTestWithArrayOfFunctions(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithArrayOfFunctions"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();
        final Func1[] functionCalls = new Func1<?, ?>[50];
        for (int i = 0; i < 50; i++) {
            functionCalls[i] = m;
        }

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (Func1<Integer, Integer> f : functionCalls) {
                    t1 = f.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    private static final class TestObserver implements Observer<Integer> {
        private final AtomicInteger onNextSum;
        private final AtomicLong aggregateTime;
        private final long start;

        private TestObserver(AtomicInteger onNextSum, long start, AtomicLong aggregateTime) {
            this.onNextSum = onNextSum;
            this.start = start;
            this.aggregateTime = aggregateTime;
        }

        @Override
        public void onNext(Integer i) {
            onNextSum.addAndGet(i);
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            double timeInMilliseconds = ((double) (end - start)) / 1000 / 1000;
            aggregateTime.addAndGet(Math.round(timeInMilliseconds));
            System.out.println(""Sum: "" + onNextSum.get() + "" Time: "" + timeInMilliseconds + ""ms"");
        }
    }

    private static final class TestStringObserver implements Observer<String> {
        private final AtomicInteger onNextSum;
        private final long start;

        private TestStringObserver(AtomicInteger onNextSum, long start) {
            this.onNextSum = onNextSum;
            this.start = start;
        }

        @Override
        public void onNext(String i) {
            //            System.out.println(i);
            onNextSum.incrementAndGet();
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            System.out.println(""Count: "" + onNextSum.get() + "" Time: "" + ((double) (end - start)) / 1000 / 1000 + ""ms"");
        }
    }

    private static class MathFunction implements Func1<Integer, Integer> {

        @Override
        public Integer call(Integer t1) {
            return t1 + 1;
        }

    }

}
",    public void runNonCompositionalTestWithArrayOfFunctions(Integer[] values),"    public void runNonCompositionalTestWithArrayOfFunctions(AtomicLong aggregateTime, Integer[] values)"
60912673554199663153769294cf12f93b032bc0,"package rx.performance;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable;
import rx.Observer;
import rx.util.functions.Func1;

public class PerformanceTest {

    /*
     * Example run:
     * 
     * compositionTestTotalTime: 2432
     * nonCompositionalTestWithDirectLoopTotalTime: 2043
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1925
     * 
     * compositionTestTotalTime: 2362
     * nonCompositionalTestWithDirectLoopTotalTime: 1910
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1823
     * 
     * compositionTestTotalTime: 2456
     * nonCompositionalTestWithDirectLoopTotalTime: 2004
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 2014
     */

    /*
     * >>> Statically typed <<<
     * 
     * Without chaining:
     * 
     * Sum: 710082754 Time: 130.683ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 21.011ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 20.84ms
     * 
     * 
     * With chaining (composition collapsing):
     * 
     * Sum: 710082754 Time: 28.787ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 19.525ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 19.175ms
     * 
     * 
     * >>> Dynamically typed <<<
     * 
     * When going via generic Functions.execute even with chained sequence:
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 577.3ms <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< very bad when dynamic
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 31.591ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 38.093ms
     * runCompositionTest
     * 
     * 
     * With Function memoization so we only pay dynamic price during sequence setup, not in onNext:
     * 
     * 
     * Using ArrayList
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 27.078ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.911ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.852ms
     * 
     * 
     * Using LinkedBlockingQueue
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 46.532ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.946ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.746ms
     */

    public static void main(String[] args) {
        PerformanceTest test = new PerformanceTest();
        Integer[] values = new Integer[100001];
        for (int i = 0; i < values.length; i++) {
            values[i] = i;
        }

        AtomicLong compositionTestTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithDirectLoopTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithArrayOfFunctionsTotalTime = new AtomicLong();

        for (int i = 0; i < 100; i++) {
            System.out.println(""-------------------------------"");
            //            test.runCompositionTestWithMultipleOperations(values);
            test.runCompositionTest(compositionTestTotalTime, values);
            test.runNonCompositionalTestWithDirectLoop(nonCompositionalTestWithDirectLoopTotalTime, values);
            test.runNonCompositionalTestWithArrayOfFunctions(nonCompositionalTestWithArrayOfFunctionsTotalTime, values);
        }

        System.out.println(""-------------------------------"");
        System.out.println(""compositionTestTotalTime: "" + compositionTestTotalTime.get());
        System.out.println(""nonCompositionalTestWithDirectLoopTotalTime: "" + nonCompositionalTestWithDirectLoopTotalTime.get());
        System.out.println(""nonCompositionalTestWithArrayOfFunctionsTotalTime: "" + nonCompositionalTestWithArrayOfFunctionsTotalTime.get());
    }

    @SuppressWarnings(""unchecked"")
    public void runCompositionTestWithMultipleOperations(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTestWithMultipleOperations"");

        // old code before memoizing
        // Count: 200002 Time: 403.095ms

        // new code with memoizing but no chaining
        // Count: 200002 Time: 103.128ms

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();

        Observable<Integer> a = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        final Observable<Integer> b = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        Observable.merge(a, b).filter(new Func1<Integer, Boolean>() {

            @Override
            public Boolean call(Integer t1) {
                return t1 > 10;
            }

        }).map(new Func1<Integer, String>() {

            @Override
            public String call(Integer t1) {
                return t1 + ""-value-from-b"";
            }
        }).take(1000000).subscribe(new TestStringObserver(onNextSum, start));

    }

    public void runCompositionTest(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTest"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();
        // 50 levels of composition (same function so that's not the cost)
        Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .subscribe(new TestObserver(onNextSum, start, aggregateTime));
    }

    public void runNonCompositionalTestWithDirectLoop(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithDirectLoop"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (int i = 0; i < 50; i++) {
                    t1 = m.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    public void runNonCompositionalTestWithArrayOfFunctions(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithArrayOfFunctions"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();
        @SuppressWarnings(""rawtypes"")
        final Func1[] functionCalls = new Func1<?, ?>[50];
        for (int i = 0; i < 50; i++) {
            functionCalls[i] = m;
        }

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @SuppressWarnings(""unchecked"")
            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (Func1<Integer, Integer> f : functionCalls) {
                    t1 = f.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    private static final class TestObserver implements Observer<Integer> {
        private final AtomicInteger onNextSum;
        private final AtomicLong aggregateTime;
        private final long start;

        private TestObserver(AtomicInteger onNextSum, long start, AtomicLong aggregateTime) {
            this.onNextSum = onNextSum;
            this.start = start;
            this.aggregateTime = aggregateTime;
        }

        @Override
        public void onNext(Integer i) {
            onNextSum.addAndGet(i);
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            double timeInMilliseconds = ((double) (end - start)) / 1000 / 1000;
            aggregateTime.addAndGet(Math.round(timeInMilliseconds));
            System.out.println(""Sum: "" + onNextSum.get() + "" Time: "" + timeInMilliseconds + ""ms"");
        }
    }

    private static final class TestStringObserver implements Observer<String> {
        private final AtomicInteger onNextSum;
        private final long start;

        private TestStringObserver(AtomicInteger onNextSum, long start) {
            this.onNextSum = onNextSum;
            this.start = start;
        }

        @Override
        public void onNext(String i) {
            //            System.out.println(i);
            onNextSum.incrementAndGet();
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            System.out.println(""Count: "" + onNextSum.get() + "" Time: "" + ((double) (end - start)) / 1000 / 1000 + ""ms"");
        }
    }

    private static class MathFunction implements Func1<Integer, Integer> {

        @Override
        public Integer call(Integer t1) {
            return t1 + 1;
        }

    }

}
",    public void runCompositionTest(Integer[] values),"    public void runCompositionTest(AtomicLong aggregateTime, Integer[] values)"
60912673554199663153769294cf12f93b032bc0,"package rx.performance;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable;
import rx.Observer;
import rx.util.functions.Func1;

public class PerformanceTest {

    /*
     * Example run:
     * 
     * compositionTestTotalTime: 2432
     * nonCompositionalTestWithDirectLoopTotalTime: 2043
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1925
     * 
     * compositionTestTotalTime: 2362
     * nonCompositionalTestWithDirectLoopTotalTime: 1910
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1823
     * 
     * compositionTestTotalTime: 2456
     * nonCompositionalTestWithDirectLoopTotalTime: 2004
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 2014
     */

    /*
     * >>> Statically typed <<<
     * 
     * Without chaining:
     * 
     * Sum: 710082754 Time: 130.683ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 21.011ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 20.84ms
     * 
     * 
     * With chaining (composition collapsing):
     * 
     * Sum: 710082754 Time: 28.787ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 19.525ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 19.175ms
     * 
     * 
     * >>> Dynamically typed <<<
     * 
     * When going via generic Functions.execute even with chained sequence:
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 577.3ms <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< very bad when dynamic
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 31.591ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 38.093ms
     * runCompositionTest
     * 
     * 
     * With Function memoization so we only pay dynamic price during sequence setup, not in onNext:
     * 
     * 
     * Using ArrayList
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 27.078ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.911ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.852ms
     * 
     * 
     * Using LinkedBlockingQueue
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 46.532ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.946ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.746ms
     */

    public static void main(String[] args) {
        PerformanceTest test = new PerformanceTest();
        Integer[] values = new Integer[100001];
        for (int i = 0; i < values.length; i++) {
            values[i] = i;
        }

        AtomicLong compositionTestTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithDirectLoopTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithArrayOfFunctionsTotalTime = new AtomicLong();

        for (int i = 0; i < 100; i++) {
            System.out.println(""-------------------------------"");
            //            test.runCompositionTestWithMultipleOperations(values);
            test.runCompositionTest(compositionTestTotalTime, values);
            test.runNonCompositionalTestWithDirectLoop(nonCompositionalTestWithDirectLoopTotalTime, values);
            test.runNonCompositionalTestWithArrayOfFunctions(nonCompositionalTestWithArrayOfFunctionsTotalTime, values);
        }

        System.out.println(""-------------------------------"");
        System.out.println(""compositionTestTotalTime: "" + compositionTestTotalTime.get());
        System.out.println(""nonCompositionalTestWithDirectLoopTotalTime: "" + nonCompositionalTestWithDirectLoopTotalTime.get());
        System.out.println(""nonCompositionalTestWithArrayOfFunctionsTotalTime: "" + nonCompositionalTestWithArrayOfFunctionsTotalTime.get());
    }

    @SuppressWarnings(""unchecked"")
    public void runCompositionTestWithMultipleOperations(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTestWithMultipleOperations"");

        // old code before memoizing
        // Count: 200002 Time: 403.095ms

        // new code with memoizing but no chaining
        // Count: 200002 Time: 103.128ms

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();

        Observable<Integer> a = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        final Observable<Integer> b = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        Observable.merge(a, b).filter(new Func1<Integer, Boolean>() {

            @Override
            public Boolean call(Integer t1) {
                return t1 > 10;
            }

        }).map(new Func1<Integer, String>() {

            @Override
            public String call(Integer t1) {
                return t1 + ""-value-from-b"";
            }
        }).take(1000000).subscribe(new TestStringObserver(onNextSum, start));

    }

    public void runCompositionTest(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTest"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();
        // 50 levels of composition (same function so that's not the cost)
        Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .subscribe(new TestObserver(onNextSum, start, aggregateTime));
    }

    public void runNonCompositionalTestWithDirectLoop(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithDirectLoop"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (int i = 0; i < 50; i++) {
                    t1 = m.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    public void runNonCompositionalTestWithArrayOfFunctions(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithArrayOfFunctions"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();
        @SuppressWarnings(""rawtypes"")
        final Func1[] functionCalls = new Func1<?, ?>[50];
        for (int i = 0; i < 50; i++) {
            functionCalls[i] = m;
        }

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @SuppressWarnings(""unchecked"")
            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (Func1<Integer, Integer> f : functionCalls) {
                    t1 = f.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    private static final class TestObserver implements Observer<Integer> {
        private final AtomicInteger onNextSum;
        private final AtomicLong aggregateTime;
        private final long start;

        private TestObserver(AtomicInteger onNextSum, long start, AtomicLong aggregateTime) {
            this.onNextSum = onNextSum;
            this.start = start;
            this.aggregateTime = aggregateTime;
        }

        @Override
        public void onNext(Integer i) {
            onNextSum.addAndGet(i);
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            double timeInMilliseconds = ((double) (end - start)) / 1000 / 1000;
            aggregateTime.addAndGet(Math.round(timeInMilliseconds));
            System.out.println(""Sum: "" + onNextSum.get() + "" Time: "" + timeInMilliseconds + ""ms"");
        }
    }

    private static final class TestStringObserver implements Observer<String> {
        private final AtomicInteger onNextSum;
        private final long start;

        private TestStringObserver(AtomicInteger onNextSum, long start) {
            this.onNextSum = onNextSum;
            this.start = start;
        }

        @Override
        public void onNext(String i) {
            //            System.out.println(i);
            onNextSum.incrementAndGet();
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            System.out.println(""Count: "" + onNextSum.get() + "" Time: "" + ((double) (end - start)) / 1000 / 1000 + ""ms"");
        }
    }

    private static class MathFunction implements Func1<Integer, Integer> {

        @Override
        public Integer call(Integer t1) {
            return t1 + 1;
        }

    }

}
",    public void runNonCompositionalTestWithDirectLoop(Integer[] values),"    public void runNonCompositionalTestWithDirectLoop(AtomicLong aggregateTime, Integer[] values)"
60912673554199663153769294cf12f93b032bc0,"package rx.performance;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable;
import rx.Observer;
import rx.util.functions.Func1;

public class PerformanceTest {

    /*
     * Example run:
     * 
     * compositionTestTotalTime: 2432
     * nonCompositionalTestWithDirectLoopTotalTime: 2043
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1925
     * 
     * compositionTestTotalTime: 2362
     * nonCompositionalTestWithDirectLoopTotalTime: 1910
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 1823
     * 
     * compositionTestTotalTime: 2456
     * nonCompositionalTestWithDirectLoopTotalTime: 2004
     * nonCompositionalTestWithArrayOfFunctionsTotalTime: 2014
     */

    /*
     * >>> Statically typed <<<
     * 
     * Without chaining:
     * 
     * Sum: 710082754 Time: 130.683ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 21.011ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 20.84ms
     * 
     * 
     * With chaining (composition collapsing):
     * 
     * Sum: 710082754 Time: 28.787ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 19.525ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 19.175ms
     * 
     * 
     * >>> Dynamically typed <<<
     * 
     * When going via generic Functions.execute even with chained sequence:
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 577.3ms <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< very bad when dynamic
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 31.591ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 38.093ms
     * runCompositionTest
     * 
     * 
     * With Function memoization so we only pay dynamic price during sequence setup, not in onNext:
     * 
     * 
     * Using ArrayList
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 27.078ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.911ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.852ms
     * 
     * 
     * Using LinkedBlockingQueue
     * 
     * runCompositionTest
     * Sum: 710082754 Time: 46.532ms
     * runNonCompositionalTestWithDirectLoop
     * Sum: 710082754 Time: 18.946ms
     * runNonCompositionalTestWithArrayOfFunctions
     * Sum: 710082754 Time: 18.746ms
     */

    public static void main(String[] args) {
        PerformanceTest test = new PerformanceTest();
        Integer[] values = new Integer[100001];
        for (int i = 0; i < values.length; i++) {
            values[i] = i;
        }

        AtomicLong compositionTestTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithDirectLoopTotalTime = new AtomicLong();
        AtomicLong nonCompositionalTestWithArrayOfFunctionsTotalTime = new AtomicLong();

        for (int i = 0; i < 100; i++) {
            System.out.println(""-------------------------------"");
            //            test.runCompositionTestWithMultipleOperations(values);
            test.runCompositionTest(compositionTestTotalTime, values);
            test.runNonCompositionalTestWithDirectLoop(nonCompositionalTestWithDirectLoopTotalTime, values);
            test.runNonCompositionalTestWithArrayOfFunctions(nonCompositionalTestWithArrayOfFunctionsTotalTime, values);
        }

        System.out.println(""-------------------------------"");
        System.out.println(""compositionTestTotalTime: "" + compositionTestTotalTime.get());
        System.out.println(""nonCompositionalTestWithDirectLoopTotalTime: "" + nonCompositionalTestWithDirectLoopTotalTime.get());
        System.out.println(""nonCompositionalTestWithArrayOfFunctionsTotalTime: "" + nonCompositionalTestWithArrayOfFunctionsTotalTime.get());
    }

    @SuppressWarnings(""unchecked"")
    public void runCompositionTestWithMultipleOperations(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTestWithMultipleOperations"");

        // old code before memoizing
        // Count: 200002 Time: 403.095ms

        // new code with memoizing but no chaining
        // Count: 200002 Time: 103.128ms

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();

        Observable<Integer> a = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        final Observable<Integer> b = Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m);

        Observable.merge(a, b).filter(new Func1<Integer, Boolean>() {

            @Override
            public Boolean call(Integer t1) {
                return t1 > 10;
            }

        }).map(new Func1<Integer, String>() {

            @Override
            public String call(Integer t1) {
                return t1 + ""-value-from-b"";
            }
        }).take(1000000).subscribe(new TestStringObserver(onNextSum, start));

    }

    public void runCompositionTest(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runCompositionTest"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();
        // 50 levels of composition (same function so that's not the cost)
        Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .subscribe(new TestObserver(onNextSum, start, aggregateTime));
    }

    public void runNonCompositionalTestWithDirectLoop(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithDirectLoop"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (int i = 0; i < 50; i++) {
                    t1 = m.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    public void runNonCompositionalTestWithArrayOfFunctions(AtomicLong aggregateTime, Integer[] values) {
        System.out.println(""runNonCompositionalTestWithArrayOfFunctions"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();
        final MathFunction m = new MathFunction();
        @SuppressWarnings(""rawtypes"")
        final Func1[] functionCalls = new Func1<?, ?>[50];
        for (int i = 0; i < 50; i++) {
            functionCalls[i] = m;
        }

        Observable.from(values).map(new Func1<Integer, Integer>() {

            @SuppressWarnings(""unchecked"")
            @Override
            public Integer call(Integer t1) {
                // iterate the 50 times here in a loop rather than via composition
                for (Func1<Integer, Integer> f : functionCalls) {
                    t1 = f.call(t1);
                }
                return t1;
            }

        }).subscribe(new TestObserver(onNextSum, start, aggregateTime));

    }

    private static final class TestObserver implements Observer<Integer> {
        private final AtomicInteger onNextSum;
        private final AtomicLong aggregateTime;
        private final long start;

        private TestObserver(AtomicInteger onNextSum, long start, AtomicLong aggregateTime) {
            this.onNextSum = onNextSum;
            this.start = start;
            this.aggregateTime = aggregateTime;
        }

        @Override
        public void onNext(Integer i) {
            onNextSum.addAndGet(i);
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            double timeInMilliseconds = ((double) (end - start)) / 1000 / 1000;
            aggregateTime.addAndGet(Math.round(timeInMilliseconds));
            System.out.println(""Sum: "" + onNextSum.get() + "" Time: "" + timeInMilliseconds + ""ms"");
        }
    }

    private static final class TestStringObserver implements Observer<String> {
        private final AtomicInteger onNextSum;
        private final long start;

        private TestStringObserver(AtomicInteger onNextSum, long start) {
            this.onNextSum = onNextSum;
            this.start = start;
        }

        @Override
        public void onNext(String i) {
            //            System.out.println(i);
            onNextSum.incrementAndGet();
        }

        @Override
        public void onError(Exception e) {
            e.printStackTrace();
        }

        @Override
        public void onCompleted() {
            long end = System.nanoTime();
            System.out.println(""Count: "" + onNextSum.get() + "" Time: "" + ((double) (end - start)) / 1000 / 1000 + ""ms"");
        }
    }

    private static class MathFunction implements Func1<Integer, Integer> {

        @Override
        public Integer call(Integer t1) {
            return t1 + 1;
        }

    }

}
",    public void runNonCompositionalTestWithArrayOfFunctions(Integer[] values),"    public void runNonCompositionalTestWithArrayOfFunctions(AtomicLong aggregateTime, Integer[] values)"
d5e5df402bf4d18075dbf11f311793399a682e2e,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.operators;

import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import org.junit.Test;
import org.mockito.InOrder;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

import rx.Observable;
import rx.Observable.OnSubscribeFunc;
import rx.Observer;
import rx.Scheduler;
import rx.Subscription;
import rx.schedulers.ImmediateScheduler;
import rx.schedulers.Schedulers;
import rx.schedulers.TestScheduler;
import rx.schedulers.TrampolineScheduler;
import rx.subscriptions.BooleanSubscription;
import rx.util.functions.Action0;
import rx.util.functions.Action1;
import rx.util.functions.Func1;

public class OperatorObserveOnTest {

    /**
     * This is testing a no-op path since it uses Schedulers.immediate() which will not do scheduling.
     */
    @Test
    @SuppressWarnings(""unchecked"")
    public void testObserveOn() {
        Observer<Integer> observer = mock(Observer.class);
        Observable.from(1, 2, 3).observeOn(Schedulers.immediate()).subscribe(observer);

        verify(observer, times(1)).onNext(1);
        verify(observer, times(1)).onNext(2);
        verify(observer, times(1)).onNext(3);
        verify(observer, times(1)).onCompleted();
    }

    @Test
    @SuppressWarnings(""unchecked"")
    public void testOrdering() throws InterruptedException {
        Observable<String> obs = Observable.from(""one"", null, ""two"", ""three"", ""four"");

        Observer<String> observer = mock(Observer.class);

        InOrder inOrder = inOrder(observer);

        final CountDownLatch completedLatch = new CountDownLatch(1);
        doAnswer(new Answer<Void>() {

            @Override
            public Void answer(InvocationOnMock invocation) throws Throwable {
                completedLatch.countDown();
                return null;
            }
        }).when(observer).onCompleted();

        obs.observeOn(Schedulers.computation()).subscribe(observer);

        if (!completedLatch.await(1000, TimeUnit.MILLISECONDS)) {
            fail(""timed out waiting"");
        }

        inOrder.verify(observer, times(1)).onNext(""one"");
        inOrder.verify(observer, times(1)).onNext(null);
        inOrder.verify(observer, times(1)).onNext(""two"");
        inOrder.verify(observer, times(1)).onNext(""three"");
        inOrder.verify(observer, times(1)).onNext(""four"");
        inOrder.verify(observer, times(1)).onCompleted();
        inOrder.verifyNoMoreInteractions();
    }

    @Test
    @SuppressWarnings(""unchecked"")
    public void testThreadName() throws InterruptedException {
        System.out.println(""Main Thread: "" + Thread.currentThread().getName());
        Observable<String> obs = Observable.from(""one"", null, ""two"", ""three"", ""four"");

        Observer<String> observer = mock(Observer.class);
        final String parentThreadName = Thread.currentThread().getName();

        final CountDownLatch completedLatch = new CountDownLatch(1);

        // assert subscribe is on main thread
        obs = obs.doOnNext(new Action1<String>() {

            @Override
            public void call(String s) {
                String threadName = Thread.currentThread().getName();
                System.out.println(""Source ThreadName: "" + threadName + ""  Expected => "" + parentThreadName);
                assertEquals(parentThreadName, threadName);
            }

        });

        // assert observe is on new thread
        obs.observeOn(Schedulers.newThread()).doOnNext(new Action1<String>() {

            @Override
            public void call(String t1) {
                String threadName = Thread.currentThread().getName();
                boolean correctThreadName = threadName.startsWith(""RxNewThreadScheduler"");
                System.out.println(""ObserveOn ThreadName: "" + threadName + ""  Correct => "" + correctThreadName);
                assertTrue(correctThreadName);
            }

        }).finallyDo(new Action0() {

            @Override
            public void call() {
                completedLatch.countDown();

            }
        }).subscribe(observer);

        if (!completedLatch.await(1000, TimeUnit.MILLISECONDS)) {
            fail(""timed out waiting"");
        }

        verify(observer, never()).onError(any(Throwable.class));
        verify(observer, times(5)).onNext(any(String.class));
        verify(observer, times(1)).onCompleted();
    }

    @Test
    public void observeOnTheSameSchedulerTwice() {
        Scheduler scheduler = Schedulers.immediate();

        Observable<Integer> o = Observable.from(1, 2, 3);
        Observable<Integer> o2 = o.observeOn(scheduler);

        @SuppressWarnings(""unchecked"")
        Observer<Object> observer1 = mock(Observer.class);
        @SuppressWarnings(""unchecked"")
        Observer<Object> observer2 = mock(Observer.class);

        InOrder inOrder1 = inOrder(observer1);
        InOrder inOrder2 = inOrder(observer2);

        o2.subscribe(observer1);
        o2.subscribe(observer2);

        inOrder1.verify(observer1, times(1)).onNext(1);
        inOrder1.verify(observer1, times(1)).onNext(2);
        inOrder1.verify(observer1, times(1)).onNext(3);
        inOrder1.verify(observer1, times(1)).onCompleted();
        verify(observer1, never()).onError(any(Throwable.class));
        inOrder1.verifyNoMoreInteractions();

        inOrder2.verify(observer2, times(1)).onNext(1);
        inOrder2.verify(observer2, times(1)).onNext(2);
        inOrder2.verify(observer2, times(1)).onNext(3);
        inOrder2.verify(observer2, times(1)).onCompleted();
        verify(observer2, never()).onError(any(Throwable.class));
        inOrder2.verifyNoMoreInteractions();
    }

    @Test
    public void observeSameOnMultipleSchedulers() {
        TestScheduler scheduler1 = new TestScheduler();
        TestScheduler scheduler2 = new TestScheduler();

        Observable<Integer> o = Observable.from(1, 2, 3);
        Observable<Integer> o1 = o.observeOn(scheduler1);
        Observable<Integer> o2 = o.observeOn(scheduler2);

        @SuppressWarnings(""unchecked"")
        Observer<Object> observer1 = mock(Observer.class);
        @SuppressWarnings(""unchecked"")
        Observer<Object> observer2 = mock(Observer.class);

        InOrder inOrder1 = inOrder(observer1);
        InOrder inOrder2 = inOrder(observer2);

        o1.subscribe(observer1);
        o2.subscribe(observer2);

        scheduler1.advanceTimeBy(1, TimeUnit.SECONDS);
        scheduler2.advanceTimeBy(1, TimeUnit.SECONDS);

        inOrder1.verify(observer1, times(1)).onNext(1);
        inOrder1.verify(observer1, times(1)).onNext(2);
        inOrder1.verify(observer1, times(1)).onNext(3);
        inOrder1.verify(observer1, times(1)).onCompleted();
        verify(observer1, never()).onError(any(Throwable.class));
        inOrder1.verifyNoMoreInteractions();

        inOrder2.verify(observer2, times(1)).onNext(1);
        inOrder2.verify(observer2, times(1)).onNext(2);
        inOrder2.verify(observer2, times(1)).onNext(3);
        inOrder2.verify(observer2, times(1)).onCompleted();
        verify(observer2, never()).onError(any(Throwable.class));
        inOrder2.verifyNoMoreInteractions();
    }

    /**
     * Confirm that running on a NewThreadScheduler uses the same thread for the entire stream
     */
    @Test
    public void testObserveOnWithNewThreadScheduler() {
        final AtomicInteger count = new AtomicInteger();
        final int _multiple = 99;

        Observable.range(1, 100000).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                return t1 * _multiple;
            }

        }).observeOn(Schedulers.newThread())
                .toBlockingObservable().forEach(new Action1<Integer>() {

                    @Override
                    public void call(Integer t1) {
                        assertEquals(count.incrementAndGet() * _multiple, t1.intValue());
                        assertTrue(Thread.currentThread().getName().startsWith(""RxNewThreadScheduler""));
                    }

                });
    }

    /**
     * Confirm that running on a ThreadPoolScheduler allows multiple threads but is still ordered.
     */
    @Test
    public void testObserveOnWithThreadPoolScheduler() {
        final AtomicInteger count = new AtomicInteger();
        final int _multiple = 99;

        Observable.range(1, 100000).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                return t1 * _multiple;
            }

        }).observeOn(Schedulers.computation())
                .toBlockingObservable().forEach(new Action1<Integer>() {

                    @Override
                    public void call(Integer t1) {
                        assertEquals(count.incrementAndGet() * _multiple, t1.intValue());
                        assertTrue(Thread.currentThread().getName().startsWith(""RxComputationThreadPool""));
                    }

                });
    }

    /**
     * Attempts to confirm that when pauses exist between events, the ScheduledObserver
     * does not lose or reorder any events since the scheduler will not block, but will
     * be re-scheduled when it receives new events after each pause.
     * 
     * 
     * This is non-deterministic in proving success, but if it ever fails (non-deterministically)
     * it is a sign of potential issues as thread-races and scheduling should not affect output.
     */
    @Test
    public void testObserveOnOrderingConcurrency() {
        final AtomicInteger count = new AtomicInteger();
        final int _multiple = 99;

        Observable.range(1, 10000).map(new Func1<Integer, Integer>() {

            @Override
            public Integer call(Integer t1) {
                if (randomIntFrom0to100() > 98) {
                    try {
                        Thread.sleep(2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                return t1 * _multiple;
            }

        }).observeOn(Schedulers.computation())
                .toBlockingObservable().forEach(new Action1<Integer>() {

                    @Override
                    public void call(Integer t1) {
                        assertEquals(count.incrementAndGet() * _multiple, t1.intValue());
                        assertTrue(Thread.currentThread().getName().startsWith(""RxComputationThreadPool""));
                    }

                });
    }

    @Test
    public void testNonBlockingOuterWhileBlockingOnNext() throws InterruptedException {

        final CountDownLatch latch = new CountDownLatch(1);
        final AtomicLong completeTime = new AtomicLong();
        // use subscribeOn to make async, observeOn to move
        Observable.range(1, 1000).subscribeOn(Schedulers.newThread()).observeOn(Schedulers.newThread()).subscribe(new Observer<Integer>() {

            @Override
            public void onCompleted() {
                System.out.println(""onCompleted"");
                completeTime.set(System.nanoTime());
                latch.countDown();
            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Integer t) {

            }

        });

        long afterSubscribeTime = System.nanoTime();
        System.out.println(""After subscribe: "" + latch.getCount());
        assertEquals(1, latch.getCount());
        latch.await();
        assertTrue(completeTime.get() > afterSubscribeTime);
        System.out.println(""onComplete nanos after subscribe: "" + (completeTime.get() - afterSubscribeTime));
    }

    @Test
    public final void testBackpressureOnFastProducerSlowConsumerWithUnsubscribeNewThread() throws InterruptedException {
        testBackpressureOnFastProducerSlowConsumerWithUnsubscribe(Schedulers.newThread(), 1);
    }

    @Test
    public final void testBackpressureOnFastProducerSlowConsumerWithUnsubscribeNewThreadAndBuffer8() throws InterruptedException {
        testBackpressureOnFastProducerSlowConsumerWithUnsubscribe(Schedulers.newThread(), 8);
    }

    @Test
    public final void testBackpressureOnFastProducerSlowConsumerWithUnsubscribeIO() throws InterruptedException {
        testBackpressureOnFastProducerSlowConsumerWithUnsubscribe(Schedulers.io(), 1);
    }

    @Test
    public final void testBackpressureOnFastProducerSlowConsumerWithUnsubscribeTrampoline() throws InterruptedException {
        testBackpressureOnFastProducerSlowConsumerWithUnsubscribe(Schedulers.trampoline(), 1);
    }

    @Test
    public final void testBackpressureOnFastProducerSlowConsumerWithUnsubscribeTestScheduler() throws InterruptedException {
        testBackpressureOnFastProducerSlowConsumerWithUnsubscribe(Schedulers.test(), 1);
    }

    @Test
    public final void testBackpressureOnFastProducerSlowConsumerWithUnsubscribeComputation() throws InterruptedException {
        testBackpressureOnFastProducerSlowConsumerWithUnsubscribe(Schedulers.computation(), 1);
    }

    private final void testBackpressureOnFastProducerSlowConsumerWithUnsubscribe(Scheduler scheduler, int bufferSize) throws InterruptedException {
        final AtomicInteger countEmitted = new AtomicInteger();
        final AtomicInteger countTaken = new AtomicInteger();
        int value = Observable.create(new OnSubscribeFunc<Integer>() {

            @Override
            public Subscription onSubscribe(final Observer<? super Integer> o) {
                final BooleanSubscription s = BooleanSubscription.create();
                Thread t = new Thread(new Runnable() {

                    @Override
                    public void run() {
                        int i = 1;
                        while (!s.isUnsubscribed() && i <= 100) {
                            //                            System.out.println(""onNext from fast producer ["" + Thread.currentThread() + ""]: "" + i);
                            o.onNext(i++);
                        }
                        o.onCompleted();
                    }
                });
                t.setDaemon(true);
                t.start();
                return s;
            }
        }).doOnNext(new Action1<Integer>() {

            @Override
            public void call(Integer i) {
                countEmitted.incrementAndGet();
            }
        }).doOnCompleted(new Action0() {

            @Override
            public void call() {
                //                System.out.println(""-------- Done Emitting from Source ---------"");
            }
        }).observeOn(scheduler, bufferSize).doOnNext(new Action1<Integer>() {

            @Override
            public void call(Integer i) {
                //                System.out.println("">> onNext to slowConsumer  ["" + Thread.currentThread() + ""] pre-take: "" + i);
                //force it to be slower than the producer
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                countTaken.incrementAndGet();
            }
        }).take(10).doOnNext(new Action1<Integer>() {

            @Override
            public void call(Integer t) {
                System.out.println(""*********** value: "" + t);
            }

        }).toBlockingObservable().last();

        if (scheduler instanceof TrampolineScheduler || scheduler instanceof ImmediateScheduler || scheduler instanceof TestScheduler) {
            // since there is no concurrency it will block and only emit as many as it can process
            assertEquals(10, countEmitted.get());
        } else {
            // the others with concurrency should not emit all 100 ... but 10 + 2 in the pipeline
            // NOTE: The +2 could change if the implementation of the queue logic changes. See Javadoc at top of class.
            assertEquals(11, countEmitted.get(), bufferSize); // can be up to 11 + bufferSize
        }
        // number received after take (but take will filter any extra)
        assertEquals(10, value);
        // so we also want to check the doOnNext after observeOn to see if it got unsubscribed
        Thread.sleep(200); // let time pass to see if the scheduler is still doing work
        // we expect only 10 to make it through the observeOn side
        assertEquals(10, countTaken.get());
    }

    private static int randomIntFrom0to100() {
        // XORShift instead of Math.random http://javamex.com/tutorials/random_numbers/xorshift.shtml
        long x = System.nanoTime();
        x ^= (x << 21);
        x ^= (x >>> 35);
        x ^= (x << 4);
        return Math.abs((int) x % 100);
    }
}
",    private final void testBackpressureOnFastProducerSlowConsumerWithUnsubscribe(Scheduler scheduler),"    private final void testBackpressureOnFastProducerSlowConsumerWithUnsubscribe(Scheduler scheduler, int bufferSize)"
1c00aa6cc578bfc5e792aa5409ff1f336529ac6d," /**
  * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package rx.subjects;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import rx.Observable.OnSubscribe;

import rx.Observer;
import rx.Subscriber;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.functions.Actions;
import rx.operators.NotificationLite;
import rx.subscriptions.Subscriptions;

/**
 * Represents the typical state and OnSubscribe logic for a Subject implementation.
 * @param <T> the source and return value type
 */
@SuppressWarnings({""unchecked"", ""rawtypes""})
/* package */final class SubjectSubscriptionManager<T> implements OnSubscribe<T> {
    /** Contains the unsubscription flag and the array of active subscribers. */
    volatile State<T> state = State.EMPTY;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, State> STATE_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, State.class, ""state"");
    /** Stores the latest value or the terminal value for some Subjects. */
    volatile Object latest;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, Object> LATEST_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, Object.class, ""latest"");
    /** Indicates that the subject is active (cheaper than checking the state).*/
    boolean active = true;
    /** Action called when a new subscriber subscribes but before it is added to the state. */
    Action1<SubjectObserver<T>> onStart = Actions.empty();
    /** Action called after the subscriber has been added to the state. */
    Action1<SubjectObserver<T>> onAdded = Actions.empty();
    /** Action called when the subscriber wants to subscribe to a terminal state. */
    Action1<SubjectObserver<T>> onTerminated = Actions.empty();
    /** The notification lite. */
    public final NotificationLite<T> nl = NotificationLite.instance();
    @Override
    public void call(final Subscriber<? super T> child) {
        SubjectObserver<T> bo = new SubjectObserver<T>(child);
        addUnsubscriber(child, bo);
        onStart.call(bo);
        if (add(bo) && child.isUnsubscribed()) {
            remove(bo);
        }
    }
    /** Registers the unsubscribe action for the given subscriber. */
    void addUnsubscriber(Subscriber<? super T> child, final SubjectObserver<T> bo) {
        child.add(Subscriptions.create(new Action0() {
            @Override
            public void call() {
                remove(bo);
            }
        }));
    }    
    /** Set the latest NotificationLite value. */
    void set(Object value) {
        latest = value;
    }
    /** @return Retrieve the latest NotificationLite value */
    Object get() {
        return latest;
    }
    /** @return the array of active subscribers, don't write into the array! */
    SubjectObserver<T>[] observers() {
        return state.observers;
    }
    /**
     * Try to atomically add a SubjectObserver to the active state.
     * @param o the SubjectObserver to add
     * @return false if the subject is already in its terminal state
     */
    boolean add(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                onTerminated.call(o);
                return false;
            }
            State newState = oldState.add(o);
            if (STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                onAdded.call(o);
                return true;
            }
        } while (true);
    }
    /**
     * Atomically remove the specified SubjectObserver from the active observers.
     * @param o the SubjectObserver to remove
     */
    void remove(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                return;
            }
            State newState = oldState.remove(o);
            if (newState == oldState || STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                return;
            }
        } while (true);
    }
    /**
     * Set a new latest NotificationLite value and return the active observers.
     * @param n the new latest value
     * @return the array of SubjectObservers, don't write into the array!
     */
    SubjectObserver<T>[] next(Object n) {
        set(n);
        return state.observers;
    }
    /**
     * Atomically set the terminal NotificationLite value (which could be any of the 3),
     * clear the active observers and return the last active observers.
     * @param n the terminal value
     * @return the last active SubjectObservers
     */
    SubjectObserver<T>[] terminate(Object n) {
        set(n);
        active = false;

        State<T> oldState = state;
        if (oldState.terminated) {
            return State.NO_OBSERVERS;
        }
        return STATE_UPDATER.getAndSet(this, State.TERMINATED).observers;
    }

    /** State-machine representing the termination state and active SubjectObservers. */
    protected static final class State<T> {
        final boolean terminated;
        final SubjectObserver[] observers;
        static final SubjectObserver[] NO_OBSERVERS = new SubjectObserver[0];
        static final State TERMINATED = new State(true, NO_OBSERVERS);
        static final State EMPTY = new State(false, NO_OBSERVERS);
        
        public State(boolean terminated, SubjectObserver[] observers) {
            this.terminated = terminated;
            this.observers = observers;
        }
        public State add(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            SubjectObserver[] b = new SubjectObserver[n + 1];
            System.arraycopy(observers, 0, b, 0, n);
            b[n] = o;
            return new State<T>(terminated, b);
        }
        public State remove(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            if (n == 1 && a[0] == o) {
                return EMPTY;
            } else
                if (n == 0) {
                    return this;
                }
            SubjectObserver[] b = new SubjectObserver[n - 1];
            int j = 0;
            for (int i = 0; i < n; i++) {
                SubjectObserver ai = a[i];
                if (ai != o) {
                    if (j == n - 1) {
                        return this;
                    }
                    b[j++] = ai;
                }
            }
            if (j == 0) {
                return EMPTY;
            }
            if (j < n - 1) {
                SubjectObserver[] c = new SubjectObserver[j];
                System.arraycopy(b, 0, c, 0, j);
                b = c;
            }
            return new State<T>(terminated, b);
        }
    }
    
    /**
     * Observer wrapping the actual Subscriber and providing various
     * emission facilities.
     * @param <T> the consumed value type of the actual Observer
     */
    protected static final class SubjectObserver<T> implements Observer<T> {
        /** The actual Observer. */
        final Observer<? super T> actual;
        /** Was the emitFirst run? Guarded by this. */
        boolean first = true;
        /** Guarded by this. */
        boolean emitting;
        /** Guarded by this. */
        List<Object> queue;
        /* volatile */boolean fastPath;
        /** Indicate that the observer has caught up. */
        protected volatile boolean caughtUp;
        /** Indicate where the observer is at replaying. */
        private volatile Object index;
        public SubjectObserver(Observer<? super T> actual) {
            this.actual = actual;
        }
        @Override
        public void onNext(T t) {
            actual.onNext(t);
        }
        @Override
        public void onError(Throwable e) {
            actual.onError(e);
        }
        @Override
        public void onCompleted() {
            actual.onCompleted();
        }
        /**
         * Emits the given NotificationLite value and
         * prevents the emitFirst to run if not already run.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitNext(Object n, final NotificationLite<T> nl) {
            if (!fastPath) {
                synchronized (this) {
                    first = false;
                    if (emitting) {
                        if (queue == null) {
                            queue = new ArrayList<Object>();
                        }
                        queue.add(n);
                        return;
                    }
                }
                fastPath = true;
            }
            nl.accept(actual, n);
        }
        /**
         * Tries to emit a NotificationLite value as the first
         * value and drains the queue as long as possible.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitFirst(Object n, final NotificationLite<T> nl) {
            synchronized (this) {
                if (!first || emitting) {
                    return;
                }
                first = false;
                emitting = n != null;
            }
            if (n != null) {
                emitLoop(null, n, nl);
            }
        }
        /**
         * Emits the contents of the queue as long as there are values.
         * @param localQueue the initial queue contents
         * @param current the current content to emit
         * @param nl the type-appropriate notification lite object
         */
        protected void emitLoop(List<Object> localQueue, Object current, final NotificationLite<T> nl) {
            boolean once = true;
            boolean skipFinal = false;
            try {
                do {
                    if (localQueue != null) {
                        for (Object n : localQueue) {
                            accept(n, nl);
                        }
                    }
                    if (once) {
                        once = false;
                        accept(current, nl);
                    }
                    synchronized (this) {
                        localQueue = queue;
                        queue = null;
                        if (localQueue == null) {
                            emitting = false;
                            skipFinal = true;
                            break;
                        }
                    }
                } while (true);
            } finally {
                if (!skipFinal) {
                    synchronized (this) {
                        emitting = false;
                    }
                }
            }
        }
        /**
         * Dispatches a NotificationLite value to the actual Observer.
         * @param n the value to dispatch
         * @param nl the type-appropriate notification lite object
         */
        protected void accept(Object n, final NotificationLite<T> nl) {
            if (n != null) {
                nl.accept(actual, n);
            }
        }
        
        /** @return the actual Observer. */
        protected Observer<? super T> getActual() {
            return actual;
        }
        /**
         * Returns the stored index.
         * @param <I> the index type
         * @return the index value
         */
        @SuppressWarnings(""unchecked"")
        public <I> I index() {
            return (I)index;
        }
        /**
         * Sets a new index value.
         * @param newIndex the new index value
         */
        public void index(Object newIndex) {
            this.index = newIndex;
        }
    }
}",        protected void emitNext(Object n),"        protected void emitNext(Object n, final NotificationLite<T> nl)"
1c00aa6cc578bfc5e792aa5409ff1f336529ac6d," /**
  * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package rx.subjects;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import rx.Observable.OnSubscribe;

import rx.Observer;
import rx.Subscriber;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.functions.Actions;
import rx.operators.NotificationLite;
import rx.subscriptions.Subscriptions;

/**
 * Represents the typical state and OnSubscribe logic for a Subject implementation.
 * @param <T> the source and return value type
 */
@SuppressWarnings({""unchecked"", ""rawtypes""})
/* package */final class SubjectSubscriptionManager<T> implements OnSubscribe<T> {
    /** Contains the unsubscription flag and the array of active subscribers. */
    volatile State<T> state = State.EMPTY;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, State> STATE_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, State.class, ""state"");
    /** Stores the latest value or the terminal value for some Subjects. */
    volatile Object latest;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, Object> LATEST_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, Object.class, ""latest"");
    /** Indicates that the subject is active (cheaper than checking the state).*/
    boolean active = true;
    /** Action called when a new subscriber subscribes but before it is added to the state. */
    Action1<SubjectObserver<T>> onStart = Actions.empty();
    /** Action called after the subscriber has been added to the state. */
    Action1<SubjectObserver<T>> onAdded = Actions.empty();
    /** Action called when the subscriber wants to subscribe to a terminal state. */
    Action1<SubjectObserver<T>> onTerminated = Actions.empty();
    /** The notification lite. */
    public final NotificationLite<T> nl = NotificationLite.instance();
    @Override
    public void call(final Subscriber<? super T> child) {
        SubjectObserver<T> bo = new SubjectObserver<T>(child);
        addUnsubscriber(child, bo);
        onStart.call(bo);
        if (add(bo) && child.isUnsubscribed()) {
            remove(bo);
        }
    }
    /** Registers the unsubscribe action for the given subscriber. */
    void addUnsubscriber(Subscriber<? super T> child, final SubjectObserver<T> bo) {
        child.add(Subscriptions.create(new Action0() {
            @Override
            public void call() {
                remove(bo);
            }
        }));
    }    
    /** Set the latest NotificationLite value. */
    void set(Object value) {
        latest = value;
    }
    /** @return Retrieve the latest NotificationLite value */
    Object get() {
        return latest;
    }
    /** @return the array of active subscribers, don't write into the array! */
    SubjectObserver<T>[] observers() {
        return state.observers;
    }
    /**
     * Try to atomically add a SubjectObserver to the active state.
     * @param o the SubjectObserver to add
     * @return false if the subject is already in its terminal state
     */
    boolean add(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                onTerminated.call(o);
                return false;
            }
            State newState = oldState.add(o);
            if (STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                onAdded.call(o);
                return true;
            }
        } while (true);
    }
    /**
     * Atomically remove the specified SubjectObserver from the active observers.
     * @param o the SubjectObserver to remove
     */
    void remove(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                return;
            }
            State newState = oldState.remove(o);
            if (newState == oldState || STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                return;
            }
        } while (true);
    }
    /**
     * Set a new latest NotificationLite value and return the active observers.
     * @param n the new latest value
     * @return the array of SubjectObservers, don't write into the array!
     */
    SubjectObserver<T>[] next(Object n) {
        set(n);
        return state.observers;
    }
    /**
     * Atomically set the terminal NotificationLite value (which could be any of the 3),
     * clear the active observers and return the last active observers.
     * @param n the terminal value
     * @return the last active SubjectObservers
     */
    SubjectObserver<T>[] terminate(Object n) {
        set(n);
        active = false;

        State<T> oldState = state;
        if (oldState.terminated) {
            return State.NO_OBSERVERS;
        }
        return STATE_UPDATER.getAndSet(this, State.TERMINATED).observers;
    }

    /** State-machine representing the termination state and active SubjectObservers. */
    protected static final class State<T> {
        final boolean terminated;
        final SubjectObserver[] observers;
        static final SubjectObserver[] NO_OBSERVERS = new SubjectObserver[0];
        static final State TERMINATED = new State(true, NO_OBSERVERS);
        static final State EMPTY = new State(false, NO_OBSERVERS);
        
        public State(boolean terminated, SubjectObserver[] observers) {
            this.terminated = terminated;
            this.observers = observers;
        }
        public State add(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            SubjectObserver[] b = new SubjectObserver[n + 1];
            System.arraycopy(observers, 0, b, 0, n);
            b[n] = o;
            return new State<T>(terminated, b);
        }
        public State remove(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            if (n == 1 && a[0] == o) {
                return EMPTY;
            } else
                if (n == 0) {
                    return this;
                }
            SubjectObserver[] b = new SubjectObserver[n - 1];
            int j = 0;
            for (int i = 0; i < n; i++) {
                SubjectObserver ai = a[i];
                if (ai != o) {
                    if (j == n - 1) {
                        return this;
                    }
                    b[j++] = ai;
                }
            }
            if (j == 0) {
                return EMPTY;
            }
            if (j < n - 1) {
                SubjectObserver[] c = new SubjectObserver[j];
                System.arraycopy(b, 0, c, 0, j);
                b = c;
            }
            return new State<T>(terminated, b);
        }
    }
    
    /**
     * Observer wrapping the actual Subscriber and providing various
     * emission facilities.
     * @param <T> the consumed value type of the actual Observer
     */
    protected static final class SubjectObserver<T> implements Observer<T> {
        /** The actual Observer. */
        final Observer<? super T> actual;
        /** Was the emitFirst run? Guarded by this. */
        boolean first = true;
        /** Guarded by this. */
        boolean emitting;
        /** Guarded by this. */
        List<Object> queue;
        /* volatile */boolean fastPath;
        /** Indicate that the observer has caught up. */
        protected volatile boolean caughtUp;
        /** Indicate where the observer is at replaying. */
        private volatile Object index;
        public SubjectObserver(Observer<? super T> actual) {
            this.actual = actual;
        }
        @Override
        public void onNext(T t) {
            actual.onNext(t);
        }
        @Override
        public void onError(Throwable e) {
            actual.onError(e);
        }
        @Override
        public void onCompleted() {
            actual.onCompleted();
        }
        /**
         * Emits the given NotificationLite value and
         * prevents the emitFirst to run if not already run.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitNext(Object n, final NotificationLite<T> nl) {
            if (!fastPath) {
                synchronized (this) {
                    first = false;
                    if (emitting) {
                        if (queue == null) {
                            queue = new ArrayList<Object>();
                        }
                        queue.add(n);
                        return;
                    }
                }
                fastPath = true;
            }
            nl.accept(actual, n);
        }
        /**
         * Tries to emit a NotificationLite value as the first
         * value and drains the queue as long as possible.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitFirst(Object n, final NotificationLite<T> nl) {
            synchronized (this) {
                if (!first || emitting) {
                    return;
                }
                first = false;
                emitting = n != null;
            }
            if (n != null) {
                emitLoop(null, n, nl);
            }
        }
        /**
         * Emits the contents of the queue as long as there are values.
         * @param localQueue the initial queue contents
         * @param current the current content to emit
         * @param nl the type-appropriate notification lite object
         */
        protected void emitLoop(List<Object> localQueue, Object current, final NotificationLite<T> nl) {
            boolean once = true;
            boolean skipFinal = false;
            try {
                do {
                    if (localQueue != null) {
                        for (Object n : localQueue) {
                            accept(n, nl);
                        }
                    }
                    if (once) {
                        once = false;
                        accept(current, nl);
                    }
                    synchronized (this) {
                        localQueue = queue;
                        queue = null;
                        if (localQueue == null) {
                            emitting = false;
                            skipFinal = true;
                            break;
                        }
                    }
                } while (true);
            } finally {
                if (!skipFinal) {
                    synchronized (this) {
                        emitting = false;
                    }
                }
            }
        }
        /**
         * Dispatches a NotificationLite value to the actual Observer.
         * @param n the value to dispatch
         * @param nl the type-appropriate notification lite object
         */
        protected void accept(Object n, final NotificationLite<T> nl) {
            if (n != null) {
                nl.accept(actual, n);
            }
        }
        
        /** @return the actual Observer. */
        protected Observer<? super T> getActual() {
            return actual;
        }
        /**
         * Returns the stored index.
         * @param <I> the index type
         * @return the index value
         */
        @SuppressWarnings(""unchecked"")
        public <I> I index() {
            return (I)index;
        }
        /**
         * Sets a new index value.
         * @param newIndex the new index value
         */
        public void index(Object newIndex) {
            this.index = newIndex;
        }
    }
}",        protected void emitFirst(Object n),"        protected void emitFirst(Object n, final NotificationLite<T> nl)"
1c00aa6cc578bfc5e792aa5409ff1f336529ac6d," /**
  * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package rx.subjects;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import rx.Observable.OnSubscribe;

import rx.Observer;
import rx.Subscriber;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.functions.Actions;
import rx.operators.NotificationLite;
import rx.subscriptions.Subscriptions;

/**
 * Represents the typical state and OnSubscribe logic for a Subject implementation.
 * @param <T> the source and return value type
 */
@SuppressWarnings({""unchecked"", ""rawtypes""})
/* package */final class SubjectSubscriptionManager<T> implements OnSubscribe<T> {
    /** Contains the unsubscription flag and the array of active subscribers. */
    volatile State<T> state = State.EMPTY;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, State> STATE_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, State.class, ""state"");
    /** Stores the latest value or the terminal value for some Subjects. */
    volatile Object latest;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, Object> LATEST_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, Object.class, ""latest"");
    /** Indicates that the subject is active (cheaper than checking the state).*/
    boolean active = true;
    /** Action called when a new subscriber subscribes but before it is added to the state. */
    Action1<SubjectObserver<T>> onStart = Actions.empty();
    /** Action called after the subscriber has been added to the state. */
    Action1<SubjectObserver<T>> onAdded = Actions.empty();
    /** Action called when the subscriber wants to subscribe to a terminal state. */
    Action1<SubjectObserver<T>> onTerminated = Actions.empty();
    /** The notification lite. */
    public final NotificationLite<T> nl = NotificationLite.instance();
    @Override
    public void call(final Subscriber<? super T> child) {
        SubjectObserver<T> bo = new SubjectObserver<T>(child);
        addUnsubscriber(child, bo);
        onStart.call(bo);
        if (add(bo) && child.isUnsubscribed()) {
            remove(bo);
        }
    }
    /** Registers the unsubscribe action for the given subscriber. */
    void addUnsubscriber(Subscriber<? super T> child, final SubjectObserver<T> bo) {
        child.add(Subscriptions.create(new Action0() {
            @Override
            public void call() {
                remove(bo);
            }
        }));
    }    
    /** Set the latest NotificationLite value. */
    void set(Object value) {
        latest = value;
    }
    /** @return Retrieve the latest NotificationLite value */
    Object get() {
        return latest;
    }
    /** @return the array of active subscribers, don't write into the array! */
    SubjectObserver<T>[] observers() {
        return state.observers;
    }
    /**
     * Try to atomically add a SubjectObserver to the active state.
     * @param o the SubjectObserver to add
     * @return false if the subject is already in its terminal state
     */
    boolean add(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                onTerminated.call(o);
                return false;
            }
            State newState = oldState.add(o);
            if (STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                onAdded.call(o);
                return true;
            }
        } while (true);
    }
    /**
     * Atomically remove the specified SubjectObserver from the active observers.
     * @param o the SubjectObserver to remove
     */
    void remove(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                return;
            }
            State newState = oldState.remove(o);
            if (newState == oldState || STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                return;
            }
        } while (true);
    }
    /**
     * Set a new latest NotificationLite value and return the active observers.
     * @param n the new latest value
     * @return the array of SubjectObservers, don't write into the array!
     */
    SubjectObserver<T>[] next(Object n) {
        set(n);
        return state.observers;
    }
    /**
     * Atomically set the terminal NotificationLite value (which could be any of the 3),
     * clear the active observers and return the last active observers.
     * @param n the terminal value
     * @return the last active SubjectObservers
     */
    SubjectObserver<T>[] terminate(Object n) {
        set(n);
        active = false;

        State<T> oldState = state;
        if (oldState.terminated) {
            return State.NO_OBSERVERS;
        }
        return STATE_UPDATER.getAndSet(this, State.TERMINATED).observers;
    }

    /** State-machine representing the termination state and active SubjectObservers. */
    protected static final class State<T> {
        final boolean terminated;
        final SubjectObserver[] observers;
        static final SubjectObserver[] NO_OBSERVERS = new SubjectObserver[0];
        static final State TERMINATED = new State(true, NO_OBSERVERS);
        static final State EMPTY = new State(false, NO_OBSERVERS);
        
        public State(boolean terminated, SubjectObserver[] observers) {
            this.terminated = terminated;
            this.observers = observers;
        }
        public State add(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            SubjectObserver[] b = new SubjectObserver[n + 1];
            System.arraycopy(observers, 0, b, 0, n);
            b[n] = o;
            return new State<T>(terminated, b);
        }
        public State remove(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            if (n == 1 && a[0] == o) {
                return EMPTY;
            } else
                if (n == 0) {
                    return this;
                }
            SubjectObserver[] b = new SubjectObserver[n - 1];
            int j = 0;
            for (int i = 0; i < n; i++) {
                SubjectObserver ai = a[i];
                if (ai != o) {
                    if (j == n - 1) {
                        return this;
                    }
                    b[j++] = ai;
                }
            }
            if (j == 0) {
                return EMPTY;
            }
            if (j < n - 1) {
                SubjectObserver[] c = new SubjectObserver[j];
                System.arraycopy(b, 0, c, 0, j);
                b = c;
            }
            return new State<T>(terminated, b);
        }
    }
    
    /**
     * Observer wrapping the actual Subscriber and providing various
     * emission facilities.
     * @param <T> the consumed value type of the actual Observer
     */
    protected static final class SubjectObserver<T> implements Observer<T> {
        /** The actual Observer. */
        final Observer<? super T> actual;
        /** Was the emitFirst run? Guarded by this. */
        boolean first = true;
        /** Guarded by this. */
        boolean emitting;
        /** Guarded by this. */
        List<Object> queue;
        /* volatile */boolean fastPath;
        /** Indicate that the observer has caught up. */
        protected volatile boolean caughtUp;
        /** Indicate where the observer is at replaying. */
        private volatile Object index;
        public SubjectObserver(Observer<? super T> actual) {
            this.actual = actual;
        }
        @Override
        public void onNext(T t) {
            actual.onNext(t);
        }
        @Override
        public void onError(Throwable e) {
            actual.onError(e);
        }
        @Override
        public void onCompleted() {
            actual.onCompleted();
        }
        /**
         * Emits the given NotificationLite value and
         * prevents the emitFirst to run if not already run.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitNext(Object n, final NotificationLite<T> nl) {
            if (!fastPath) {
                synchronized (this) {
                    first = false;
                    if (emitting) {
                        if (queue == null) {
                            queue = new ArrayList<Object>();
                        }
                        queue.add(n);
                        return;
                    }
                }
                fastPath = true;
            }
            nl.accept(actual, n);
        }
        /**
         * Tries to emit a NotificationLite value as the first
         * value and drains the queue as long as possible.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitFirst(Object n, final NotificationLite<T> nl) {
            synchronized (this) {
                if (!first || emitting) {
                    return;
                }
                first = false;
                emitting = n != null;
            }
            if (n != null) {
                emitLoop(null, n, nl);
            }
        }
        /**
         * Emits the contents of the queue as long as there are values.
         * @param localQueue the initial queue contents
         * @param current the current content to emit
         * @param nl the type-appropriate notification lite object
         */
        protected void emitLoop(List<Object> localQueue, Object current, final NotificationLite<T> nl) {
            boolean once = true;
            boolean skipFinal = false;
            try {
                do {
                    if (localQueue != null) {
                        for (Object n : localQueue) {
                            accept(n, nl);
                        }
                    }
                    if (once) {
                        once = false;
                        accept(current, nl);
                    }
                    synchronized (this) {
                        localQueue = queue;
                        queue = null;
                        if (localQueue == null) {
                            emitting = false;
                            skipFinal = true;
                            break;
                        }
                    }
                } while (true);
            } finally {
                if (!skipFinal) {
                    synchronized (this) {
                        emitting = false;
                    }
                }
            }
        }
        /**
         * Dispatches a NotificationLite value to the actual Observer.
         * @param n the value to dispatch
         * @param nl the type-appropriate notification lite object
         */
        protected void accept(Object n, final NotificationLite<T> nl) {
            if (n != null) {
                nl.accept(actual, n);
            }
        }
        
        /** @return the actual Observer. */
        protected Observer<? super T> getActual() {
            return actual;
        }
        /**
         * Returns the stored index.
         * @param <I> the index type
         * @return the index value
         */
        @SuppressWarnings(""unchecked"")
        public <I> I index() {
            return (I)index;
        }
        /**
         * Sets a new index value.
         * @param newIndex the new index value
         */
        public void index(Object newIndex) {
            this.index = newIndex;
        }
    }
}","        protected void emitLoop(List<Object> localQueue, Object current)","        protected void emitLoop(List<Object> localQueue, Object current, final NotificationLite<T> nl)"
1c00aa6cc578bfc5e792aa5409ff1f336529ac6d," /**
  * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package rx.subjects;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import rx.Observable.OnSubscribe;

import rx.Observer;
import rx.Subscriber;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.functions.Actions;
import rx.operators.NotificationLite;
import rx.subscriptions.Subscriptions;

/**
 * Represents the typical state and OnSubscribe logic for a Subject implementation.
 * @param <T> the source and return value type
 */
@SuppressWarnings({""unchecked"", ""rawtypes""})
/* package */final class SubjectSubscriptionManager<T> implements OnSubscribe<T> {
    /** Contains the unsubscription flag and the array of active subscribers. */
    volatile State<T> state = State.EMPTY;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, State> STATE_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, State.class, ""state"");
    /** Stores the latest value or the terminal value for some Subjects. */
    volatile Object latest;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, Object> LATEST_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, Object.class, ""latest"");
    /** Indicates that the subject is active (cheaper than checking the state).*/
    boolean active = true;
    /** Action called when a new subscriber subscribes but before it is added to the state. */
    Action1<SubjectObserver<T>> onStart = Actions.empty();
    /** Action called after the subscriber has been added to the state. */
    Action1<SubjectObserver<T>> onAdded = Actions.empty();
    /** Action called when the subscriber wants to subscribe to a terminal state. */
    Action1<SubjectObserver<T>> onTerminated = Actions.empty();
    /** The notification lite. */
    public final NotificationLite<T> nl = NotificationLite.instance();
    @Override
    public void call(final Subscriber<? super T> child) {
        SubjectObserver<T> bo = new SubjectObserver<T>(child);
        addUnsubscriber(child, bo);
        onStart.call(bo);
        if (add(bo) && child.isUnsubscribed()) {
            remove(bo);
        }
    }
    /** Registers the unsubscribe action for the given subscriber. */
    void addUnsubscriber(Subscriber<? super T> child, final SubjectObserver<T> bo) {
        child.add(Subscriptions.create(new Action0() {
            @Override
            public void call() {
                remove(bo);
            }
        }));
    }    
    /** Set the latest NotificationLite value. */
    void set(Object value) {
        latest = value;
    }
    /** @return Retrieve the latest NotificationLite value */
    Object get() {
        return latest;
    }
    /** @return the array of active subscribers, don't write into the array! */
    SubjectObserver<T>[] observers() {
        return state.observers;
    }
    /**
     * Try to atomically add a SubjectObserver to the active state.
     * @param o the SubjectObserver to add
     * @return false if the subject is already in its terminal state
     */
    boolean add(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                onTerminated.call(o);
                return false;
            }
            State newState = oldState.add(o);
            if (STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                onAdded.call(o);
                return true;
            }
        } while (true);
    }
    /**
     * Atomically remove the specified SubjectObserver from the active observers.
     * @param o the SubjectObserver to remove
     */
    void remove(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                return;
            }
            State newState = oldState.remove(o);
            if (newState == oldState || STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                return;
            }
        } while (true);
    }
    /**
     * Set a new latest NotificationLite value and return the active observers.
     * @param n the new latest value
     * @return the array of SubjectObservers, don't write into the array!
     */
    SubjectObserver<T>[] next(Object n) {
        set(n);
        return state.observers;
    }
    /**
     * Atomically set the terminal NotificationLite value (which could be any of the 3),
     * clear the active observers and return the last active observers.
     * @param n the terminal value
     * @return the last active SubjectObservers
     */
    SubjectObserver<T>[] terminate(Object n) {
        set(n);
        active = false;

        State<T> oldState = state;
        if (oldState.terminated) {
            return State.NO_OBSERVERS;
        }
        return STATE_UPDATER.getAndSet(this, State.TERMINATED).observers;
    }

    /** State-machine representing the termination state and active SubjectObservers. */
    protected static final class State<T> {
        final boolean terminated;
        final SubjectObserver[] observers;
        static final SubjectObserver[] NO_OBSERVERS = new SubjectObserver[0];
        static final State TERMINATED = new State(true, NO_OBSERVERS);
        static final State EMPTY = new State(false, NO_OBSERVERS);
        
        public State(boolean terminated, SubjectObserver[] observers) {
            this.terminated = terminated;
            this.observers = observers;
        }
        public State add(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            SubjectObserver[] b = new SubjectObserver[n + 1];
            System.arraycopy(observers, 0, b, 0, n);
            b[n] = o;
            return new State<T>(terminated, b);
        }
        public State remove(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            if (n == 1 && a[0] == o) {
                return EMPTY;
            } else
                if (n == 0) {
                    return this;
                }
            SubjectObserver[] b = new SubjectObserver[n - 1];
            int j = 0;
            for (int i = 0; i < n; i++) {
                SubjectObserver ai = a[i];
                if (ai != o) {
                    if (j == n - 1) {
                        return this;
                    }
                    b[j++] = ai;
                }
            }
            if (j == 0) {
                return EMPTY;
            }
            if (j < n - 1) {
                SubjectObserver[] c = new SubjectObserver[j];
                System.arraycopy(b, 0, c, 0, j);
                b = c;
            }
            return new State<T>(terminated, b);
        }
    }
    
    /**
     * Observer wrapping the actual Subscriber and providing various
     * emission facilities.
     * @param <T> the consumed value type of the actual Observer
     */
    protected static final class SubjectObserver<T> implements Observer<T> {
        /** The actual Observer. */
        final Observer<? super T> actual;
        /** Was the emitFirst run? Guarded by this. */
        boolean first = true;
        /** Guarded by this. */
        boolean emitting;
        /** Guarded by this. */
        List<Object> queue;
        /* volatile */boolean fastPath;
        /** Indicate that the observer has caught up. */
        protected volatile boolean caughtUp;
        /** Indicate where the observer is at replaying. */
        private volatile Object index;
        public SubjectObserver(Observer<? super T> actual) {
            this.actual = actual;
        }
        @Override
        public void onNext(T t) {
            actual.onNext(t);
        }
        @Override
        public void onError(Throwable e) {
            actual.onError(e);
        }
        @Override
        public void onCompleted() {
            actual.onCompleted();
        }
        /**
         * Emits the given NotificationLite value and
         * prevents the emitFirst to run if not already run.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitNext(Object n, final NotificationLite<T> nl) {
            if (!fastPath) {
                synchronized (this) {
                    first = false;
                    if (emitting) {
                        if (queue == null) {
                            queue = new ArrayList<Object>();
                        }
                        queue.add(n);
                        return;
                    }
                }
                fastPath = true;
            }
            nl.accept(actual, n);
        }
        /**
         * Tries to emit a NotificationLite value as the first
         * value and drains the queue as long as possible.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitFirst(Object n, final NotificationLite<T> nl) {
            synchronized (this) {
                if (!first || emitting) {
                    return;
                }
                first = false;
                emitting = n != null;
            }
            if (n != null) {
                emitLoop(null, n, nl);
            }
        }
        /**
         * Emits the contents of the queue as long as there are values.
         * @param localQueue the initial queue contents
         * @param current the current content to emit
         * @param nl the type-appropriate notification lite object
         */
        protected void emitLoop(List<Object> localQueue, Object current, final NotificationLite<T> nl) {
            boolean once = true;
            boolean skipFinal = false;
            try {
                do {
                    if (localQueue != null) {
                        for (Object n : localQueue) {
                            accept(n, nl);
                        }
                    }
                    if (once) {
                        once = false;
                        accept(current, nl);
                    }
                    synchronized (this) {
                        localQueue = queue;
                        queue = null;
                        if (localQueue == null) {
                            emitting = false;
                            skipFinal = true;
                            break;
                        }
                    }
                } while (true);
            } finally {
                if (!skipFinal) {
                    synchronized (this) {
                        emitting = false;
                    }
                }
            }
        }
        /**
         * Dispatches a NotificationLite value to the actual Observer.
         * @param n the value to dispatch
         * @param nl the type-appropriate notification lite object
         */
        protected void accept(Object n, final NotificationLite<T> nl) {
            if (n != null) {
                nl.accept(actual, n);
            }
        }
        
        /** @return the actual Observer. */
        protected Observer<? super T> getActual() {
            return actual;
        }
        /**
         * Returns the stored index.
         * @param <I> the index type
         * @return the index value
         */
        @SuppressWarnings(""unchecked"")
        public <I> I index() {
            return (I)index;
        }
        /**
         * Sets a new index value.
         * @param newIndex the new index value
         */
        public void index(Object newIndex) {
            this.index = newIndex;
        }
    }
}",        protected void accept(Object n),"        protected void accept(Object n, final NotificationLite<T> nl)"
b0e87db05dd8fca53b452d431d197f202f466d23," /**
  * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package rx.subjects;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import rx.Observable.OnSubscribe;

import rx.Observer;
import rx.Subscriber;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.functions.Actions;
import rx.operators.NotificationLite;
import rx.subscriptions.Subscriptions;

/**
 * Represents the typical state and OnSubscribe logic for a Subject implementation.
 * @param <T> the source and return value type
 */
@SuppressWarnings({""unchecked"", ""rawtypes""})
/* package */final class SubjectSubscriptionManager<T> implements OnSubscribe<T> {
    /** Contains the unsubscription flag and the array of active subscribers. */
    volatile State<T> state = State.EMPTY;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, State> STATE_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, State.class, ""state"");
    /** Stores the latest value or the terminal value for some Subjects. */
    volatile Object latest;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, Object> LATEST_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, Object.class, ""latest"");
    /** Indicates that the subject is active (cheaper than checking the state).*/
    boolean active = true;
    /** Action called when a new subscriber subscribes but before it is added to the state. */
    Action1<SubjectObserver<T>> onStart = Actions.empty();
    /** Action called after the subscriber has been added to the state. */
    Action1<SubjectObserver<T>> onAdded = Actions.empty();
    /** Action called when the subscriber wants to subscribe to a terminal state. */
    Action1<SubjectObserver<T>> onTerminated = Actions.empty();
    /** The notification lite. */
    public final NotificationLite<T> nl = NotificationLite.instance();
    @Override
    public void call(final Subscriber<? super T> child) {
        SubjectObserver<T> bo = new SubjectObserver<T>(child);
        addUnsubscriber(child, bo);
        onStart.call(bo);
        if (add(bo) && child.isUnsubscribed()) {
            remove(bo);
        }
    }
    /** Registers the unsubscribe action for the given subscriber. */
    void addUnsubscriber(Subscriber<? super T> child, final SubjectObserver<T> bo) {
        child.add(Subscriptions.create(new Action0() {
            @Override
            public void call() {
                remove(bo);
            }
        }));
    }    
    /** Set the latest NotificationLite value. */
    void set(Object value) {
        latest = value;
    }
    /** @return Retrieve the latest NotificationLite value */
    Object get() {
        return latest;
    }
    /** @return the array of active subscribers, don't write into the array! */
    SubjectObserver<T>[] observers() {
        return state.observers;
    }
    /**
     * Try to atomically add a SubjectObserver to the active state.
     * @param o the SubjectObserver to add
     * @return false if the subject is already in its terminal state
     */
    boolean add(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                onTerminated.call(o);
                return false;
            }
            State newState = oldState.add(o);
            if (STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                onAdded.call(o);
                return true;
            }
        } while (true);
    }
    /**
     * Atomically remove the specified SubjectObserver from the active observers.
     * @param o the SubjectObserver to remove
     */
    void remove(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                return;
            }
            State newState = oldState.remove(o);
            if (newState == oldState || STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                return;
            }
        } while (true);
    }
    /**
     * Set a new latest NotificationLite value and return the active observers.
     * @param n the new latest value
     * @return the array of SubjectObservers, don't write into the array!
     */
    SubjectObserver<T>[] next(Object n) {
        set(n);
        return state.observers;
    }
    /**
     * Atomically set the terminal NotificationLite value (which could be any of the 3),
     * clear the active observers and return the last active observers.
     * @param n the terminal value
     * @return the last active SubjectObservers
     */
    SubjectObserver<T>[] terminate(Object n) {
        set(n);
        active = false;

        State<T> oldState = state;
        if (oldState.terminated) {
            return State.NO_OBSERVERS;
        }
        return STATE_UPDATER.getAndSet(this, State.TERMINATED).observers;
    }

    /** State-machine representing the termination state and active SubjectObservers. */
    protected static final class State<T> {
        final boolean terminated;
        final SubjectObserver[] observers;
        static final SubjectObserver[] NO_OBSERVERS = new SubjectObserver[0];
        static final State TERMINATED = new State(true, NO_OBSERVERS);
        static final State EMPTY = new State(false, NO_OBSERVERS);
        
        public State(boolean terminated, SubjectObserver[] observers) {
            this.terminated = terminated;
            this.observers = observers;
        }
        public State add(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            SubjectObserver[] b = new SubjectObserver[n + 1];
            System.arraycopy(observers, 0, b, 0, n);
            b[n] = o;
            return new State<T>(terminated, b);
        }
        public State remove(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            if (n == 1 && a[0] == o) {
                return EMPTY;
            } else
                if (n == 0) {
                    return this;
                }
            SubjectObserver[] b = new SubjectObserver[n - 1];
            int j = 0;
            for (int i = 0; i < n; i++) {
                SubjectObserver ai = a[i];
                if (ai != o) {
                    if (j == n - 1) {
                        return this;
                    }
                    b[j++] = ai;
                }
            }
            if (j == 0) {
                return EMPTY;
            }
            if (j < n - 1) {
                SubjectObserver[] c = new SubjectObserver[j];
                System.arraycopy(b, 0, c, 0, j);
                b = c;
            }
            return new State<T>(terminated, b);
        }
    }
    
    /**
     * Observer wrapping the actual Subscriber and providing various
     * emission facilities.
     * @param <T> the consumed value type of the actual Observer
     */
    protected static final class SubjectObserver<T> implements Observer<T> {
        /** The actual Observer. */
        final Observer<? super T> actual;
        /** Was the emitFirst run? Guarded by this. */
        boolean first = true;
        /** Guarded by this. */
        boolean emitting;
        /** Guarded by this. */
        List<Object> queue;
        /* volatile */boolean fastPath;
        /** Indicate that the observer has caught up. */
        protected volatile boolean caughtUp;
        /** Indicate where the observer is at replaying. */
        private volatile Object index;
        public SubjectObserver(Observer<? super T> actual) {
            this.actual = actual;
        }
        @Override
        public void onNext(T t) {
            actual.onNext(t);
        }
        @Override
        public void onError(Throwable e) {
            actual.onError(e);
        }
        @Override
        public void onCompleted() {
            actual.onCompleted();
        }
        /**
         * Emits the given NotificationLite value and
         * prevents the emitFirst to run if not already run.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitNext(Object n, final NotificationLite<T> nl) {
            if (!fastPath) {
                synchronized (this) {
                    first = false;
                    if (emitting) {
                        if (queue == null) {
                            queue = new ArrayList<Object>();
                        }
                        queue.add(n);
                        return;
                    }
                }
                fastPath = true;
            }
            nl.accept(actual, n);
        }
        /**
         * Tries to emit a NotificationLite value as the first
         * value and drains the queue as long as possible.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitFirst(Object n, final NotificationLite<T> nl) {
            synchronized (this) {
                if (!first || emitting) {
                    return;
                }
                first = false;
                emitting = n != null;
            }
            if (n != null) {
                emitLoop(null, n, nl);
            }
        }
        /**
         * Emits the contents of the queue as long as there are values.
         * @param localQueue the initial queue contents
         * @param current the current content to emit
         * @param nl the type-appropriate notification lite object
         */
        protected void emitLoop(List<Object> localQueue, Object current, final NotificationLite<T> nl) {
            boolean once = true;
            boolean skipFinal = false;
            try {
                do {
                    if (localQueue != null) {
                        for (Object n : localQueue) {
                            accept(n, nl);
                        }
                    }
                    if (once) {
                        once = false;
                        accept(current, nl);
                    }
                    synchronized (this) {
                        localQueue = queue;
                        queue = null;
                        if (localQueue == null) {
                            emitting = false;
                            skipFinal = true;
                            break;
                        }
                    }
                } while (true);
            } finally {
                if (!skipFinal) {
                    synchronized (this) {
                        emitting = false;
                    }
                }
            }
        }
        /**
         * Dispatches a NotificationLite value to the actual Observer.
         * @param n the value to dispatch
         * @param nl the type-appropriate notification lite object
         */
        protected void accept(Object n, final NotificationLite<T> nl) {
            if (n != null) {
                nl.accept(actual, n);
            }
        }
        
        /** @return the actual Observer. */
        protected Observer<? super T> getActual() {
            return actual;
        }
        /**
         * Returns the stored index.
         * @param <I> the index type
         * @return the index value
         */
        @SuppressWarnings(""unchecked"")
        public <I> I index() {
            return (I)index;
        }
        /**
         * Sets a new index value.
         * @param newIndex the new index value
         */
        public void index(Object newIndex) {
            this.index = newIndex;
        }
    }
}",        protected void emitNext(Object n),"        protected void emitNext(Object n, final NotificationLite<T> nl)"
b0e87db05dd8fca53b452d431d197f202f466d23," /**
  * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package rx.subjects;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import rx.Observable.OnSubscribe;

import rx.Observer;
import rx.Subscriber;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.functions.Actions;
import rx.operators.NotificationLite;
import rx.subscriptions.Subscriptions;

/**
 * Represents the typical state and OnSubscribe logic for a Subject implementation.
 * @param <T> the source and return value type
 */
@SuppressWarnings({""unchecked"", ""rawtypes""})
/* package */final class SubjectSubscriptionManager<T> implements OnSubscribe<T> {
    /** Contains the unsubscription flag and the array of active subscribers. */
    volatile State<T> state = State.EMPTY;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, State> STATE_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, State.class, ""state"");
    /** Stores the latest value or the terminal value for some Subjects. */
    volatile Object latest;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, Object> LATEST_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, Object.class, ""latest"");
    /** Indicates that the subject is active (cheaper than checking the state).*/
    boolean active = true;
    /** Action called when a new subscriber subscribes but before it is added to the state. */
    Action1<SubjectObserver<T>> onStart = Actions.empty();
    /** Action called after the subscriber has been added to the state. */
    Action1<SubjectObserver<T>> onAdded = Actions.empty();
    /** Action called when the subscriber wants to subscribe to a terminal state. */
    Action1<SubjectObserver<T>> onTerminated = Actions.empty();
    /** The notification lite. */
    public final NotificationLite<T> nl = NotificationLite.instance();
    @Override
    public void call(final Subscriber<? super T> child) {
        SubjectObserver<T> bo = new SubjectObserver<T>(child);
        addUnsubscriber(child, bo);
        onStart.call(bo);
        if (add(bo) && child.isUnsubscribed()) {
            remove(bo);
        }
    }
    /** Registers the unsubscribe action for the given subscriber. */
    void addUnsubscriber(Subscriber<? super T> child, final SubjectObserver<T> bo) {
        child.add(Subscriptions.create(new Action0() {
            @Override
            public void call() {
                remove(bo);
            }
        }));
    }    
    /** Set the latest NotificationLite value. */
    void set(Object value) {
        latest = value;
    }
    /** @return Retrieve the latest NotificationLite value */
    Object get() {
        return latest;
    }
    /** @return the array of active subscribers, don't write into the array! */
    SubjectObserver<T>[] observers() {
        return state.observers;
    }
    /**
     * Try to atomically add a SubjectObserver to the active state.
     * @param o the SubjectObserver to add
     * @return false if the subject is already in its terminal state
     */
    boolean add(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                onTerminated.call(o);
                return false;
            }
            State newState = oldState.add(o);
            if (STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                onAdded.call(o);
                return true;
            }
        } while (true);
    }
    /**
     * Atomically remove the specified SubjectObserver from the active observers.
     * @param o the SubjectObserver to remove
     */
    void remove(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                return;
            }
            State newState = oldState.remove(o);
            if (newState == oldState || STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                return;
            }
        } while (true);
    }
    /**
     * Set a new latest NotificationLite value and return the active observers.
     * @param n the new latest value
     * @return the array of SubjectObservers, don't write into the array!
     */
    SubjectObserver<T>[] next(Object n) {
        set(n);
        return state.observers;
    }
    /**
     * Atomically set the terminal NotificationLite value (which could be any of the 3),
     * clear the active observers and return the last active observers.
     * @param n the terminal value
     * @return the last active SubjectObservers
     */
    SubjectObserver<T>[] terminate(Object n) {
        set(n);
        active = false;

        State<T> oldState = state;
        if (oldState.terminated) {
            return State.NO_OBSERVERS;
        }
        return STATE_UPDATER.getAndSet(this, State.TERMINATED).observers;
    }

    /** State-machine representing the termination state and active SubjectObservers. */
    protected static final class State<T> {
        final boolean terminated;
        final SubjectObserver[] observers;
        static final SubjectObserver[] NO_OBSERVERS = new SubjectObserver[0];
        static final State TERMINATED = new State(true, NO_OBSERVERS);
        static final State EMPTY = new State(false, NO_OBSERVERS);
        
        public State(boolean terminated, SubjectObserver[] observers) {
            this.terminated = terminated;
            this.observers = observers;
        }
        public State add(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            SubjectObserver[] b = new SubjectObserver[n + 1];
            System.arraycopy(observers, 0, b, 0, n);
            b[n] = o;
            return new State<T>(terminated, b);
        }
        public State remove(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            if (n == 1 && a[0] == o) {
                return EMPTY;
            } else
                if (n == 0) {
                    return this;
                }
            SubjectObserver[] b = new SubjectObserver[n - 1];
            int j = 0;
            for (int i = 0; i < n; i++) {
                SubjectObserver ai = a[i];
                if (ai != o) {
                    if (j == n - 1) {
                        return this;
                    }
                    b[j++] = ai;
                }
            }
            if (j == 0) {
                return EMPTY;
            }
            if (j < n - 1) {
                SubjectObserver[] c = new SubjectObserver[j];
                System.arraycopy(b, 0, c, 0, j);
                b = c;
            }
            return new State<T>(terminated, b);
        }
    }
    
    /**
     * Observer wrapping the actual Subscriber and providing various
     * emission facilities.
     * @param <T> the consumed value type of the actual Observer
     */
    protected static final class SubjectObserver<T> implements Observer<T> {
        /** The actual Observer. */
        final Observer<? super T> actual;
        /** Was the emitFirst run? Guarded by this. */
        boolean first = true;
        /** Guarded by this. */
        boolean emitting;
        /** Guarded by this. */
        List<Object> queue;
        /* volatile */boolean fastPath;
        /** Indicate that the observer has caught up. */
        protected volatile boolean caughtUp;
        /** Indicate where the observer is at replaying. */
        private volatile Object index;
        public SubjectObserver(Observer<? super T> actual) {
            this.actual = actual;
        }
        @Override
        public void onNext(T t) {
            actual.onNext(t);
        }
        @Override
        public void onError(Throwable e) {
            actual.onError(e);
        }
        @Override
        public void onCompleted() {
            actual.onCompleted();
        }
        /**
         * Emits the given NotificationLite value and
         * prevents the emitFirst to run if not already run.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitNext(Object n, final NotificationLite<T> nl) {
            if (!fastPath) {
                synchronized (this) {
                    first = false;
                    if (emitting) {
                        if (queue == null) {
                            queue = new ArrayList<Object>();
                        }
                        queue.add(n);
                        return;
                    }
                }
                fastPath = true;
            }
            nl.accept(actual, n);
        }
        /**
         * Tries to emit a NotificationLite value as the first
         * value and drains the queue as long as possible.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitFirst(Object n, final NotificationLite<T> nl) {
            synchronized (this) {
                if (!first || emitting) {
                    return;
                }
                first = false;
                emitting = n != null;
            }
            if (n != null) {
                emitLoop(null, n, nl);
            }
        }
        /**
         * Emits the contents of the queue as long as there are values.
         * @param localQueue the initial queue contents
         * @param current the current content to emit
         * @param nl the type-appropriate notification lite object
         */
        protected void emitLoop(List<Object> localQueue, Object current, final NotificationLite<T> nl) {
            boolean once = true;
            boolean skipFinal = false;
            try {
                do {
                    if (localQueue != null) {
                        for (Object n : localQueue) {
                            accept(n, nl);
                        }
                    }
                    if (once) {
                        once = false;
                        accept(current, nl);
                    }
                    synchronized (this) {
                        localQueue = queue;
                        queue = null;
                        if (localQueue == null) {
                            emitting = false;
                            skipFinal = true;
                            break;
                        }
                    }
                } while (true);
            } finally {
                if (!skipFinal) {
                    synchronized (this) {
                        emitting = false;
                    }
                }
            }
        }
        /**
         * Dispatches a NotificationLite value to the actual Observer.
         * @param n the value to dispatch
         * @param nl the type-appropriate notification lite object
         */
        protected void accept(Object n, final NotificationLite<T> nl) {
            if (n != null) {
                nl.accept(actual, n);
            }
        }
        
        /** @return the actual Observer. */
        protected Observer<? super T> getActual() {
            return actual;
        }
        /**
         * Returns the stored index.
         * @param <I> the index type
         * @return the index value
         */
        @SuppressWarnings(""unchecked"")
        public <I> I index() {
            return (I)index;
        }
        /**
         * Sets a new index value.
         * @param newIndex the new index value
         */
        public void index(Object newIndex) {
            this.index = newIndex;
        }
    }
}",        protected void emitFirst(Object n),"        protected void emitFirst(Object n, final NotificationLite<T> nl)"
b0e87db05dd8fca53b452d431d197f202f466d23," /**
  * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package rx.subjects;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import rx.Observable.OnSubscribe;

import rx.Observer;
import rx.Subscriber;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.functions.Actions;
import rx.operators.NotificationLite;
import rx.subscriptions.Subscriptions;

/**
 * Represents the typical state and OnSubscribe logic for a Subject implementation.
 * @param <T> the source and return value type
 */
@SuppressWarnings({""unchecked"", ""rawtypes""})
/* package */final class SubjectSubscriptionManager<T> implements OnSubscribe<T> {
    /** Contains the unsubscription flag and the array of active subscribers. */
    volatile State<T> state = State.EMPTY;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, State> STATE_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, State.class, ""state"");
    /** Stores the latest value or the terminal value for some Subjects. */
    volatile Object latest;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, Object> LATEST_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, Object.class, ""latest"");
    /** Indicates that the subject is active (cheaper than checking the state).*/
    boolean active = true;
    /** Action called when a new subscriber subscribes but before it is added to the state. */
    Action1<SubjectObserver<T>> onStart = Actions.empty();
    /** Action called after the subscriber has been added to the state. */
    Action1<SubjectObserver<T>> onAdded = Actions.empty();
    /** Action called when the subscriber wants to subscribe to a terminal state. */
    Action1<SubjectObserver<T>> onTerminated = Actions.empty();
    /** The notification lite. */
    public final NotificationLite<T> nl = NotificationLite.instance();
    @Override
    public void call(final Subscriber<? super T> child) {
        SubjectObserver<T> bo = new SubjectObserver<T>(child);
        addUnsubscriber(child, bo);
        onStart.call(bo);
        if (add(bo) && child.isUnsubscribed()) {
            remove(bo);
        }
    }
    /** Registers the unsubscribe action for the given subscriber. */
    void addUnsubscriber(Subscriber<? super T> child, final SubjectObserver<T> bo) {
        child.add(Subscriptions.create(new Action0() {
            @Override
            public void call() {
                remove(bo);
            }
        }));
    }    
    /** Set the latest NotificationLite value. */
    void set(Object value) {
        latest = value;
    }
    /** @return Retrieve the latest NotificationLite value */
    Object get() {
        return latest;
    }
    /** @return the array of active subscribers, don't write into the array! */
    SubjectObserver<T>[] observers() {
        return state.observers;
    }
    /**
     * Try to atomically add a SubjectObserver to the active state.
     * @param o the SubjectObserver to add
     * @return false if the subject is already in its terminal state
     */
    boolean add(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                onTerminated.call(o);
                return false;
            }
            State newState = oldState.add(o);
            if (STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                onAdded.call(o);
                return true;
            }
        } while (true);
    }
    /**
     * Atomically remove the specified SubjectObserver from the active observers.
     * @param o the SubjectObserver to remove
     */
    void remove(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                return;
            }
            State newState = oldState.remove(o);
            if (newState == oldState || STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                return;
            }
        } while (true);
    }
    /**
     * Set a new latest NotificationLite value and return the active observers.
     * @param n the new latest value
     * @return the array of SubjectObservers, don't write into the array!
     */
    SubjectObserver<T>[] next(Object n) {
        set(n);
        return state.observers;
    }
    /**
     * Atomically set the terminal NotificationLite value (which could be any of the 3),
     * clear the active observers and return the last active observers.
     * @param n the terminal value
     * @return the last active SubjectObservers
     */
    SubjectObserver<T>[] terminate(Object n) {
        set(n);
        active = false;

        State<T> oldState = state;
        if (oldState.terminated) {
            return State.NO_OBSERVERS;
        }
        return STATE_UPDATER.getAndSet(this, State.TERMINATED).observers;
    }

    /** State-machine representing the termination state and active SubjectObservers. */
    protected static final class State<T> {
        final boolean terminated;
        final SubjectObserver[] observers;
        static final SubjectObserver[] NO_OBSERVERS = new SubjectObserver[0];
        static final State TERMINATED = new State(true, NO_OBSERVERS);
        static final State EMPTY = new State(false, NO_OBSERVERS);
        
        public State(boolean terminated, SubjectObserver[] observers) {
            this.terminated = terminated;
            this.observers = observers;
        }
        public State add(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            SubjectObserver[] b = new SubjectObserver[n + 1];
            System.arraycopy(observers, 0, b, 0, n);
            b[n] = o;
            return new State<T>(terminated, b);
        }
        public State remove(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            if (n == 1 && a[0] == o) {
                return EMPTY;
            } else
                if (n == 0) {
                    return this;
                }
            SubjectObserver[] b = new SubjectObserver[n - 1];
            int j = 0;
            for (int i = 0; i < n; i++) {
                SubjectObserver ai = a[i];
                if (ai != o) {
                    if (j == n - 1) {
                        return this;
                    }
                    b[j++] = ai;
                }
            }
            if (j == 0) {
                return EMPTY;
            }
            if (j < n - 1) {
                SubjectObserver[] c = new SubjectObserver[j];
                System.arraycopy(b, 0, c, 0, j);
                b = c;
            }
            return new State<T>(terminated, b);
        }
    }
    
    /**
     * Observer wrapping the actual Subscriber and providing various
     * emission facilities.
     * @param <T> the consumed value type of the actual Observer
     */
    protected static final class SubjectObserver<T> implements Observer<T> {
        /** The actual Observer. */
        final Observer<? super T> actual;
        /** Was the emitFirst run? Guarded by this. */
        boolean first = true;
        /** Guarded by this. */
        boolean emitting;
        /** Guarded by this. */
        List<Object> queue;
        /* volatile */boolean fastPath;
        /** Indicate that the observer has caught up. */
        protected volatile boolean caughtUp;
        /** Indicate where the observer is at replaying. */
        private volatile Object index;
        public SubjectObserver(Observer<? super T> actual) {
            this.actual = actual;
        }
        @Override
        public void onNext(T t) {
            actual.onNext(t);
        }
        @Override
        public void onError(Throwable e) {
            actual.onError(e);
        }
        @Override
        public void onCompleted() {
            actual.onCompleted();
        }
        /**
         * Emits the given NotificationLite value and
         * prevents the emitFirst to run if not already run.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitNext(Object n, final NotificationLite<T> nl) {
            if (!fastPath) {
                synchronized (this) {
                    first = false;
                    if (emitting) {
                        if (queue == null) {
                            queue = new ArrayList<Object>();
                        }
                        queue.add(n);
                        return;
                    }
                }
                fastPath = true;
            }
            nl.accept(actual, n);
        }
        /**
         * Tries to emit a NotificationLite value as the first
         * value and drains the queue as long as possible.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitFirst(Object n, final NotificationLite<T> nl) {
            synchronized (this) {
                if (!first || emitting) {
                    return;
                }
                first = false;
                emitting = n != null;
            }
            if (n != null) {
                emitLoop(null, n, nl);
            }
        }
        /**
         * Emits the contents of the queue as long as there are values.
         * @param localQueue the initial queue contents
         * @param current the current content to emit
         * @param nl the type-appropriate notification lite object
         */
        protected void emitLoop(List<Object> localQueue, Object current, final NotificationLite<T> nl) {
            boolean once = true;
            boolean skipFinal = false;
            try {
                do {
                    if (localQueue != null) {
                        for (Object n : localQueue) {
                            accept(n, nl);
                        }
                    }
                    if (once) {
                        once = false;
                        accept(current, nl);
                    }
                    synchronized (this) {
                        localQueue = queue;
                        queue = null;
                        if (localQueue == null) {
                            emitting = false;
                            skipFinal = true;
                            break;
                        }
                    }
                } while (true);
            } finally {
                if (!skipFinal) {
                    synchronized (this) {
                        emitting = false;
                    }
                }
            }
        }
        /**
         * Dispatches a NotificationLite value to the actual Observer.
         * @param n the value to dispatch
         * @param nl the type-appropriate notification lite object
         */
        protected void accept(Object n, final NotificationLite<T> nl) {
            if (n != null) {
                nl.accept(actual, n);
            }
        }
        
        /** @return the actual Observer. */
        protected Observer<? super T> getActual() {
            return actual;
        }
        /**
         * Returns the stored index.
         * @param <I> the index type
         * @return the index value
         */
        @SuppressWarnings(""unchecked"")
        public <I> I index() {
            return (I)index;
        }
        /**
         * Sets a new index value.
         * @param newIndex the new index value
         */
        public void index(Object newIndex) {
            this.index = newIndex;
        }
    }
}","        protected void emitLoop(List<Object> localQueue, Object current)","        protected void emitLoop(List<Object> localQueue, Object current, final NotificationLite<T> nl)"
b0e87db05dd8fca53b452d431d197f202f466d23," /**
  * Copyright 2014 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
package rx.subjects;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import rx.Observable.OnSubscribe;

import rx.Observer;
import rx.Subscriber;
import rx.functions.Action0;
import rx.functions.Action1;
import rx.functions.Actions;
import rx.operators.NotificationLite;
import rx.subscriptions.Subscriptions;

/**
 * Represents the typical state and OnSubscribe logic for a Subject implementation.
 * @param <T> the source and return value type
 */
@SuppressWarnings({""unchecked"", ""rawtypes""})
/* package */final class SubjectSubscriptionManager<T> implements OnSubscribe<T> {
    /** Contains the unsubscription flag and the array of active subscribers. */
    volatile State<T> state = State.EMPTY;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, State> STATE_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, State.class, ""state"");
    /** Stores the latest value or the terminal value for some Subjects. */
    volatile Object latest;
    static final AtomicReferenceFieldUpdater<SubjectSubscriptionManager, Object> LATEST_UPDATER
            = AtomicReferenceFieldUpdater.newUpdater(SubjectSubscriptionManager.class, Object.class, ""latest"");
    /** Indicates that the subject is active (cheaper than checking the state).*/
    boolean active = true;
    /** Action called when a new subscriber subscribes but before it is added to the state. */
    Action1<SubjectObserver<T>> onStart = Actions.empty();
    /** Action called after the subscriber has been added to the state. */
    Action1<SubjectObserver<T>> onAdded = Actions.empty();
    /** Action called when the subscriber wants to subscribe to a terminal state. */
    Action1<SubjectObserver<T>> onTerminated = Actions.empty();
    /** The notification lite. */
    public final NotificationLite<T> nl = NotificationLite.instance();
    @Override
    public void call(final Subscriber<? super T> child) {
        SubjectObserver<T> bo = new SubjectObserver<T>(child);
        addUnsubscriber(child, bo);
        onStart.call(bo);
        if (add(bo) && child.isUnsubscribed()) {
            remove(bo);
        }
    }
    /** Registers the unsubscribe action for the given subscriber. */
    void addUnsubscriber(Subscriber<? super T> child, final SubjectObserver<T> bo) {
        child.add(Subscriptions.create(new Action0() {
            @Override
            public void call() {
                remove(bo);
            }
        }));
    }    
    /** Set the latest NotificationLite value. */
    void set(Object value) {
        latest = value;
    }
    /** @return Retrieve the latest NotificationLite value */
    Object get() {
        return latest;
    }
    /** @return the array of active subscribers, don't write into the array! */
    SubjectObserver<T>[] observers() {
        return state.observers;
    }
    /**
     * Try to atomically add a SubjectObserver to the active state.
     * @param o the SubjectObserver to add
     * @return false if the subject is already in its terminal state
     */
    boolean add(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                onTerminated.call(o);
                return false;
            }
            State newState = oldState.add(o);
            if (STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                onAdded.call(o);
                return true;
            }
        } while (true);
    }
    /**
     * Atomically remove the specified SubjectObserver from the active observers.
     * @param o the SubjectObserver to remove
     */
    void remove(SubjectObserver<T> o) {
        do {
            State oldState = state;
            if (oldState.terminated) {
                return;
            }
            State newState = oldState.remove(o);
            if (newState == oldState || STATE_UPDATER.compareAndSet(this, oldState, newState)) {
                return;
            }
        } while (true);
    }
    /**
     * Set a new latest NotificationLite value and return the active observers.
     * @param n the new latest value
     * @return the array of SubjectObservers, don't write into the array!
     */
    SubjectObserver<T>[] next(Object n) {
        set(n);
        return state.observers;
    }
    /**
     * Atomically set the terminal NotificationLite value (which could be any of the 3),
     * clear the active observers and return the last active observers.
     * @param n the terminal value
     * @return the last active SubjectObservers
     */
    SubjectObserver<T>[] terminate(Object n) {
        set(n);
        active = false;

        State<T> oldState = state;
        if (oldState.terminated) {
            return State.NO_OBSERVERS;
        }
        return STATE_UPDATER.getAndSet(this, State.TERMINATED).observers;
    }

    /** State-machine representing the termination state and active SubjectObservers. */
    protected static final class State<T> {
        final boolean terminated;
        final SubjectObserver[] observers;
        static final SubjectObserver[] NO_OBSERVERS = new SubjectObserver[0];
        static final State TERMINATED = new State(true, NO_OBSERVERS);
        static final State EMPTY = new State(false, NO_OBSERVERS);
        
        public State(boolean terminated, SubjectObserver[] observers) {
            this.terminated = terminated;
            this.observers = observers;
        }
        public State add(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            SubjectObserver[] b = new SubjectObserver[n + 1];
            System.arraycopy(observers, 0, b, 0, n);
            b[n] = o;
            return new State<T>(terminated, b);
        }
        public State remove(SubjectObserver o) {
            SubjectObserver[] a = observers;
            int n = a.length;
            if (n == 1 && a[0] == o) {
                return EMPTY;
            } else
                if (n == 0) {
                    return this;
                }
            SubjectObserver[] b = new SubjectObserver[n - 1];
            int j = 0;
            for (int i = 0; i < n; i++) {
                SubjectObserver ai = a[i];
                if (ai != o) {
                    if (j == n - 1) {
                        return this;
                    }
                    b[j++] = ai;
                }
            }
            if (j == 0) {
                return EMPTY;
            }
            if (j < n - 1) {
                SubjectObserver[] c = new SubjectObserver[j];
                System.arraycopy(b, 0, c, 0, j);
                b = c;
            }
            return new State<T>(terminated, b);
        }
    }
    
    /**
     * Observer wrapping the actual Subscriber and providing various
     * emission facilities.
     * @param <T> the consumed value type of the actual Observer
     */
    protected static final class SubjectObserver<T> implements Observer<T> {
        /** The actual Observer. */
        final Observer<? super T> actual;
        /** Was the emitFirst run? Guarded by this. */
        boolean first = true;
        /** Guarded by this. */
        boolean emitting;
        /** Guarded by this. */
        List<Object> queue;
        /* volatile */boolean fastPath;
        /** Indicate that the observer has caught up. */
        protected volatile boolean caughtUp;
        /** Indicate where the observer is at replaying. */
        private volatile Object index;
        public SubjectObserver(Observer<? super T> actual) {
            this.actual = actual;
        }
        @Override
        public void onNext(T t) {
            actual.onNext(t);
        }
        @Override
        public void onError(Throwable e) {
            actual.onError(e);
        }
        @Override
        public void onCompleted() {
            actual.onCompleted();
        }
        /**
         * Emits the given NotificationLite value and
         * prevents the emitFirst to run if not already run.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitNext(Object n, final NotificationLite<T> nl) {
            if (!fastPath) {
                synchronized (this) {
                    first = false;
                    if (emitting) {
                        if (queue == null) {
                            queue = new ArrayList<Object>();
                        }
                        queue.add(n);
                        return;
                    }
                }
                fastPath = true;
            }
            nl.accept(actual, n);
        }
        /**
         * Tries to emit a NotificationLite value as the first
         * value and drains the queue as long as possible.
         * @param n the NotificationLite value
         * @param nl the type-appropriate notification lite object
         */
        protected void emitFirst(Object n, final NotificationLite<T> nl) {
            synchronized (this) {
                if (!first || emitting) {
                    return;
                }
                first = false;
                emitting = n != null;
            }
            if (n != null) {
                emitLoop(null, n, nl);
            }
        }
        /**
         * Emits the contents of the queue as long as there are values.
         * @param localQueue the initial queue contents
         * @param current the current content to emit
         * @param nl the type-appropriate notification lite object
         */
        protected void emitLoop(List<Object> localQueue, Object current, final NotificationLite<T> nl) {
            boolean once = true;
            boolean skipFinal = false;
            try {
                do {
                    if (localQueue != null) {
                        for (Object n : localQueue) {
                            accept(n, nl);
                        }
                    }
                    if (once) {
                        once = false;
                        accept(current, nl);
                    }
                    synchronized (this) {
                        localQueue = queue;
                        queue = null;
                        if (localQueue == null) {
                            emitting = false;
                            skipFinal = true;
                            break;
                        }
                    }
                } while (true);
            } finally {
                if (!skipFinal) {
                    synchronized (this) {
                        emitting = false;
                    }
                }
            }
        }
        /**
         * Dispatches a NotificationLite value to the actual Observer.
         * @param n the value to dispatch
         * @param nl the type-appropriate notification lite object
         */
        protected void accept(Object n, final NotificationLite<T> nl) {
            if (n != null) {
                nl.accept(actual, n);
            }
        }
        
        /** @return the actual Observer. */
        protected Observer<? super T> getActual() {
            return actual;
        }
        /**
         * Returns the stored index.
         * @param <I> the index type
         * @return the index value
         */
        @SuppressWarnings(""unchecked"")
        public <I> I index() {
            return (I)index;
        }
        /**
         * Sets a new index value.
         * @param newIndex the new index value
         */
        public void index(Object newIndex) {
            this.index = newIndex;
        }
    }
}",        protected void accept(Object n),"        protected void accept(Object n, final NotificationLite<T> nl)"
061cdb685c3d3a73b90e1af81aed2f3ff4166630,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.internal.operators;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicLongFieldUpdater;

import rx.Observable;
import rx.Observable.Operator;
import rx.Producer;
import rx.Subscriber;
import rx.exceptions.CompositeException;
import rx.exceptions.MissingBackpressureException;
import rx.exceptions.OnErrorThrowable;
import rx.functions.Func1;
import rx.internal.util.RxRingBuffer;
import rx.internal.util.ScalarSynchronousObservable;
import rx.internal.util.SubscriptionIndexedRingBuffer;

/**
 * Flattens a list of {@link Observable}s into one {@code Observable}, without any transformation.
 * <p>
 * <img width=""640"" height=""380"" src=""https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png"" alt="""">
 * <p>
 * You can combine the items emitted by multiple {@code Observable}s so that they act like a single {@code Observable}, by using the merge operation.
 * 
 * @param <T>
 *            the type of the items emitted by both the source and merged {@code Observable}s
 */
public class OperatorMerge<T> implements Operator<T, Observable<? extends T>> {

    /*
     * benjchristensen => This class is complex and I'm not a fan of it despite writing it. I want to give some background
     * as to why for anyone who wants to try and help improve it.
     * 
     * One of my first implementations that added backpressure support (Producer.request) was fairly elegant and used a simple
     * queue draining approach. It was simple to understand as all onNext were added to their queues, then a single winner
     * would drain the queues, similar to observeOn. It killed the Netflix API when I canaried it. There were two problems:
     * (1) performance and (2) object allocation overhead causing massive GC pressure. Remember that merge is one of the most
     * used operators (mostly due to flatmap) and is therefore critical to and a limiter of performance in any application.
     * 
     * All subsequent work on this class and the various fast-paths and branches within it have been to achieve the needed functionality
     * while reducing or eliminating object allocation and keeping performance acceptable.
     * 
     * This has meant adopting strategies such as:
     * 
     * - ring buffers instead of growable queues
     * - object pooling
     * - skipping request logic when downstream does not need backpressure
     * - ScalarValueQueue for optimizing synchronous single-value Observables
     * - adopting data structures that use Unsafe (and gating them based on environment so non-Oracle JVMs still work)
     * 
     * It has definitely increased the complexity and maintenance cost of this class, but the performance gains have been significant.
     * 
     * The biggest cost of the increased complexity is concurrency bugs and reasoning through what's going on.
     * 
     * I'd love to have contributions that improve this class, but keep in mind the performance and GC pressure.
     * The benchmarks I use are in the JMH OperatorMergePerf class. GC memory pressure is tested using Java Flight Recorder
     * to track object allocation.
     */

    public OperatorMerge() {
        this.delayErrors = false;
    }

    public OperatorMerge(boolean delayErrors) {
        this.delayErrors = delayErrors;
    }

    private final boolean delayErrors;

    @Override
    public Subscriber<Observable<? extends T>> call(final Subscriber<? super T> child) {
        return new MergeSubscriber<T>(child, delayErrors);

    }

    private static final class MergeSubscriber<T> extends Subscriber<Observable<? extends T>> {
        final NotificationLite<T> on = NotificationLite.instance();
        final Subscriber<? super T> actual;
        private final MergeProducer<T> mergeProducer;
        private int wip;
        private boolean completed;
        private final boolean delayErrors;
        private ConcurrentLinkedQueue<Throwable> exceptions;

        private volatile SubscriptionIndexedRingBuffer<InnerSubscriber<T>> childrenSubscribers;

        private RxRingBuffer scalarValueQueue = null;

        /* protected by lock on MergeSubscriber instance */
        private int missedEmitting = 0;
        private boolean emitLock = false;

        /**
         * Using synchronized(this) for `emitLock` instead of ReentrantLock or AtomicInteger is faster when there is no contention.
         * 
         * <pre> {@code
         * Using ReentrantLock:
         * r.o.OperatorMergePerf.merge1SyncStreamOfN           1000  thrpt         5    44185.294     1295.565    ops/s
         * 
         * Using synchronized(this):
         * r.o.OperatorMergePerf.merge1SyncStreamOfN           1000  thrpt         5    79715.981     3704.486    ops/s
         * 
         * Still slower though than allowing concurrency:
         * r.o.OperatorMergePerf.merge1SyncStreamOfN           1000  thrpt         5   149331.046     4851.290    ops/s
         * } </pre>
         */

        public MergeSubscriber(Subscriber<? super T> actual, boolean delayErrors) {
            super(actual);
            this.actual = actual;
            this.mergeProducer = new MergeProducer<T>(this);
            this.delayErrors = delayErrors;
            // decoupled the subscription chain because we need to decouple and control backpressure
            actual.add(this);
            actual.setProducer(mergeProducer);
        }

        @Override
        public void onStart() {
            // we request backpressure so we can handle long-running Observables that are enqueueing, such as flatMap use cases
            // we decouple the Producer chain while keeping the Subscription chain together (perf benefit) via super(actual)
            request(RxRingBuffer.SIZE);
        }

        /*
         * This is expected to be executed sequentially as per the Rx contract or it will not work.
         */
        @Override
        public void onNext(Observable<? extends T> t) {
            if (t instanceof ScalarSynchronousObservable) {
                ScalarSynchronousObservable<? extends T> t2 = (ScalarSynchronousObservable<? extends T>)t;
                handleScalarSynchronousObservable(t2);
            } else {
                if (t == null || isUnsubscribed()) {
                    return;
                }
                synchronized (this) {
                    // synchronized here because `wip` can be concurrently changed by children Observables
                    wip++;
                }
                handleNewSource(t);
            }
        }

        private void handleNewSource(Observable<? extends T> t) {
            if (childrenSubscribers == null) {
                // lazily create this only if we receive Observables we need to subscribe to
                childrenSubscribers = new SubscriptionIndexedRingBuffer<InnerSubscriber<T>>();
                add(childrenSubscribers);
            }
            MergeProducer<T> producerIfNeeded = null;
            // if we have received a request then we need to respect it, otherwise we fast-path
            if (mergeProducer.requested != Long.MAX_VALUE) {
                /**
                 * <pre> {@code
                 * With this optimization:
                 * 
                 * r.o.OperatorMergePerf.merge1SyncStreamOfN      1000  thrpt         5    57100.080     4686.331    ops/s
                 * r.o.OperatorMergePerf.merge1SyncStreamOfN   1000000  thrpt         5       60.875        1.622    ops/s
                 *  
                 * Without this optimization:
                 * 
                 * r.o.OperatorMergePerf.merge1SyncStreamOfN      1000  thrpt         5    29863.945     1858.002    ops/s
                 * r.o.OperatorMergePerf.merge1SyncStreamOfN   1000000  thrpt         5       30.516        1.087    ops/s
                 * } </pre>
                 */
                producerIfNeeded = mergeProducer;
            }
            InnerSubscriber<T> i = new InnerSubscriber<T>(this, producerIfNeeded);
            i.sindex = childrenSubscribers.add(i);
            t.unsafeSubscribe(i);
            request(1);
        }

        private void handleScalarSynchronousObservable(ScalarSynchronousObservable<? extends T> t) {
            // fast-path for scalar, synchronous values such as Observable.from(int)
            /**
             * Without this optimization:
             * 
             * <pre> {@code
             * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
             * r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  2,418,452.409   130572.665    ops/s
             * r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5     5,690.456       94.958    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5          takes too long
             * 
             * With this optimization:
             * 
             * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5,475,300.198   156741.334    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    68,932.278     1311.023    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       64.405        0.611    ops/s
             * } </pre>
             * 
             */
            if (mergeProducer.requested == Long.MAX_VALUE) {
                handleScalarSynchronousObservableWithoutRequestLimits(t);
            } else {
                handleScalarSynchronousObservableWithRequestLimits(t);
            }
        }

        private void handleScalarSynchronousObservableWithoutRequestLimits(ScalarSynchronousObservable<? extends T> t) {
            T value = t.get();
            if (getEmitLock()) {
                try {
                    actual.onNext(value);
                    return;
                } finally {
                    if (releaseEmitLock()) {
                        drainQueuesIfNeeded();
                    }
                    request(1);
                }
            } else {
                initScalarValueQueueIfNeeded();
                try {
                    scalarValueQueue.onNext(value);
                } catch (MissingBackpressureException e) {
                    onError(e);
                }
                return;
            }
        }

        private void handleScalarSynchronousObservableWithRequestLimits(ScalarSynchronousObservable<? extends T> t) {
            if (getEmitLock()) {
                boolean emitted = false;
                try {
                    long r = mergeProducer.requested;
                    if (r > 0) {
                        emitted = true;
                        actual.onNext(t.get());
                        MergeProducer.REQUESTED.decrementAndGet(mergeProducer);
                        // we handle this Observable without ever incrementing the wip or touching other machinery so just return here
                        return;
                    }
                } finally {
                    if (releaseEmitLock()) {
                        drainQueuesIfNeeded();
                    }
                    if (emitted) {
                        request(1);
                    }
                }
            }

            // if we didn't return above we need to enqueue
            // enqueue the values for later delivery
            initScalarValueQueueIfNeeded();
            try {
                scalarValueQueue.onNext(t.get());
            } catch (MissingBackpressureException e) {
                onError(e);
            }
        }

        private void initScalarValueQueueIfNeeded() {
            if (scalarValueQueue == null) {
                scalarValueQueue = RxRingBuffer.getSpmcInstance();
                add(scalarValueQueue);
            }
        }

        private synchronized boolean releaseEmitLock() {
            emitLock = false;
            if (missedEmitting == 0) {
                return false;
            } else {
                return true;
            }
        }

        private synchronized boolean getEmitLock() {
            if (emitLock) {
                missedEmitting++;
                return false;
            } else {
                emitLock = true;
                missedEmitting = 0;
                return true;
            }
        }

        private boolean drainQueuesIfNeeded() {
            while (true) {
                if (getEmitLock()) {
                    int emitted = 0;
                    try {
                        emitted = drainScalarValueQueue();
                        drainChildrenQueues();
                    } finally {
                        boolean moreToDrain = releaseEmitLock();
                        // request outside of lock
                        request(emitted);
                        if (!moreToDrain) {
                            return true;
                        }
                        // otherwise we'll loop and get whatever was added 
                    }
                } else {
                    return false;
                }
            }
        }

        int lastDrainedIndex = 0;

        /**
         * ONLY call when holding the EmitLock.
         */
        private void drainChildrenQueues() {
            if (childrenSubscribers != null) {
                lastDrainedIndex = childrenSubscribers.forEach(DRAIN_ACTION, lastDrainedIndex);
            }
        }

        /**
         * ONLY call when holding the EmitLock.
         */
        private int drainScalarValueQueue() {
            if (scalarValueQueue != null) {
                long r = mergeProducer.requested;
                int emittedWhileDraining = 0;
                if (r < 0) {
                    // drain it all
                    Object o = null;
                    while ((o = scalarValueQueue.poll()) != null) {
                        on.accept(actual, o);
                        emittedWhileDraining++;
                    }
                } else if (r > 0) {
                    // drain what was requested
                    long toEmit = r;
                    for (int i = 0; i < toEmit; i++) {
                        Object o = scalarValueQueue.poll();
                        if (o == null) {
                            break;
                        } else {
                            on.accept(actual, o);
                            emittedWhileDraining++;
                        }
                    }
                    // decrement the number we emitted from outstanding requests
                    MergeProducer.REQUESTED.getAndAdd(mergeProducer, -emittedWhileDraining);
                }
                return emittedWhileDraining;
            }
            return 0;
        }

        final Func1<InnerSubscriber<T>, Boolean> DRAIN_ACTION = new Func1<InnerSubscriber<T>, Boolean>() {

            @Override
            public Boolean call(InnerSubscriber<T> s) {
                if (s.q != null) {
                    long r = mergeProducer.requested;
                    int emitted = 0;
                    emitted += s.drainQueue();
                    if (emitted > 0) {
                        /*
                         * `s.emitted` is not volatile (because of performance impact of making it so shown by JMH tests)
                         * but `emitted` can ONLY be touched by the thread holding the `emitLock` which we're currently inside.
                         * 
                         * Entering and leaving the emitLock flushes all values so this is visible to us.
                         */
                        emitted += s.emitted;
                        // TODO we may want to store this in s.emitted and only request if above batch
                        // reset this since we have requested them all
                        s.emitted = 0;
                        s.requestMore(emitted);
                    }
                    if (emitted == r) {
                        // we emitted as many as were requested so stop the forEach loop
                        return Boolean.FALSE;
                    }
                }
                return Boolean.TRUE;
            }

        };

        @Override
        public void onError(Throwable e) {
            if (!completed) {
                completed = true;
                innerError(e, true);
            }
        }
        
        private void innerError(Throwable e, boolean parent) {
            if (delayErrors) {
                synchronized (this) {
                    if (exceptions == null) {
                        exceptions = new ConcurrentLinkedQueue<Throwable>();
                    }
                }
                exceptions.add(e);
                boolean sendOnComplete = false;
                synchronized (this) {
                    if (!parent) {
                        wip--;
                    }
                    if ((wip == 0 && completed) || (wip < 0)) {
                        sendOnComplete = true;
                    }
                }
                if (sendOnComplete) {
                    drainAndComplete();
                }
            } else {
                actual.onError(e);
            }
        }

        @Override
        public void onCompleted() {
            boolean c = false;
            synchronized (this) {
                completed = true;
                if (wip == 0 && (scalarValueQueue == null || scalarValueQueue.isEmpty())) {
                    c = true;
                }
            }
            if (c) {
                // complete outside of lock
                drainAndComplete();
            }
        }

        void completeInner(InnerSubscriber<T> s) {
            boolean sendOnComplete = false;
            synchronized (this) {
                wip--;
                if (wip == 0 && completed) {
                    sendOnComplete = true;
                }
            }
            childrenSubscribers.remove(s.sindex);
            if (sendOnComplete) {
                drainAndComplete();
            }
        }

        private void drainAndComplete() {
            drainQueuesIfNeeded(); // TODO need to confirm whether this is needed or not
            if (delayErrors) {
                Queue<Throwable> es = null;
                synchronized (this) {
                    es = exceptions;
                }
                if (es != null) {
                    if (es.isEmpty()) {
                        actual.onCompleted();
                    } else if (es.size() == 1) {
                        actual.onError(es.poll());
                    } else {
                        actual.onError(new CompositeException(es));
                    }
                } else {
                    actual.onCompleted();
                }
            } else {
                actual.onCompleted();
            }
        }

    }

    private static final class MergeProducer<T> implements Producer {

        private final MergeSubscriber<T> ms;

        public MergeProducer(MergeSubscriber<T> ms) {
            this.ms = ms;
        }

        private volatile long requested = 0;
        @SuppressWarnings(""rawtypes"")
        static final AtomicLongFieldUpdater<MergeProducer> REQUESTED = AtomicLongFieldUpdater.newUpdater(MergeProducer.class, ""requested"");

        @Override
        public void request(long n) {
            if (requested == Long.MAX_VALUE) {
                return;
            }
            if (n == Long.MAX_VALUE) {
                requested = Long.MAX_VALUE;
            } else {
                REQUESTED.getAndAdd(this, n);
                if (ms.drainQueuesIfNeeded()) {
                    boolean sendComplete = false;
                    synchronized (ms) {
                        if (ms.wip == 0 && ms.scalarValueQueue != null && ms.scalarValueQueue.isEmpty()) {
                            sendComplete = true;
                        }
                    }
                    if (sendComplete) {
                        ms.drainAndComplete();
                    }
                }
            }
        }

    }

    private static final class InnerSubscriber<T> extends Subscriber<T> {
        public int sindex;
        final MergeSubscriber<T> parentSubscriber;
        final MergeProducer<T> producer;
        /** Make sure the inner termination events are delivered only once. */
        volatile int terminated;
        @SuppressWarnings(""rawtypes"")
        static final AtomicIntegerFieldUpdater<InnerSubscriber> ONCE_TERMINATED = AtomicIntegerFieldUpdater.newUpdater(InnerSubscriber.class, ""terminated"");

        private final RxRingBuffer q = RxRingBuffer.getSpmcInstance();
        /* protected by emitLock */
        int emitted = 0;
        final int THRESHOLD = (int) (q.capacity() * 0.7);

        public InnerSubscriber(MergeSubscriber<T> parent, MergeProducer<T> producer) {
            this.parentSubscriber = parent;
            this.producer = producer;
            add(q);
            request(q.capacity());
        }

        @Override
        public void onNext(T t) {
            emit(t, false);
        }

        @Override
        public void onError(Throwable e) {
            // it doesn't go through queues, it immediately onErrors and tears everything down
            if (ONCE_TERMINATED.compareAndSet(this, 0, 1)) {
                parentSubscriber.innerError(e, false);
            }
        }

        @Override
        public void onCompleted() {
            if (ONCE_TERMINATED.compareAndSet(this, 0, 1)) {
                emit(null, true);
            }
        }

        public void requestMore(long n) {
            request(n);
        }

        private void emit(T t, boolean complete) {
            boolean drain = false;
            boolean enqueue = true;
            /**
             * This optimization to skip the queue is messy ... but it makes a big difference in performance when merging a single stream
             * with many values, or many intermittent streams without contention. It doesn't make much of a difference if there is contention.
             * 
             * Below are some of the relevant benchmarks to show the difference.
             * 
             * <pre> {@code
             * With this fast-path:
             * 
             * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
             * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5344143.680   393484.592    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    83582.662     4293.755    ops/s +++
             * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       73.889        4.477    ops/s +++
             * 
             * r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5799265.333   199205.296    ops/s +
             * r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       62.655        2.521    ops/s +++
             * 
             * r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76925.616     4909.174    ops/s
             * r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3634.977      242.469    ops/s
             * 
             * Without:
             * 
             * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
             * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5099295.678   159539.842    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    18196.671    10053.298    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       19.184        1.028    ops/s
             * 
             * r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5591612.719   591821.763    ops/s
             * r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       21.018        3.251    ops/s
             * 
             * r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    72692.073    18395.031    ops/s
             * r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     4379.093      386.368    ops/s
             * } </pre>
             * 
             * It looks like it may cause a slowdown in highly contended cases (like 'mergeTwoAsyncStreamsOfN' above) as instead of just
             * putting in the queue, it attempts to get the lock. We are optimizing for the non-contended case.
             */
            if (parentSubscriber.getEmitLock()) {
                enqueue = false;
                try {
                    // drain the queue if there is anything in it before emitting the current value
                    emitted += drainQueue();
                    //                    }
                    if (producer == null) {
                        // no backpressure requested
                        if (complete) {
                            parentSubscriber.completeInner(this);
                        } else {
                            try {
                                parentSubscriber.actual.onNext(t);
                            } catch (Throwable e) {
                                // special error handling due to complexity of merge
                                onError(OnErrorThrowable.addValueAsLastCause(e, t));
                            }
                            emitted++;
                        }
                    } else {
                        // this needs to check q.count() as draining above may not have drained the full queue
                        // perf tests show this to be okay, though different queue implementations could perform poorly with this
                        if (producer.requested > 0 && q.count() == 0) {
                            if (complete) {
                                parentSubscriber.completeInner(this);
                            } else {
                                try {
                                    parentSubscriber.actual.onNext(t);
                                } catch (Throwable e) {
                                    // special error handling due to complexity of merge
                                    onError(OnErrorThrowable.addValueAsLastCause(e, t));
                                }
                                emitted++;
                                MergeProducer.REQUESTED.decrementAndGet(producer);
                            }
                        } else {
                            // no requests available, so enqueue it
                            enqueue = true;
                        }
                    }
                } finally {
                    drain = parentSubscriber.releaseEmitLock();
                }
                if (emitted > THRESHOLD) {
                    // this is for batching requests when we're in a use case that isn't queueing, always fast-pathing the onNext
                    /**
                     * <pre> {@code
                     * Without this batching:
                     * 
                     * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5060743.715   100445.513    ops/s
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    36606.582     1610.582    ops/s
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       38.476        0.973    ops/s
                     * 
                     * With this batching:
                     * 
                     * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5367945.738   262740.137    ops/s
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    62703.930     8496.036    ops/s
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       72.711        3.746    ops/s
                     *} </pre>
                     */
                    request(emitted);
                    // we are modifying this outside of the emit lock ... but this can be considered a ""lazySet""
                    // and it will be flushed before anything else touches it because the emitLock will be obtained
                    // before any other usage of it
                    emitted = 0;
                }
            }
            if (enqueue) {
                enqueue(t, complete);
                drain = true;
            }
            if (drain) {
                /**
                 * This extra check for whether to call drain is ugly, but it helps:
                 * <pre> {@code
                 * Without:
                 * r.o.OperatorMergePerf.mergeNSyncStreamsOfN     1000  thrpt         5       61.812        1.455    ops/s
                 * 
                 * With:
                 * r.o.OperatorMergePerf.mergeNSyncStreamsOfN     1000  thrpt         5       78.795        1.766    ops/s
                 * } </pre>
                 */
                parentSubscriber.drainQueuesIfNeeded();
            }
        }

        private void enqueue(T t, boolean complete) {
            try {
                if (complete) {
                    q.onCompleted();
                } else {
                    q.onNext(t);
                }
            } catch (MissingBackpressureException e) {
                onError(e);
            }
        }

        private int drainRequested() {
            int emitted = 0;
            // drain what was requested
            long toEmit = producer.requested;
            Object o;
            for (int i = 0; i < toEmit; i++) {
                o = q.poll();
                if (o == null) {
                    // no more items
                    break;
                } else if (q.isCompleted(o)) {
                    parentSubscriber.completeInner(this);
                } else {
                    try {
                        if (!q.accept(o, parentSubscriber.actual)) {
                            emitted++;
                        }
                    } catch (Throwable e) {
                        // special error handling due to complexity of merge
                        onError(OnErrorThrowable.addValueAsLastCause(e, o));
                    }
                }
            }

            // decrement the number we emitted from outstanding requests
            MergeProducer.REQUESTED.getAndAdd(producer, -emitted);
            return emitted;
        }

        private int drainAll() {
            int emitted = 0;
            // drain it all
            Object o;
            while ((o = q.poll()) != null) {
                if (q.isCompleted(o)) {
                    parentSubscriber.completeInner(this);
                } else {
                    try {
                        if (!q.accept(o, parentSubscriber.actual)) {
                            emitted++;
                        }
                    } catch (Throwable e) {
                        // special error handling due to complexity of merge
                        onError(OnErrorThrowable.addValueAsLastCause(e, o));
                    }
                }
            }
            return emitted;
        }

        private int drainQueue() {
            if (producer != null) {
                return drainRequested();
            } else {
                return drainAll();
            }
        }
    }
}",        private void innerError(Throwable e),"        private void innerError(Throwable e, boolean parent)"
053e506e7eee63a6a2631a41482691bef9bc5a53,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.internal.operators;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicLongFieldUpdater;

import rx.Observable;
import rx.Observable.Operator;
import rx.Producer;
import rx.Subscriber;
import rx.exceptions.CompositeException;
import rx.exceptions.MissingBackpressureException;
import rx.exceptions.OnErrorThrowable;
import rx.functions.Func1;
import rx.internal.util.RxRingBuffer;
import rx.internal.util.ScalarSynchronousObservable;
import rx.internal.util.SubscriptionIndexedRingBuffer;

/**
 * Flattens a list of {@link Observable}s into one {@code Observable}, without any transformation.
 * <p>
 * <img width=""640"" height=""380"" src=""https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png"" alt="""">
 * <p>
 * You can combine the items emitted by multiple {@code Observable}s so that they act like a single {@code Observable}, by using the merge operation.
 * 
 * @param <T>
 *            the type of the items emitted by both the source and merged {@code Observable}s
 */
public class OperatorMerge<T> implements Operator<T, Observable<? extends T>> {

    /*
     * benjchristensen => This class is complex and I'm not a fan of it despite writing it. I want to give some background
     * as to why for anyone who wants to try and help improve it.
     * 
     * One of my first implementations that added backpressure support (Producer.request) was fairly elegant and used a simple
     * queue draining approach. It was simple to understand as all onNext were added to their queues, then a single winner
     * would drain the queues, similar to observeOn. It killed the Netflix API when I canaried it. There were two problems:
     * (1) performance and (2) object allocation overhead causing massive GC pressure. Remember that merge is one of the most
     * used operators (mostly due to flatmap) and is therefore critical to and a limiter of performance in any application.
     * 
     * All subsequent work on this class and the various fast-paths and branches within it have been to achieve the needed functionality
     * while reducing or eliminating object allocation and keeping performance acceptable.
     * 
     * This has meant adopting strategies such as:
     * 
     * - ring buffers instead of growable queues
     * - object pooling
     * - skipping request logic when downstream does not need backpressure
     * - ScalarValueQueue for optimizing synchronous single-value Observables
     * - adopting data structures that use Unsafe (and gating them based on environment so non-Oracle JVMs still work)
     * 
     * It has definitely increased the complexity and maintenance cost of this class, but the performance gains have been significant.
     * 
     * The biggest cost of the increased complexity is concurrency bugs and reasoning through what's going on.
     * 
     * I'd love to have contributions that improve this class, but keep in mind the performance and GC pressure.
     * The benchmarks I use are in the JMH OperatorMergePerf class. GC memory pressure is tested using Java Flight Recorder
     * to track object allocation.
     */

    public OperatorMerge() {
        this.delayErrors = false;
    }

    public OperatorMerge(boolean delayErrors) {
        this.delayErrors = delayErrors;
    }

    private final boolean delayErrors;

    @Override
    public Subscriber<Observable<? extends T>> call(final Subscriber<? super T> child) {
        return new MergeSubscriber<T>(child, delayErrors);

    }

    private static final class MergeSubscriber<T> extends Subscriber<Observable<? extends T>> {
        final NotificationLite<T> on = NotificationLite.instance();
        final Subscriber<? super T> actual;
        private final MergeProducer<T> mergeProducer;
        private int wip;
        private boolean completed;
        private final boolean delayErrors;
        private ConcurrentLinkedQueue<Throwable> exceptions;

        private volatile SubscriptionIndexedRingBuffer<InnerSubscriber<T>> childrenSubscribers;

        private RxRingBuffer scalarValueQueue = null;

        /* protected by lock on MergeSubscriber instance */
        private int missedEmitting = 0;
        private boolean emitLock = false;

        /**
         * Using synchronized(this) for `emitLock` instead of ReentrantLock or AtomicInteger is faster when there is no contention.
         * 
         * <pre> {@code
         * Using ReentrantLock:
         * r.o.OperatorMergePerf.merge1SyncStreamOfN           1000  thrpt         5    44185.294     1295.565    ops/s
         * 
         * Using synchronized(this):
         * r.o.OperatorMergePerf.merge1SyncStreamOfN           1000  thrpt         5    79715.981     3704.486    ops/s
         * 
         * Still slower though than allowing concurrency:
         * r.o.OperatorMergePerf.merge1SyncStreamOfN           1000  thrpt         5   149331.046     4851.290    ops/s
         * } </pre>
         */

        public MergeSubscriber(Subscriber<? super T> actual, boolean delayErrors) {
            super(actual);
            this.actual = actual;
            this.mergeProducer = new MergeProducer<T>(this);
            this.delayErrors = delayErrors;
            // decoupled the subscription chain because we need to decouple and control backpressure
            actual.add(this);
            actual.setProducer(mergeProducer);
        }

        @Override
        public void onStart() {
            // we request backpressure so we can handle long-running Observables that are enqueueing, such as flatMap use cases
            // we decouple the Producer chain while keeping the Subscription chain together (perf benefit) via super(actual)
            request(RxRingBuffer.SIZE);
        }

        /*
         * This is expected to be executed sequentially as per the Rx contract or it will not work.
         */
        @Override
        public void onNext(Observable<? extends T> t) {
            if (t instanceof ScalarSynchronousObservable) {
                ScalarSynchronousObservable<? extends T> t2 = (ScalarSynchronousObservable<? extends T>)t;
                handleScalarSynchronousObservable(t2);
            } else {
                if (t == null || isUnsubscribed()) {
                    return;
                }
                synchronized (this) {
                    // synchronized here because `wip` can be concurrently changed by children Observables
                    wip++;
                }
                handleNewSource(t);
            }
        }

        private void handleNewSource(Observable<? extends T> t) {
            if (childrenSubscribers == null) {
                // lazily create this only if we receive Observables we need to subscribe to
                childrenSubscribers = new SubscriptionIndexedRingBuffer<InnerSubscriber<T>>();
                add(childrenSubscribers);
            }
            MergeProducer<T> producerIfNeeded = null;
            // if we have received a request then we need to respect it, otherwise we fast-path
            if (mergeProducer.requested != Long.MAX_VALUE) {
                /**
                 * <pre> {@code
                 * With this optimization:
                 * 
                 * r.o.OperatorMergePerf.merge1SyncStreamOfN      1000  thrpt         5    57100.080     4686.331    ops/s
                 * r.o.OperatorMergePerf.merge1SyncStreamOfN   1000000  thrpt         5       60.875        1.622    ops/s
                 *  
                 * Without this optimization:
                 * 
                 * r.o.OperatorMergePerf.merge1SyncStreamOfN      1000  thrpt         5    29863.945     1858.002    ops/s
                 * r.o.OperatorMergePerf.merge1SyncStreamOfN   1000000  thrpt         5       30.516        1.087    ops/s
                 * } </pre>
                 */
                producerIfNeeded = mergeProducer;
            }
            InnerSubscriber<T> i = new InnerSubscriber<T>(this, producerIfNeeded);
            i.sindex = childrenSubscribers.add(i);
            t.unsafeSubscribe(i);
            request(1);
        }

        private void handleScalarSynchronousObservable(ScalarSynchronousObservable<? extends T> t) {
            // fast-path for scalar, synchronous values such as Observable.from(int)
            /**
             * Without this optimization:
             * 
             * <pre> {@code
             * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
             * r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  2,418,452.409   130572.665    ops/s
             * r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5     5,690.456       94.958    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5          takes too long
             * 
             * With this optimization:
             * 
             * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5,475,300.198   156741.334    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    68,932.278     1311.023    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       64.405        0.611    ops/s
             * } </pre>
             * 
             */
            if (mergeProducer.requested == Long.MAX_VALUE) {
                handleScalarSynchronousObservableWithoutRequestLimits(t);
            } else {
                handleScalarSynchronousObservableWithRequestLimits(t);
            }
        }

        private void handleScalarSynchronousObservableWithoutRequestLimits(ScalarSynchronousObservable<? extends T> t) {
            T value = t.get();
            if (getEmitLock()) {
                try {
                    actual.onNext(value);
                    return;
                } finally {
                    if (releaseEmitLock()) {
                        drainQueuesIfNeeded();
                    }
                    request(1);
                }
            } else {
                initScalarValueQueueIfNeeded();
                try {
                    scalarValueQueue.onNext(value);
                } catch (MissingBackpressureException e) {
                    onError(e);
                }
                return;
            }
        }

        private void handleScalarSynchronousObservableWithRequestLimits(ScalarSynchronousObservable<? extends T> t) {
            if (getEmitLock()) {
                boolean emitted = false;
                try {
                    long r = mergeProducer.requested;
                    if (r > 0) {
                        emitted = true;
                        actual.onNext(t.get());
                        MergeProducer.REQUESTED.decrementAndGet(mergeProducer);
                        // we handle this Observable without ever incrementing the wip or touching other machinery so just return here
                        return;
                    }
                } finally {
                    if (releaseEmitLock()) {
                        drainQueuesIfNeeded();
                    }
                    if (emitted) {
                        request(1);
                    }
                }
            }

            // if we didn't return above we need to enqueue
            // enqueue the values for later delivery
            initScalarValueQueueIfNeeded();
            try {
                scalarValueQueue.onNext(t.get());
            } catch (MissingBackpressureException e) {
                onError(e);
            }
        }

        private void initScalarValueQueueIfNeeded() {
            if (scalarValueQueue == null) {
                scalarValueQueue = RxRingBuffer.getSpmcInstance();
                add(scalarValueQueue);
            }
        }

        private synchronized boolean releaseEmitLock() {
            emitLock = false;
            if (missedEmitting == 0) {
                return false;
            } else {
                return true;
            }
        }

        private synchronized boolean getEmitLock() {
            if (emitLock) {
                missedEmitting++;
                return false;
            } else {
                emitLock = true;
                missedEmitting = 0;
                return true;
            }
        }

        private boolean drainQueuesIfNeeded() {
            while (true) {
                if (getEmitLock()) {
                    int emitted = 0;
                    try {
                        emitted = drainScalarValueQueue();
                        drainChildrenQueues();
                    } finally {
                        boolean moreToDrain = releaseEmitLock();
                        // request outside of lock
                        if (emitted > 0) {
                            request(emitted);
                        }
                        if (!moreToDrain) {
                            return true;
                        }
                        // otherwise we'll loop and get whatever was added 
                    }
                } else {
                    return false;
                }
            }
        }

        int lastDrainedIndex = 0;

        /**
         * ONLY call when holding the EmitLock.
         */
        private void drainChildrenQueues() {
            if (childrenSubscribers != null) {
                lastDrainedIndex = childrenSubscribers.forEach(DRAIN_ACTION, lastDrainedIndex);
            }
        }

        /**
         * ONLY call when holding the EmitLock.
         */
        private int drainScalarValueQueue() {
            if (scalarValueQueue != null) {
                long r = mergeProducer.requested;
                int emittedWhileDraining = 0;
                if (r < 0) {
                    // drain it all
                    Object o = null;
                    while ((o = scalarValueQueue.poll()) != null) {
                        on.accept(actual, o);
                        emittedWhileDraining++;
                    }
                } else if (r > 0) {
                    // drain what was requested
                    long toEmit = r;
                    for (int i = 0; i < toEmit; i++) {
                        Object o = scalarValueQueue.poll();
                        if (o == null) {
                            break;
                        } else {
                            on.accept(actual, o);
                            emittedWhileDraining++;
                        }
                    }
                    // decrement the number we emitted from outstanding requests
                    MergeProducer.REQUESTED.getAndAdd(mergeProducer, -emittedWhileDraining);
                }
                return emittedWhileDraining;
            }
            return 0;
        }

        final Func1<InnerSubscriber<T>, Boolean> DRAIN_ACTION = new Func1<InnerSubscriber<T>, Boolean>() {

            @Override
            public Boolean call(InnerSubscriber<T> s) {
                if (s.q != null) {
                    long r = mergeProducer.requested;
                    int emitted = 0;
                    emitted += s.drainQueue();
                    if (emitted > 0) {
                        /*
                         * `s.emitted` is not volatile (because of performance impact of making it so shown by JMH tests)
                         * but `emitted` can ONLY be touched by the thread holding the `emitLock` which we're currently inside.
                         * 
                         * Entering and leaving the emitLock flushes all values so this is visible to us.
                         */
                        emitted += s.emitted;
                        // TODO we may want to store this in s.emitted and only request if above batch
                        // reset this since we have requested them all
                        s.emitted = 0;
                        s.requestMore(emitted);
                    }
                    if (emitted == r) {
                        // we emitted as many as were requested so stop the forEach loop
                        return Boolean.FALSE;
                    }
                }
                return Boolean.TRUE;
            }

        };

        @Override
        public void onError(Throwable e) {
            if (!completed) {
                completed = true;
                innerError(e, true);
            }
        }
        
        private void innerError(Throwable e, boolean parent) {
            if (delayErrors) {
                synchronized (this) {
                    if (exceptions == null) {
                        exceptions = new ConcurrentLinkedQueue<Throwable>();
                    }
                }
                exceptions.add(e);
                boolean sendOnComplete = false;
                synchronized (this) {
                    if (!parent) {
                        wip--;
                    }
                    if ((wip == 0 && completed) || (wip < 0)) {
                        sendOnComplete = true;
                    }
                }
                if (sendOnComplete) {
                    drainAndComplete();
                }
            } else {
                actual.onError(e);
            }
        }

        @Override
        public void onCompleted() {
            boolean c = false;
            synchronized (this) {
                completed = true;
                if (wip == 0 && (scalarValueQueue == null || scalarValueQueue.isEmpty())) {
                    c = true;
                }
            }
            if (c) {
                // complete outside of lock
                drainAndComplete();
            }
        }

        void completeInner(InnerSubscriber<T> s) {
            boolean sendOnComplete = false;
            synchronized (this) {
                wip--;
                if (wip == 0 && completed) {
                    sendOnComplete = true;
                }
            }
            childrenSubscribers.remove(s.sindex);
            if (sendOnComplete) {
                drainAndComplete();
            }
        }

        private void drainAndComplete() {
            drainQueuesIfNeeded(); // TODO need to confirm whether this is needed or not
            if (delayErrors) {
                Queue<Throwable> es = null;
                synchronized (this) {
                    es = exceptions;
                }
                if (es != null) {
                    if (es.isEmpty()) {
                        actual.onCompleted();
                    } else if (es.size() == 1) {
                        actual.onError(es.poll());
                    } else {
                        actual.onError(new CompositeException(es));
                    }
                } else {
                    actual.onCompleted();
                }
            } else {
                actual.onCompleted();
            }
        }

    }

    private static final class MergeProducer<T> implements Producer {

        private final MergeSubscriber<T> ms;

        public MergeProducer(MergeSubscriber<T> ms) {
            this.ms = ms;
        }

        private volatile long requested = 0;
        @SuppressWarnings(""rawtypes"")
        static final AtomicLongFieldUpdater<MergeProducer> REQUESTED = AtomicLongFieldUpdater.newUpdater(MergeProducer.class, ""requested"");

        @Override
        public void request(long n) {
            if (requested == Long.MAX_VALUE) {
                return;
            }
            if (n == Long.MAX_VALUE) {
                requested = Long.MAX_VALUE;
            } else {
                REQUESTED.getAndAdd(this, n);
                if (ms.drainQueuesIfNeeded()) {
                    boolean sendComplete = false;
                    synchronized (ms) {
                        if (ms.wip == 0 && ms.scalarValueQueue != null && ms.scalarValueQueue.isEmpty()) {
                            sendComplete = true;
                        }
                    }
                    if (sendComplete) {
                        ms.drainAndComplete();
                    }
                }
            }
        }

    }

    private static final class InnerSubscriber<T> extends Subscriber<T> {
        public int sindex;
        final MergeSubscriber<T> parentSubscriber;
        final MergeProducer<T> producer;
        /** Make sure the inner termination events are delivered only once. */
        @SuppressWarnings(""unused"")
        volatile int terminated;
        @SuppressWarnings(""rawtypes"")
        static final AtomicIntegerFieldUpdater<InnerSubscriber> ONCE_TERMINATED = AtomicIntegerFieldUpdater.newUpdater(InnerSubscriber.class, ""terminated"");

        private final RxRingBuffer q = RxRingBuffer.getSpmcInstance();
        /* protected by emitLock */
        int emitted = 0;
        final int THRESHOLD = (int) (q.capacity() * 0.7);

        public InnerSubscriber(MergeSubscriber<T> parent, MergeProducer<T> producer) {
            this.parentSubscriber = parent;
            this.producer = producer;
            add(q);
            request(q.capacity());
        }

        @Override
        public void onNext(T t) {
            emit(t, false);
        }

        @Override
        public void onError(Throwable e) {
            // it doesn't go through queues, it immediately onErrors and tears everything down
            if (ONCE_TERMINATED.compareAndSet(this, 0, 1)) {
                parentSubscriber.innerError(e, false);
            }
        }

        @Override
        public void onCompleted() {
            if (ONCE_TERMINATED.compareAndSet(this, 0, 1)) {
                emit(null, true);
            }
        }

        public void requestMore(long n) {
            request(n);
        }

        private void emit(T t, boolean complete) {
            boolean drain = false;
            boolean enqueue = true;
            /**
             * This optimization to skip the queue is messy ... but it makes a big difference in performance when merging a single stream
             * with many values, or many intermittent streams without contention. It doesn't make much of a difference if there is contention.
             * 
             * Below are some of the relevant benchmarks to show the difference.
             * 
             * <pre> {@code
             * With this fast-path:
             * 
             * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
             * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5344143.680   393484.592    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    83582.662     4293.755    ops/s +++
             * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       73.889        4.477    ops/s +++
             * 
             * r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5799265.333   199205.296    ops/s +
             * r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       62.655        2.521    ops/s +++
             * 
             * r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76925.616     4909.174    ops/s
             * r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3634.977      242.469    ops/s
             * 
             * Without:
             * 
             * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
             * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5099295.678   159539.842    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    18196.671    10053.298    ops/s
             * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       19.184        1.028    ops/s
             * 
             * r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5591612.719   591821.763    ops/s
             * r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       21.018        3.251    ops/s
             * 
             * r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    72692.073    18395.031    ops/s
             * r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     4379.093      386.368    ops/s
             * } </pre>
             * 
             * It looks like it may cause a slowdown in highly contended cases (like 'mergeTwoAsyncStreamsOfN' above) as instead of just
             * putting in the queue, it attempts to get the lock. We are optimizing for the non-contended case.
             */
            if (parentSubscriber.getEmitLock()) {
                enqueue = false;
                try {
                    // drain the queue if there is anything in it before emitting the current value
                    emitted += drainQueue();
                    //                    }
                    if (producer == null) {
                        // no backpressure requested
                        if (complete) {
                            parentSubscriber.completeInner(this);
                        } else {
                            try {
                                parentSubscriber.actual.onNext(t);
                            } catch (Throwable e) {
                                // special error handling due to complexity of merge
                                onError(OnErrorThrowable.addValueAsLastCause(e, t));
                            }
                            emitted++;
                        }
                    } else {
                        // this needs to check q.count() as draining above may not have drained the full queue
                        // perf tests show this to be okay, though different queue implementations could perform poorly with this
                        if (producer.requested > 0 && q.count() == 0) {
                            if (complete) {
                                parentSubscriber.completeInner(this);
                            } else {
                                try {
                                    parentSubscriber.actual.onNext(t);
                                } catch (Throwable e) {
                                    // special error handling due to complexity of merge
                                    onError(OnErrorThrowable.addValueAsLastCause(e, t));
                                }
                                emitted++;
                                MergeProducer.REQUESTED.decrementAndGet(producer);
                            }
                        } else {
                            // no requests available, so enqueue it
                            enqueue = true;
                        }
                    }
                } finally {
                    drain = parentSubscriber.releaseEmitLock();
                }
                if (emitted > THRESHOLD) {
                    // this is for batching requests when we're in a use case that isn't queueing, always fast-pathing the onNext
                    /**
                     * <pre> {@code
                     * Without this batching:
                     * 
                     * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5060743.715   100445.513    ops/s
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    36606.582     1610.582    ops/s
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       38.476        0.973    ops/s
                     * 
                     * With this batching:
                     * 
                     * Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5367945.738   262740.137    ops/s
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    62703.930     8496.036    ops/s
                     * r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       72.711        3.746    ops/s
                     *} </pre>
                     */
                    request(emitted);
                    // we are modifying this outside of the emit lock ... but this can be considered a ""lazySet""
                    // and it will be flushed before anything else touches it because the emitLock will be obtained
                    // before any other usage of it
                    emitted = 0;
                }
            }
            if (enqueue) {
                enqueue(t, complete);
                drain = true;
            }
            if (drain) {
                /**
                 * This extra check for whether to call drain is ugly, but it helps:
                 * <pre> {@code
                 * Without:
                 * r.o.OperatorMergePerf.mergeNSyncStreamsOfN     1000  thrpt         5       61.812        1.455    ops/s
                 * 
                 * With:
                 * r.o.OperatorMergePerf.mergeNSyncStreamsOfN     1000  thrpt         5       78.795        1.766    ops/s
                 * } </pre>
                 */
                parentSubscriber.drainQueuesIfNeeded();
            }
        }

        private void enqueue(T t, boolean complete) {
            try {
                if (complete) {
                    q.onCompleted();
                } else {
                    q.onNext(t);
                }
            } catch (MissingBackpressureException e) {
                onError(e);
            }
        }

        private int drainRequested() {
            int emitted = 0;
            // drain what was requested
            long toEmit = producer.requested;
            Object o;
            for (int i = 0; i < toEmit; i++) {
                o = q.poll();
                if (o == null) {
                    // no more items
                    break;
                } else if (q.isCompleted(o)) {
                    parentSubscriber.completeInner(this);
                } else {
                    try {
                        if (!q.accept(o, parentSubscriber.actual)) {
                            emitted++;
                        }
                    } catch (Throwable e) {
                        // special error handling due to complexity of merge
                        onError(OnErrorThrowable.addValueAsLastCause(e, o));
                    }
                }
            }

            // decrement the number we emitted from outstanding requests
            MergeProducer.REQUESTED.getAndAdd(producer, -emitted);
            return emitted;
        }

        private int drainAll() {
            int emitted = 0;
            // drain it all
            Object o;
            while ((o = q.poll()) != null) {
                if (q.isCompleted(o)) {
                    parentSubscriber.completeInner(this);
                } else {
                    try {
                        if (!q.accept(o, parentSubscriber.actual)) {
                            emitted++;
                        }
                    } catch (Throwable e) {
                        // special error handling due to complexity of merge
                        onError(OnErrorThrowable.addValueAsLastCause(e, o));
                    }
                }
            }
            return emitted;
        }

        private int drainQueue() {
            if (producer != null) {
                return drainRequested();
            } else {
                return drainAll();
            }
        }
    }
}",        private void innerError(Throwable e),"        private void innerError(Throwable e, boolean parent)"
af275628baa8e62e2e00271ee08fff01de77845a,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.internal.operators;

import java.nio.BufferOverflowException;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable.Operator;
import rx.Producer;
import rx.Subscriber;
import rx.functions.Func0;

public class OperatorOnBackpressureBuffer<T> implements Operator<T, T> {

    private final NotificationLite<T> on = NotificationLite.instance();

    private final Long capacity;
    private final Func0 onOverflow;

    public OperatorOnBackpressureBuffer() {
        this.capacity = null;
        this.onOverflow = null;
    }

    public OperatorOnBackpressureBuffer(long capacity) {
        this(capacity, null);
    }

    public OperatorOnBackpressureBuffer(long capacity, Func0<Void> onOverflow) {
        if (capacity <= 0) {
            throw new IllegalArgumentException(""Buffer capacity must be > 0"");
        }
        this.capacity = capacity;
        this.onOverflow = onOverflow;
    }

    @Override
    public Subscriber<? super T> call(final Subscriber<? super T> child) {
        // TODO get a different queue implementation
        final ConcurrentLinkedQueue<Object> queue = new ConcurrentLinkedQueue<Object>();
        final AtomicLong capacity = (this.capacity == null) ? null : new AtomicLong(this.capacity);
        final AtomicLong wip = new AtomicLong();
        final AtomicLong requested = new AtomicLong();

        child.setProducer(new Producer() {

            @Override
            public void request(long n) {
                if (requested.getAndAdd(n) == 0) {
                    pollQueue(wip, requested, capacity, queue, child);
                }
            }

        });
        // don't pass through subscriber as we are async and doing queue draining
        // a parent being unsubscribed should not affect the children
        Subscriber<T> parent = new Subscriber<T>() {

            private AtomicBoolean saturated = new AtomicBoolean(false);

            @Override
            public void onStart() {
                request(Long.MAX_VALUE);
            }

            @Override
            public void onCompleted() {
                queue.offer(on.completed());
                pollQueue(wip, requested, capacity, queue, child);
            }

            @Override
            public void onError(Throwable e) {
                queue.offer(on.error(e));
                pollQueue(wip, requested, capacity, queue, child);
            }

            @Override
            public void onNext(T t) {
                if (!ensureCapacity()) {
                    return;
                }
                queue.offer(on.next(t));
                pollQueue(wip, requested, capacity, queue, child);
            }

            private boolean ensureCapacity() {
                if (capacity == null) {
                    return true;
                }

                long currCapacity;
                do {
                    currCapacity = capacity.get();
                    if (currCapacity <= 0) {
                        if (saturated.compareAndSet(false, true)) {
                            // ensure single completion contract
                            child.onError(new BufferOverflowException());
                            unsubscribe();
                            if (onOverflow != null) {
                                onOverflow.call();
                            }
                        }
                        return false;
                    }
                // ensure no other thread stole our slot, or retry
                } while (!capacity.compareAndSet(currCapacity, currCapacity - 1));
                return true;
            }
        };
        
        // if child unsubscribes it should unsubscribe the parent, but not the other way around
        child.add(parent);
        
        return parent;
    }

    private void pollQueue(AtomicLong wip, AtomicLong requested, AtomicLong capacity, Queue<Object> queue, Subscriber<? super T> child) {
        // TODO can we do this without putting everything in the queue first so we can fast-path the case when we don't need to queue?
        if (requested.get() > 0) {
            // only one draining at a time
            try {
                /*
                 * This needs to protect against concurrent execution because `request` and `on*` events can come concurrently.
                 */
                if (wip.getAndIncrement() == 0) {
                    while (true) {
                        if (requested.getAndDecrement() != 0) {
                            Object o = queue.poll();
                            if (o == null) {
                                // nothing in queue
                                requested.incrementAndGet();
                                return;
                            }
                            if (capacity != null) { // it's bounded
                                capacity.incrementAndGet();
                            }
                            on.accept(child, o);
                        } else {
                            // we hit the end ... so increment back to 0 again
                            requested.incrementAndGet();
                            return;
                        }
                    }
                }

            } finally {
                wip.decrementAndGet();
            }
        }
    }
}
","    private void pollQueue(AtomicLong wip, AtomicLong requested, Queue<Object> queue, Subscriber<? super T> child)","    private void pollQueue(AtomicLong wip, AtomicLong requested, AtomicLong capacity, Queue<Object> queue, Subscriber<? super T> child)"
c4265fc75fd6cae0588f0efa15814d22e29111bc,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.internal.operators;

import java.nio.BufferOverflowException;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable.Operator;
import rx.Producer;
import rx.Subscriber;
import rx.functions.Func0;

public class OperatorOnBackpressureBuffer<T> implements Operator<T, T> {

    private final NotificationLite<T> on = NotificationLite.instance();

    private final Long capacity;
    private final Func0 onOverflow;

    public OperatorOnBackpressureBuffer() {
        this.capacity = null;
        this.onOverflow = null;
    }

    public OperatorOnBackpressureBuffer(long capacity) {
        this(capacity, null);
    }

    public OperatorOnBackpressureBuffer(long capacity, Func0<Void> onOverflow) {
        if (capacity <= 0) {
            throw new IllegalArgumentException(""Buffer capacity must be > 0"");
        }
        this.capacity = capacity;
        this.onOverflow = onOverflow;
    }

    @Override
    public Subscriber<? super T> call(final Subscriber<? super T> child) {
        // TODO get a different queue implementation
        final ConcurrentLinkedQueue<Object> queue = new ConcurrentLinkedQueue<Object>();
        final AtomicLong capacity = (this.capacity == null) ? null : new AtomicLong(this.capacity);
        final AtomicLong wip = new AtomicLong();
        final AtomicLong requested = new AtomicLong();

        child.setProducer(new Producer() {

            @Override
            public void request(long n) {
                if (requested.getAndAdd(n) == 0) {
                    pollQueue(wip, requested, capacity, queue, child);
                }
            }

        });
        // don't pass through subscriber as we are async and doing queue draining
        // a parent being unsubscribed should not affect the children
        Subscriber<T> parent = new Subscriber<T>() {

            private AtomicBoolean saturated = new AtomicBoolean(false);

            @Override
            public void onStart() {
                request(Long.MAX_VALUE);
            }

            @Override
            public void onCompleted() {
                queue.offer(on.completed());
                pollQueue(wip, requested, capacity, queue, child);
            }

            @Override
            public void onError(Throwable e) {
                queue.offer(on.error(e));
                pollQueue(wip, requested, capacity, queue, child);
            }

            @Override
            public void onNext(T t) {
                if (!ensureCapacity()) {
                    return;
                }
                queue.offer(on.next(t));
                pollQueue(wip, requested, capacity, queue, child);
            }

            private boolean ensureCapacity() {
                if (capacity == null) {
                    return true;
                }

                long currCapacity;
                do {
                    currCapacity = capacity.get();
                    if (currCapacity <= 0) {
                        if (saturated.compareAndSet(false, true)) {
                            // ensure single completion contract
                            child.onError(new BufferOverflowException());
                            unsubscribe();
                            if (onOverflow != null) {
                                onOverflow.call();
                            }
                        }
                        return false;
                    }
                // ensure no other thread stole our slot, or retry
                } while (!capacity.compareAndSet(currCapacity, currCapacity - 1));
                return true;
            }
        };
        
        // if child unsubscribes it should unsubscribe the parent, but not the other way around
        child.add(parent);
        
        return parent;
    }

    private void pollQueue(AtomicLong wip, AtomicLong requested, AtomicLong capacity, Queue<Object> queue, Subscriber<? super T> child) {
        // TODO can we do this without putting everything in the queue first so we can fast-path the case when we don't need to queue?
        if (requested.get() > 0) {
            // only one draining at a time
            try {
                /*
                 * This needs to protect against concurrent execution because `request` and `on*` events can come concurrently.
                 */
                if (wip.getAndIncrement() == 0) {
                    while (true) {
                        if (requested.getAndDecrement() != 0) {
                            Object o = queue.poll();
                            if (o == null) {
                                // nothing in queue
                                requested.incrementAndGet();
                                return;
                            }
                            if (capacity != null) { // it's bounded
                                capacity.incrementAndGet();
                            }
                            on.accept(child, o);
                        } else {
                            // we hit the end ... so increment back to 0 again
                            requested.incrementAndGet();
                            return;
                        }
                    }
                }

            } finally {
                wip.decrementAndGet();
            }
        }
    }
}
","    private void pollQueue(AtomicLong wip, AtomicLong requested, Queue<Object> queue, Subscriber<? super T> child)","    private void pollQueue(AtomicLong wip, AtomicLong requested, AtomicLong capacity, Queue<Object> queue, Subscriber<? super T> child)"
c8c272ef57140fbb0cc2d36cf46e7e4763e4820d,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.internal.operators;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable.Operator;
import rx.Producer;
import rx.Subscriber;
import rx.exceptions.MissingBackpressureException;
import rx.functions.Action0;

public class OperatorOnBackpressureBuffer<T> implements Operator<T, T> {

    private final NotificationLite<T> on = NotificationLite.instance();

    private final Long capacity;
    private final Action0 onOverflow;

    public OperatorOnBackpressureBuffer() {
        this.capacity = null;
        this.onOverflow = null;
    }

    public OperatorOnBackpressureBuffer(long capacity) {
        this(capacity, null);
    }

    public OperatorOnBackpressureBuffer(long capacity, Action0 onOverflow) {
        if (capacity <= 0) {
            throw new IllegalArgumentException(""Buffer capacity must be > 0"");
        }
        this.capacity = capacity;
        this.onOverflow = onOverflow;
    }

    @Override
    public Subscriber<? super T> call(final Subscriber<? super T> child) {
        // TODO get a different queue implementation
        final ConcurrentLinkedQueue<Object> queue = new ConcurrentLinkedQueue<Object>();
        final AtomicLong capacity = (this.capacity == null) ? null : new AtomicLong(this.capacity);
        final AtomicLong wip = new AtomicLong();
        final AtomicLong requested = new AtomicLong();

        child.setProducer(new Producer() {

            @Override
            public void request(long n) {
                if (requested.getAndAdd(n) == 0) {
                    pollQueue(wip, requested, capacity, queue, child);
                }
            }

        });
        // don't pass through subscriber as we are async and doing queue draining
        // a parent being unsubscribed should not affect the children
        Subscriber<T> parent = new Subscriber<T>() {

            private AtomicBoolean saturated = new AtomicBoolean(false);

            @Override
            public void onStart() {
                request(Long.MAX_VALUE);
            }

            @Override
            public void onCompleted() {
                queue.offer(on.completed());
                pollQueue(wip, requested, capacity, queue, child);
            }

            @Override
            public void onError(Throwable e) {
                queue.offer(on.error(e));
                pollQueue(wip, requested, capacity, queue, child);
            }

            @Override
            public void onNext(T t) {
                if (!ensureCapacity()) {
                    return;
                }
                queue.offer(on.next(t));
                pollQueue(wip, requested, capacity, queue, child);
            }

            private boolean ensureCapacity() {
                if (capacity == null) {
                    return true;
                }

                long currCapacity;
                do {
                    currCapacity = capacity.get();
                    if (currCapacity <= 0) {
                        if (saturated.compareAndSet(false, true)) {
                            // ensure single completion contract
                            child.onError(new MissingBackpressureException(""Overflowed buffer of "" + OperatorOnBackpressureBuffer.this.capacity));
                            unsubscribe();
                            if (onOverflow != null) {
                                onOverflow.call();
                            }
                        }
                        return false;
                    }
                // ensure no other thread stole our slot, or retry
                } while (!capacity.compareAndSet(currCapacity, currCapacity - 1));
                return true;
            }
        };
        
        // if child unsubscribes it should unsubscribe the parent, but not the other way around
        child.add(parent);
        
        return parent;
    }

    private void pollQueue(AtomicLong wip, AtomicLong requested, AtomicLong capacity, Queue<Object> queue, Subscriber<? super T> child) {
        // TODO can we do this without putting everything in the queue first so we can fast-path the case when we don't need to queue?
        if (requested.get() > 0) {
            // only one draining at a time
            try {
                /*
                 * This needs to protect against concurrent execution because `request` and `on*` events can come concurrently.
                 */
                if (wip.getAndIncrement() == 0) {
                    while (true) {
                        if (requested.getAndDecrement() != 0) {
                            Object o = queue.poll();
                            if (o == null) {
                                // nothing in queue
                                requested.incrementAndGet();
                                return;
                            }
                            if (capacity != null) { // it's bounded
                                capacity.incrementAndGet();
                            }
                            on.accept(child, o);
                        } else {
                            // we hit the end ... so increment back to 0 again
                            requested.incrementAndGet();
                            return;
                        }
                    }
                }

            } finally {
                wip.decrementAndGet();
            }
        }
    }
}
","    private void pollQueue(AtomicLong wip, AtomicLong requested, Queue<Object> queue, Subscriber<? super T> child)","    private void pollQueue(AtomicLong wip, AtomicLong requested, AtomicLong capacity, Queue<Object> queue, Subscriber<? super T> child)"
1d15fea659d5f84bd666b164f3bf6ebcbb91327d,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.internal.operators;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable.Operator;
import rx.Producer;
import rx.Subscriber;
import rx.exceptions.MissingBackpressureException;
import rx.functions.Action0;

public class OperatorOnBackpressureBuffer<T> implements Operator<T, T> {

    private final NotificationLite<T> on = NotificationLite.instance();

    private final Long capacity;
    private final Action0 onOverflow;

    public OperatorOnBackpressureBuffer() {
        this.capacity = null;
        this.onOverflow = null;
    }

    public OperatorOnBackpressureBuffer(long capacity) {
        this(capacity, null);
    }

    public OperatorOnBackpressureBuffer(long capacity, Action0 onOverflow) {
        if (capacity <= 0) {
            throw new IllegalArgumentException(""Buffer capacity must be > 0"");
        }
        this.capacity = capacity;
        this.onOverflow = onOverflow;
    }

    @Override
    public Subscriber<? super T> call(final Subscriber<? super T> child) {
        // TODO get a different queue implementation
        final ConcurrentLinkedQueue<Object> queue = new ConcurrentLinkedQueue<Object>();
        final AtomicLong capacity = (this.capacity == null) ? null : new AtomicLong(this.capacity);
        final AtomicLong wip = new AtomicLong();
        final AtomicLong requested = new AtomicLong();

        child.setProducer(new Producer() {

            @Override
            public void request(long n) {
                if (requested.getAndAdd(n) == 0) {
                    pollQueue(wip, requested, capacity, queue, child);
                }
            }

        });
        // don't pass through subscriber as we are async and doing queue draining
        // a parent being unsubscribed should not affect the children
        Subscriber<T> parent = new Subscriber<T>() {

            private AtomicBoolean saturated = new AtomicBoolean(false);

            @Override
            public void onStart() {
                request(Long.MAX_VALUE);
            }

            @Override
            public void onCompleted() {
                if (!saturated.get()) {
                    queue.offer(on.completed());
                    pollQueue(wip, requested, capacity, queue, child);
                }
            }

            @Override
            public void onError(Throwable e) {
                if (!saturated.get()) {
                    queue.offer(on.error(e));
                    pollQueue(wip, requested, capacity, queue, child);
                }
            }

            @Override
            public void onNext(T t) {
                if (!assertCapacity()) {
                    return;
                }
                queue.offer(on.next(t));
                pollQueue(wip, requested, capacity, queue, child);
            }

            private boolean assertCapacity() {
                if (capacity == null) {
                    return true;
                }

                long currCapacity;
                do {
                    currCapacity = capacity.get();
                    if (currCapacity <= 0) {
                        if (saturated.compareAndSet(false, true)) {
                            unsubscribe();
                            child.onError(new MissingBackpressureException(
                                ""Overflowed buffer of ""
                                + OperatorOnBackpressureBuffer.this.capacity));
                            if (onOverflow != null) {
                                onOverflow.call();
                            }
                        }
                        return false;
                    }
                // ensure no other thread stole our slot, or retry
                } while (!capacity.compareAndSet(currCapacity, currCapacity - 1));
                return true;
            }
        };
        
        // if child unsubscribes it should unsubscribe the parent, but not the other way around
        child.add(parent);
        
        return parent;
    }

    private void pollQueue(AtomicLong wip, AtomicLong requested, AtomicLong capacity, Queue<Object> queue, Subscriber<? super T> child) {
        // TODO can we do this without putting everything in the queue first so we can fast-path the case when we don't need to queue?
        if (requested.get() > 0) {
            // only one draining at a time
            try {
                /*
                 * This needs to protect against concurrent execution because `request` and `on*` events can come concurrently.
                 */
                if (wip.getAndIncrement() == 0) {
                    while (true) {
                        if (requested.getAndDecrement() != 0) {
                            Object o = queue.poll();
                            if (o == null) {
                                // nothing in queue
                                requested.incrementAndGet();
                                return;
                            }
                            if (capacity != null) { // it's bounded
                                capacity.incrementAndGet();
                            }
                            on.accept(child, o);
                        } else {
                            // we hit the end ... so increment back to 0 again
                            requested.incrementAndGet();
                            return;
                        }
                    }
                }

            } finally {
                wip.decrementAndGet();
            }
        }
    }
}
","    private void pollQueue(AtomicLong wip, AtomicLong requested, Queue<Object> queue, Subscriber<? super T> child)","    private void pollQueue(AtomicLong wip, AtomicLong requested, AtomicLong capacity, Queue<Object> queue, Subscriber<? super T> child)"
d1908c5156a18c172583a55d9fbe44d3fb9619e8,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.internal.operators;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

import rx.Observable.Operator;
import rx.Producer;
import rx.Subscriber;
import rx.exceptions.MissingBackpressureException;
import rx.functions.Action0;

public class OperatorOnBackpressureBuffer<T> implements Operator<T, T> {

    private final NotificationLite<T> on = NotificationLite.instance();

    private final Long capacity;
    private final Action0 onOverflow;

    public OperatorOnBackpressureBuffer() {
        this.capacity = null;
        this.onOverflow = null;
    }

    public OperatorOnBackpressureBuffer(long capacity) {
        this(capacity, null);
    }

    public OperatorOnBackpressureBuffer(long capacity, Action0 onOverflow) {
        if (capacity <= 0) {
            throw new IllegalArgumentException(""Buffer capacity must be > 0"");
        }
        this.capacity = capacity;
        this.onOverflow = onOverflow;
    }

    @Override
    public Subscriber<? super T> call(final Subscriber<? super T> child) {
        // TODO get a different queue implementation
        final ConcurrentLinkedQueue<Object> queue = new ConcurrentLinkedQueue<Object>();
        final AtomicLong capacity = (this.capacity == null) ? null : new AtomicLong(this.capacity);
        final AtomicLong wip = new AtomicLong();
        final AtomicLong requested = new AtomicLong();

        child.setProducer(new Producer() {

            @Override
            public void request(long n) {
                if (requested.getAndAdd(n) == 0) {
                    pollQueue(wip, requested, capacity, queue, child);
                }
            }

        });
        // don't pass through subscriber as we are async and doing queue draining
        // a parent being unsubscribed should not affect the children
        Subscriber<T> parent = new Subscriber<T>() {

            private AtomicBoolean saturated = new AtomicBoolean(false);

            @Override
            public void onStart() {
                request(Long.MAX_VALUE);
            }

            @Override
            public void onCompleted() {
                if (!saturated.get()) {
                    queue.offer(on.completed());
                    pollQueue(wip, requested, capacity, queue, child);
                }
            }

            @Override
            public void onError(Throwable e) {
                if (!saturated.get()) {
                    queue.offer(on.error(e));
                    pollQueue(wip, requested, capacity, queue, child);
                }
            }

            @Override
            public void onNext(T t) {
                if (!assertCapacity()) {
                    return;
                }
                queue.offer(on.next(t));
                pollQueue(wip, requested, capacity, queue, child);
            }

            private boolean assertCapacity() {
                if (capacity == null) {
                    return true;
                }

                long currCapacity;
                do {
                    currCapacity = capacity.get();
                    if (currCapacity <= 0) {
                        if (saturated.compareAndSet(false, true)) {
                            unsubscribe();
                            child.onError(new MissingBackpressureException(
                                ""Overflowed buffer of ""
                                + OperatorOnBackpressureBuffer.this.capacity));
                            if (onOverflow != null) {
                                onOverflow.call();
                            }
                        }
                        return false;
                    }
                // ensure no other thread stole our slot, or retry
                } while (!capacity.compareAndSet(currCapacity, currCapacity - 1));
                return true;
            }
        };
        
        // if child unsubscribes it should unsubscribe the parent, but not the other way around
        child.add(parent);
        
        return parent;
    }

    private void pollQueue(AtomicLong wip, AtomicLong requested, AtomicLong capacity, Queue<Object> queue, Subscriber<? super T> child) {
        // TODO can we do this without putting everything in the queue first so we can fast-path the case when we don't need to queue?
        if (requested.get() > 0) {
            // only one draining at a time
            try {
                /*
                 * This needs to protect against concurrent execution because `request` and `on*` events can come concurrently.
                 */
                if (wip.getAndIncrement() == 0) {
                    while (true) {
                        if (requested.getAndDecrement() != 0) {
                            Object o = queue.poll();
                            if (o == null) {
                                // nothing in queue
                                requested.incrementAndGet();
                                return;
                            }
                            if (capacity != null) { // it's bounded
                                capacity.incrementAndGet();
                            }
                            on.accept(child, o);
                        } else {
                            // we hit the end ... so increment back to 0 again
                            requested.incrementAndGet();
                            return;
                        }
                    }
                }

            } finally {
                wip.decrementAndGet();
            }
        }
    }
}
","    private void pollQueue(AtomicLong wip, AtomicLong requested, Queue<Object> queue, Subscriber<? super T> child)","    private void pollQueue(AtomicLong wip, AtomicLong requested, AtomicLong capacity, Queue<Object> queue, Subscriber<? super T> child)"
7163288b11a67ddf6a155b7af4916d6b206a688e,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rx.subscriptions;

import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;

import rx.Subscription;

/**
 * Benchmark typical composite subscription single-threaded behavior.
 * <p>
 * gradlew benchmarks ""-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*CompositeSubscriptionPerf.*""
 * <p>
 * gradlew benchmarks ""-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*CompositeSubscriptionPerf.*""
 */
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
public class CompositeSubscriptionPerf {
    @State(Scope.Thread)
    public static class TheState {
        @Param({ ""1"", ""1000"", ""100000"" })
        public int loop;
        @Param({ ""1"", ""5"", ""10"", ""100"" })
        public int count;
        
        public final CompositeSubscription csub = new CompositeSubscription();
        
        public Subscription[] values;
        @Setup
        public void setup() {
            values = new Subscription[count];
            for (int i = 0; i < count; i++) {
                values[i] = new Subscription() {
                    @Override
                    public boolean isUnsubscribed() {
                        return false;
                    }
                    @Override
                    public void unsubscribe() {
                        
                    }
                };
            }
        }
    }
    @Benchmark
    public void addRemove(TheState state) {
        CompositeSubscription csub = state.csub;
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.add(values[j]);
            }
            for (int j = values.length - 1; j >= 0; j--) {
                csub.remove(values[j]);
            }
        }
    }
    @Benchmark
    public void addRemoveLocal(TheState state, Blackhole bh) {
        CompositeSubscription csub = new CompositeSubscription();
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.add(values[j]);
            }
            for (int j = values.length - 1; j >= 0; j--) {
                csub.remove(values[j]);
            }
        }
        
        bh.consume(csub);
    }
    @Benchmark
    public void addClear(TheState state) {
        CompositeSubscription csub = state.csub;
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.add(values[j]);
            }
            csub.clear();
        }
    }
    @Benchmark
    public void addClearLocal(TheState state, Blackhole bh) {
        CompositeSubscription csub = new CompositeSubscription();
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.add(values[j]);
            }
            csub.clear();
        }
        bh.consume(csub);
    }
}
",    public void addRemoveLocal(TheState state),"    public void addRemoveLocal(TheState state, Blackhole bh)"
7163288b11a67ddf6a155b7af4916d6b206a688e,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rx.subscriptions;

import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;

import rx.Subscription;

/**
 * Benchmark typical composite subscription single-threaded behavior.
 * <p>
 * gradlew benchmarks ""-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*CompositeSubscriptionPerf.*""
 * <p>
 * gradlew benchmarks ""-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*CompositeSubscriptionPerf.*""
 */
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
public class CompositeSubscriptionPerf {
    @State(Scope.Thread)
    public static class TheState {
        @Param({ ""1"", ""1000"", ""100000"" })
        public int loop;
        @Param({ ""1"", ""5"", ""10"", ""100"" })
        public int count;
        
        public final CompositeSubscription csub = new CompositeSubscription();
        
        public Subscription[] values;
        @Setup
        public void setup() {
            values = new Subscription[count];
            for (int i = 0; i < count; i++) {
                values[i] = new Subscription() {
                    @Override
                    public boolean isUnsubscribed() {
                        return false;
                    }
                    @Override
                    public void unsubscribe() {
                        
                    }
                };
            }
        }
    }
    @Benchmark
    public void addRemove(TheState state) {
        CompositeSubscription csub = state.csub;
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.add(values[j]);
            }
            for (int j = values.length - 1; j >= 0; j--) {
                csub.remove(values[j]);
            }
        }
    }
    @Benchmark
    public void addRemoveLocal(TheState state, Blackhole bh) {
        CompositeSubscription csub = new CompositeSubscription();
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.add(values[j]);
            }
            for (int j = values.length - 1; j >= 0; j--) {
                csub.remove(values[j]);
            }
        }
        
        bh.consume(csub);
    }
    @Benchmark
    public void addClear(TheState state) {
        CompositeSubscription csub = state.csub;
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.add(values[j]);
            }
            csub.clear();
        }
    }
    @Benchmark
    public void addClearLocal(TheState state, Blackhole bh) {
        CompositeSubscription csub = new CompositeSubscription();
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.add(values[j]);
            }
            csub.clear();
        }
        bh.consume(csub);
    }
}
",    public void addClearLocal(TheState state),"    public void addClearLocal(TheState state, Blackhole bh)"
7163288b11a67ddf6a155b7af4916d6b206a688e,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rx.subscriptions;

import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;

import rx.Subscription;

/**
 * Benchmark typical multiple-assignment subscription behavior.
 * <p>
 * gradlew benchmarks ""-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*MultipleAssignmentSubscriptionPerf.*""
 * <p>
 * gradlew benchmarks ""-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*MultipleAssignmentSubscriptionPerf.*""
 */
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
public class MultipleAssignmentSubscriptionPerf {
    @State(Scope.Thread)
    public static class TheState {
        @Param({ ""1"", ""1000"", ""100000"" })
        public int loop;
        @Param({ ""1"", ""5"", ""10"", ""100"" })
        public int count;
        
        public final MultipleAssignmentSubscription csub = new MultipleAssignmentSubscription();
        
        public Subscription[] values;
        @Setup
        public void setup() {
            values = new Subscription[count];
            for (int i = 0; i < count; i++) {
                values[i] = new Subscription() {
                    @Override
                    public boolean isUnsubscribed() {
                        return false;
                    }
                    @Override
                    public void unsubscribe() {
                        
                    }
                };
            }
        }
    }
    @Benchmark
    public void add(TheState state) {
        MultipleAssignmentSubscription csub = state.csub;
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.set(values[j]);
            }
        }
    }
    @Benchmark
    public void addLocal(TheState state, Blackhole bh) {
        MultipleAssignmentSubscription csub = new MultipleAssignmentSubscription();
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.set(values[j]);
            }
        }
        bh.consume(csub);
    }
}
",    public void addLocal(TheState state),"    public void addLocal(TheState state, Blackhole bh)"
7163288b11a67ddf6a155b7af4916d6b206a688e,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rx.subscriptions;

import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;

import rx.Subscription;

/**
 * Benchmark typical serial subscription behavior.
 * <p>
 * gradlew benchmarks ""-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*SerialSubscriptionPerf.*""
 * <p>
 * gradlew benchmarks ""-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*SerialSubscriptionPerf.*""
 */
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
public class SerialSubscriptionPerf {
    @State(Scope.Thread)
    public static class TheState {
        @Param({ ""1"", ""1000"", ""100000"" })
        public int loop;
        @Param({ ""1"", ""5"", ""10"", ""100"" })
        public int count;
        
        public final SerialSubscription csub = new SerialSubscription();
        
        public Subscription[] values;
        @Setup
        public void setup() {
            values = new Subscription[count];
            for (int i = 0; i < count; i++) {
                values[i] = new Subscription() {
                    @Override
                    public boolean isUnsubscribed() {
                        return false;
                    }
                    @Override
                    public void unsubscribe() {
                        
                    }
                };
            }
        }
    }
    @Benchmark
    public void add(TheState state) {
        SerialSubscription csub = state.csub;
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.set(values[j]);
            }
        }
    }
    @Benchmark
    public void addLocal(TheState state, Blackhole bh) {
        SerialSubscription csub = new SerialSubscription();
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.set(values[j]);
            }
        }
        bh.consume(csub);
    }
}
",    public void addLocal(TheState state),"    public void addLocal(TheState state, Blackhole bh)"
7163288b11a67ddf6a155b7af4916d6b206a688e,"/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rx.subscriptions;

import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;

import rx.Subscription;
import rx.internal.util.SubscriptionList;

/**
 * Benchmark typical subscription list behavior.
 * <p>
 * gradlew benchmarks ""-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*SubscriptionListPerf.*""
 * <p>
 * gradlew benchmarks ""-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*SubscriptionListPerf.*""
 */
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
public class SubscriptionListPerf {
    @State(Scope.Thread)
    public static class TheState {
        @Param({ ""1"", ""1000"", ""100000"" })
        public int loop;
        @Param({ ""1"", ""5"", ""10"", ""100"" })
        public int count;
        
        public final SubscriptionList csub = new SubscriptionList();
        
        public Subscription[] values;
        @Setup
        public void setup() {
            values = new Subscription[count];
            for (int i = 0; i < count; i++) {
                values[i] = new Subscription() {
                    @Override
                    public boolean isUnsubscribed() {
                        return false;
                    }
                    @Override
                    public void unsubscribe() {
                        
                    }
                };
            }
        }
    }
    @Benchmark
    public void addClear(TheState state) {
        SubscriptionList csub = state.csub;
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.add(values[j]);
            }
            csub.clear();
        }
    }
    @Benchmark
    public void addClearLocal(TheState state, Blackhole bh) {
        SubscriptionList csub = new SubscriptionList();
        Subscription[] values = state.values;
        
        for (int i = state.loop; i > 0; i--) {
            for (int j = values.length - 1; j >= 0; j--) {
                csub.add(values[j]);
            }
            csub.clear();
        }
        bh.consume(csub);
    }
}
",    public void addClearLocal(TheState state),"    public void addClearLocal(TheState state, Blackhole bh)"
9099f90e2281e388385663c37eeaf4b5917987ae,"/**
 * Copyright 2016 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package io.reactivex;


import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicReference;

import org.reactivestreams.*;

import io.reactivex.annotations.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.flowables.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.functions.Objects;
import io.reactivex.internal.fuseable.*;
import io.reactivex.internal.operators.flowable.*;
import io.reactivex.internal.operators.flowable.FlowableConcatMap.ErrorMode;
import io.reactivex.internal.subscribers.flowable.*;
import io.reactivex.internal.subscriptions.EmptySubscription;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.*;
import io.reactivex.subscribers.*;

public abstract class Flowable<T> implements Publisher<T> {
    private static final Object OBJECT = new Object(); 
    /** The default buffer size. */
    static final int BUFFER_SIZE;
    static {
        BUFFER_SIZE = Math.max(16, Integer.getInteger(""rx2.buffer-size"", 128));
    }
    
    /**
     * Interface to map/wrap a downstream subscriber to an upstream subscriber.
     *
     * @param <Downstream> the value type of the downstream
     * @param <Upstream> the value type of the upstream
     */
    public interface Operator<Downstream, Upstream> extends Function<Subscriber<? super Downstream>, Subscriber<? super Upstream>> {

    }
    
    /**
     * Interface to compose observables.
     *
     * @param <T> the upstream value type
     * @param <R> the downstream value type
     */
    public interface Transformer<T, R> extends Function<Flowable<T>, Publisher<? extends R>> {
        
    }

    /** A never observable instance as there is no need to instantiate this more than once. */
    static final Flowable<Object> NEVER = new Flowable<Object>() { // FIXME factor out
        @Override
        public void subscribeActual(Subscriber<? super Object> s) {
            s.onSubscribe(EmptySubscription.INSTANCE);
        }
    };

    public static <T> Flowable<T> amb(Iterable<? extends Publisher<? extends T>> sources) {
        Objects.requireNonNull(sources, ""sources is null"");
        return new FlowableAmb<T>(null, sources);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> amb(Publisher<? extends T>... sources) {
        Objects.requireNonNull(sources, ""sources is null"");
        int len = sources.length;
        if (len == 0) {
            return empty();
        } else
        if (len == 1) {
            return fromPublisher(sources[0]);
        }
        return new FlowableAmb<T>(sources, null);
    }

    public static int bufferSize() {
        return BUFFER_SIZE;
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<Object[], ? extends R> combiner) {
        return combineLatest(sources, combiner, bufferSize());
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static <T, R> Flowable<R> combineLatest(Function<Object[], ? extends R> combiner, Publisher<? extends T>... sources) {
        return combineLatest(sources, combiner, bufferSize());
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<Object[], ? extends R> combiner, int bufferSize) {
        Objects.requireNonNull(sources, ""sources is null"");
        Objects.requireNonNull(combiner, ""combiner is null"");
        validateBufferSize(bufferSize, ""bufferSize"");
        if (sources.length == 0) {
            return empty();
        }
        return new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false);
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, Function<Object[], ? extends R> combiner) {
        return combineLatest(sources, combiner, bufferSize());
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, Function<Object[], ? extends R> combiner, int bufferSize) {
        Objects.requireNonNull(sources, ""sources is null"");
        Objects.requireNonNull(combiner, ""combiner is null"");
        validateBufferSize(bufferSize, ""bufferSize"");
        return new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false);
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources, Function<Object[], ? extends R> combiner) {
        return combineLatestDelayError(sources, combiner, bufferSize());
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static <T, R> Flowable<R> combineLatestDelayError(Function<Object[], ? extends R> combiner, Publisher<? extends T>... sources) {
        return combineLatestDelayError(sources, combiner, bufferSize());
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources, Function<Object[], ? extends R> combiner, int bufferSize) {
        Objects.requireNonNull(sources, ""sources is null"");
        Objects.requireNonNull(combiner, ""combiner is null"");
        validateBufferSize(bufferSize, ""bufferSize"");
        if (sources.length == 0) {
            return empty();
        }
        return new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true);
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources, Function<Object[], ? extends R> combiner) {
        return combineLatestDelayError(sources, combiner, bufferSize());
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources, Function<Object[], ? extends R> combiner, int bufferSize) {
        Objects.requireNonNull(sources, ""sources is null"");
        Objects.requireNonNull(combiner, ""combiner is null"");
        validateBufferSize(bufferSize, ""bufferSize"");
        return new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, R> Flowable<R> combineLatest(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            BiFunction<? super T1, ? super T2, ? extends R> combiner) {
        Function<Object[], R> f = Functions.toFunction(combiner);
        return combineLatest(f, p1, p2);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, R> Flowable<R> combineLatest(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            Publisher<? extends T3> p3, 
            Function3<? super T1, ? super T2, ? super T3, ? extends R> combiner) {
        return combineLatest(Functions.toFunction(combiner), p1, p2, p3);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, R> Flowable<R> combineLatest(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combiner) {
        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, T5, R> Flowable<R> combineLatest(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
            Publisher<? extends T5> p5,
            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combiner) {
        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4, p5);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> combineLatest(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
            Publisher<? extends T5> p5, Publisher<? extends T6> p6,
            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combiner) {
        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4, p5, p6);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> combineLatest(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
            Publisher<? extends T5> p5, Publisher<? extends T6> p6,
            Publisher<? extends T7> p7,
            Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> combiner) {
        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4, p5, p6, p7);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> combineLatest(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
            Publisher<? extends T5> p5, Publisher<? extends T6> p6,
            Publisher<? extends T7> p7, Publisher<? extends T8> p8,
            Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> combiner) {
        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4, p5, p6, p7, p8);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> combineLatest(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
            Publisher<? extends T5> p5, Publisher<? extends T6> p6,
            Publisher<? extends T7> p7, Publisher<? extends T8> p8,
            Publisher<? extends T9> p9,
            Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> combiner) {
        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concat(Iterable<? extends Publisher<? extends T>> sources) {
        Objects.requireNonNull(sources, ""sources is null"");
        return fromIterable(sources).concatMap((Function)Functions.identity());
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concat(Iterable<? extends Publisher<? extends T>> sources, int prefetch) {
        Objects.requireNonNull(sources, ""sources is null"");
        return fromIterable(sources).concatMap((Function)Functions.identity(), prefetch);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {
        return concat(sources, bufferSize());
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {
        return fromPublisher(sources).concatMap((Function)Functions.identity());
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concat(Publisher<? extends T> p1, Publisher<? extends T> p2) {
        return concatArray(p1, p2);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concat(
            Publisher<? extends T> p1, Publisher<? extends T> p2,
            Publisher<? extends T> p3) {
        return concatArray(p1, p2, p3);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concat(
            Publisher<? extends T> p1, Publisher<? extends T> p2,
            Publisher<? extends T> p3, Publisher<? extends T> p4) {
        return concatArray(p1, p2, p3, p4);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concat(
            Publisher<? extends T> p1, Publisher<? extends T> p2, 
            Publisher<? extends T> p3, Publisher<? extends T> p4,
            Publisher<? extends T> p5
    ) {
        return concatArray(p1, p2, p3, p4, p5);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concat(
            Publisher<? extends T> p1, Publisher<? extends T> p2, 
            Publisher<? extends T> p3, Publisher<? extends T> p4,
            Publisher<? extends T> p5, Publisher<? extends T> p6
    ) {
        return concatArray(p1, p2, p3, p4, p5, p6);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concat(
            Publisher<? extends T> p1, Publisher<? extends T> p2,
            Publisher<? extends T> p3, Publisher<? extends T> p4,
            Publisher<? extends T> p5, Publisher<? extends T> p6,
            Publisher<? extends T> p7
    ) {
        return concatArray(p1, p2, p3, p4, p5, p6, p7);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concat(
            Publisher<? extends T> p1, Publisher<? extends T> p2, 
            Publisher<? extends T> p3, Publisher<? extends T> p4,
            Publisher<? extends T> p5, Publisher<? extends T> p6,
            Publisher<? extends T> p7, Publisher<? extends T> p8
    ) {
        return concatArray(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concat(
            Publisher<? extends T> p1, Publisher<? extends T> p2, 
            Publisher<? extends T> p3, Publisher<? extends T> p4,
            Publisher<? extends T> p5, Publisher<? extends T> p6,
            Publisher<? extends T> p7, Publisher<? extends T> p8,
            Publisher<? extends T> p9
    ) {
        return concatArray(p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @Deprecated // prefetch is unnecessary when the sources is synchronously available
    public static <T> Flowable<T> concatArray(int prefetch, Publisher<? extends T>... sources) {
        return concatArray(sources);
    }

    /**
     * Concatenates a variable number of Observable sources.
     * <p>
     * Note: named this way because of overload conflict with concat(NbpObservable&lt;NbpObservable&gt)
     * @param sources the array of sources
     * @param <T> the common base value type
     * @return the new Observable instance
     * @throws NullPointerException if sources is null
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concatArray(Publisher<? extends T>... sources) {
        if (sources.length == 0) {
            return empty();
        } else
        if (sources.length == 1) {
            return fromPublisher(sources[0]);
        }
        return new FlowableConcatArray<T>(sources, false);
    }

    /**
     * Concatenates a variable number of Observable sources and delays errors from any of them
     * till all terminate.
     * @param sources the array of sources
     * @param <T> the common base value type
     * @return the new Flowable instance
     * @throws NullPointerException if sources is null
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concatArrayDelayError(Publisher<? extends T>... sources) {
        if (sources.length == 0) {
            return empty();
        } else
        if (sources.length == 1) {
            return fromPublisher(sources[0]);
        }
        return new FlowableConcatArray<T>(sources, true);
    }

    public static <T> Flowable<T> concatArrayEager(Publisher<? extends T>... sources) {
        return concatArrayEager(bufferSize(), bufferSize(), sources);
    }

    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
    public static <T> Flowable<T> concatArrayEager(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {
        return new FlowableConcatMapEager(new FlowableFromArray(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE);
    }

    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources) {
        return concatEager(sources, bufferSize(), bufferSize());
    }

    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
    public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {
        return new FlowableConcatMapEager(sources, Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE);
    }

    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources) {
        return concatEager(sources, bufferSize(), bufferSize());
    }

    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
    public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {
        return new FlowableConcatMapEager(new FlowableFromIterable(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources) {
        Objects.requireNonNull(sources, ""sources is null"");
        return concatDelayError(sources, bufferSize(), true);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {
        Objects.requireNonNull(sources, ""sources is null"");
        return fromIterable(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources) {
        return concatDelayError(sources, bufferSize(), true);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {
        return fromPublisher(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);
    }

    
    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> create(Publisher<T> onSubscribe) {
        Objects.requireNonNull(onSubscribe, ""onSubscribe is null"");
        if (onSubscribe instanceof Flowable) {
            throw new IllegalArgumentException(""create(Flowable) should be upgraded"");
        }
        return fromPublisher(onSubscribe);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> defer(Supplier<? extends Publisher<? extends T>> supplier) {
        Objects.requireNonNull(supplier, ""supplier is null"");
        return new FlowableDefer<T>(supplier);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> empty() {
        return FlowableEmpty.empty();
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> error(Supplier<? extends Throwable> errorSupplier) {
        Objects.requireNonNull(errorSupplier, ""errorSupplier is null"");
        return new FlowableError<T>(errorSupplier);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> error(final Throwable e) {
        Objects.requireNonNull(e, ""e is null"");
        return error(new Supplier<Throwable>() {
            @Override
            public Throwable get() {
                return e;
            }
        });
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> fromArray(T... values) {
        Objects.requireNonNull(values, ""values is null"");
        if (values.length == 0) {
            return empty();
        } else
            if (values.length == 1) {
                return just(values[0]);
            }
        return new FlowableFromArray<T>(values);
    }
    
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> fromAsync(Consumer<AsyncEmitter<T>> asyncEmitter, AsyncEmitter.BackpressureMode mode) {
        return new FlowableFromAsync<T>(asyncEmitter, mode);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> fromCallable(Callable<? extends T> supplier) {
        Objects.requireNonNull(supplier, ""supplier is null"");
        return new FlowableFromCallable<T>(supplier);
    }

    /*
     * It doesn't add cancellation support by default like 1.x
     * if necessary, one can use composition to achieve it:
     * futureObservable.doOnCancel(() -> future.cancel(true));
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> fromFuture(Future<? extends T> future) {
        Objects.requireNonNull(future, ""future is null"");
        Flowable<T> o = new FlowableFromFuture<T>(future, 0L, null);
        
        return o;
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {
        Objects.requireNonNull(future, ""future is null"");
        Objects.requireNonNull(unit, ""unit is null"");
        return new FlowableFromFuture<T>(future, timeout, unit);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static <T> Flowable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit, Scheduler scheduler) {
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        Flowable<T> o = fromFuture(future, timeout, unit); 
        return o.subscribeOn(scheduler);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.IO)
    public static <T> Flowable<T> fromFuture(Future<? extends T> future, Scheduler scheduler) {
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        Flowable<T> o = fromFuture(future);
        return o.subscribeOn(Schedulers.io());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> fromIterable(Iterable<? extends T> source) {
        Objects.requireNonNull(source, ""source is null"");
        return new FlowableFromIterable<T>(source);
    }
    
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(""unchecked"")
    public static <T> Flowable<T> fromPublisher(final Publisher<? extends T> publisher) {
        if (publisher instanceof Flowable) {
            return (Flowable<T>)publisher;
        }
        Objects.requireNonNull(publisher, ""publisher is null"");

        return new FlowableWrapper<T>(publisher);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> generate(final Consumer<Subscriber<T>> generator) {
        Objects.requireNonNull(generator, ""generator is null"");
        return generate(Functions.nullSupplier(), 
        new BiFunction<Object, Subscriber<T>, Object>() {
            @Override
            public Object apply(Object s, Subscriber<T> o) {
                generator.accept(o);
                return s;
            }
        }, Functions.emptyConsumer());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T, S> Flowable<T> generate(Supplier<S> initialState, final BiConsumer<S, Subscriber<T>> generator) {
        Objects.requireNonNull(generator, ""generator is null"");
        return generate(initialState, new BiFunction<S, Subscriber<T>, S>() {
            @Override
            public S apply(S s, Subscriber<T> o) {
                generator.accept(s, o);
                return s;
            }
        }, Functions.emptyConsumer());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T, S> Flowable<T> generate(Supplier<S> initialState, final BiConsumer<S, Subscriber<T>> generator, Consumer<? super S> disposeState) {
        Objects.requireNonNull(generator, ""generator is null"");
        return generate(initialState, new BiFunction<S, Subscriber<T>, S>() {
            @Override
            public S apply(S s, Subscriber<T> o) {
                generator.accept(s, o);
                return s;
            }
        }, disposeState);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T, S> Flowable<T> generate(Supplier<S> initialState, BiFunction<S, Subscriber<T>, S> generator) {
        return generate(initialState, generator, Functions.emptyConsumer());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T, S> Flowable<T> generate(Supplier<S> initialState, BiFunction<S, Subscriber<T>, S> generator, Consumer<? super S> disposeState) {
        Objects.requireNonNull(initialState, ""initialState is null"");
        Objects.requireNonNull(generator, ""generator is null"");
        Objects.requireNonNull(disposeState, ""disposeState is null"");
        return new FlowableGenerate<T, S>(initialState, generator, disposeState);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit) {
        return interval(initialDelay, period, unit, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
        if (initialDelay < 0) {
            initialDelay = 0L;
        }
        if (period < 0) {
            period = 0L;
        }
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");

        return new FlowableInterval(initialDelay, period, unit, scheduler);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Flowable<Long> interval(long period, TimeUnit unit) {
        return interval(period, period, unit, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Flowable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {
        return interval(period, period, unit, scheduler);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {
        return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {

        long end = start + (count - 1);
        if (end < 0) {
            throw new IllegalArgumentException(""Overflow! start + count is bigger than Long.MAX_VALUE"");
        }

        if (initialDelay < 0) {
            initialDelay = 0L;
        }
        if (period < 0) {
            period = 0L;
        }
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");

        return new FlowableIntervalRange(start, end, initialDelay, period, unit, scheduler);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> just(T value) {
        Objects.requireNonNull(value, ""value is null"");
        return new FlowableJust<T>(value);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> just(T v1, T v2) {
        Objects.requireNonNull(v1, ""The first value is null"");
        Objects.requireNonNull(v2, ""The second value is null"");
        
        return fromArray(v1, v2);
    }

    
    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> just(T v1, T v2, T v3) {
        Objects.requireNonNull(v1, ""The first value is null"");
        Objects.requireNonNull(v2, ""The second value is null"");
        Objects.requireNonNull(v3, ""The third value is null"");
        
        return fromArray(v1, v2, v3);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4) {
        Objects.requireNonNull(v1, ""The first value is null"");
        Objects.requireNonNull(v2, ""The second value is null"");
        Objects.requireNonNull(v3, ""The third value is null"");
        Objects.requireNonNull(v4, ""The fourth value is null"");
        
        return fromArray(v1, v2, v3, v4);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5) {
        Objects.requireNonNull(v1, ""The first value is null"");
        Objects.requireNonNull(v2, ""The second value is null"");
        Objects.requireNonNull(v3, ""The third value is null"");
        Objects.requireNonNull(v4, ""The fourth value is null"");
        Objects.requireNonNull(v5, ""The fifth value is null"");
        
        return fromArray(v1, v2, v3, v4, v5);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6) {
        Objects.requireNonNull(v1, ""The first value is null"");
        Objects.requireNonNull(v2, ""The second value is null"");
        Objects.requireNonNull(v3, ""The third value is null"");
        Objects.requireNonNull(v4, ""The fourth value is null"");
        Objects.requireNonNull(v5, ""The fifth value is null"");
        Objects.requireNonNull(v6, ""The sixth value is null"");
        
        return fromArray(v1, v2, v3, v4, v5, v6);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7) {
        Objects.requireNonNull(v1, ""The first value is null"");
        Objects.requireNonNull(v2, ""The second value is null"");
        Objects.requireNonNull(v3, ""The third value is null"");
        Objects.requireNonNull(v4, ""The fourth value is null"");
        Objects.requireNonNull(v5, ""The fifth value is null"");
        Objects.requireNonNull(v6, ""The sixth value is null"");
        Objects.requireNonNull(v7, ""The seventh value is null"");
        
        return fromArray(v1, v2, v3, v4, v5, v6, v7);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8) {
        Objects.requireNonNull(v1, ""The first value is null"");
        Objects.requireNonNull(v2, ""The second value is null"");
        Objects.requireNonNull(v3, ""The third value is null"");
        Objects.requireNonNull(v4, ""The fourth value is null"");
        Objects.requireNonNull(v5, ""The fifth value is null"");
        Objects.requireNonNull(v6, ""The sixth value is null"");
        Objects.requireNonNull(v7, ""The seventh value is null"");
        Objects.requireNonNull(v8, ""The eigth value is null"");
        
        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9) {
        Objects.requireNonNull(v1, ""The first value is null"");
        Objects.requireNonNull(v2, ""The second value is null"");
        Objects.requireNonNull(v3, ""The third value is null"");
        Objects.requireNonNull(v4, ""The fourth value is null"");
        Objects.requireNonNull(v5, ""The fifth value is null"");
        Objects.requireNonNull(v6, ""The sixth value is null"");
        Objects.requireNonNull(v7, ""The seventh value is null"");
        Objects.requireNonNull(v8, ""The eigth value is null"");
        Objects.requireNonNull(v9, ""The ninth is null"");
        
        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9, T v10) {
        Objects.requireNonNull(v1, ""The first value is null"");
        Objects.requireNonNull(v2, ""The second value is null"");
        Objects.requireNonNull(v3, ""The third value is null"");
        Objects.requireNonNull(v4, ""The fourth value is null"");
        Objects.requireNonNull(v5, ""The fifth value is null"");
        Objects.requireNonNull(v6, ""The sixth value is null"");
        Objects.requireNonNull(v7, ""The seventh value is null"");
        Objects.requireNonNull(v8, ""The eigth value is null"");
        Objects.requireNonNull(v9, ""The ninth is null"");
        Objects.requireNonNull(v10, ""The tenth is null"");
        
        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(int maxConcurrency, int bufferSize, Iterable<? extends Publisher<? extends T>> sources) {
        return fromIterable(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {
        return fromArray(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(int maxConcurrency, Publisher<? extends T>... sources) {
        return fromArray(sources).flatMap((Function)Functions.identity(), maxConcurrency);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources) {
        return fromIterable(sources).flatMap((Function)Functions.identity());
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {
        return fromIterable(sources).flatMap((Function)Functions.identity(), maxConcurrency);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(Publisher<? extends Publisher<? extends T>> sources) {
        return merge(sources, bufferSize());
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {
        return fromPublisher(sources).flatMap((Function)Functions.identity(), maxConcurrency);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(Publisher<? extends T>... sources) {
        return fromArray(sources).flatMap((Function)Functions.identity(), sources.length);
    }
    
    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(Publisher<? extends T> p1, Publisher<? extends T> p2) {
        Objects.requireNonNull(p1, ""p1 is null"");
        Objects.requireNonNull(p2, ""p2 is null"");
        return fromArray(p1, p2).flatMap((Function)Functions.identity(), false, 2);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(Publisher<? extends T> p1, Publisher<? extends T> p2, Publisher<? extends T> p3) {
        Objects.requireNonNull(p1, ""p1 is null"");
        Objects.requireNonNull(p2, ""p2 is null"");
        Objects.requireNonNull(p3, ""p3 is null"");
        return fromArray(p1, p2, p3).flatMap((Function)Functions.identity(), false, 3);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> merge(
            Publisher<? extends T> p1, Publisher<? extends T> p2, 
            Publisher<? extends T> p3, Publisher<? extends T> p4) {
        Objects.requireNonNull(p1, ""p1 is null"");
        Objects.requireNonNull(p2, ""p2 is null"");
        Objects.requireNonNull(p3, ""p3 is null"");
        Objects.requireNonNull(p4, ""p4 is null"");
        return fromArray(p1, p2, p3, p4).flatMap((Function)Functions.identity(), false, 4);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(boolean delayErrors, Iterable<? extends Publisher<? extends T>> sources) {
        return fromIterable(sources).flatMap((Function)Functions.identity(), true);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(int maxConcurrency, int bufferSize, Iterable<? extends Publisher<? extends T>> sources) {
        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {
        return fromArray(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(int maxConcurrency, Iterable<? extends Publisher<? extends T>> sources) {
        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(int maxConcurrency, Publisher<? extends T>... sources) {
        return fromArray(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources) {
        return mergeDelayError(sources, bufferSize());
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {
        return fromPublisher(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T>... sources) {
        return fromArray(sources).flatMap((Function)Functions.identity(), true, sources.length);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> p1, Publisher<? extends T> p2) {
        Objects.requireNonNull(p1, ""p1 is null"");
        Objects.requireNonNull(p2, ""p2 is null"");
        return fromArray(p1, p2).flatMap((Function)Functions.identity(), true, 2);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> p1, Publisher<? extends T> p2, Publisher<? extends T> p3) {
        Objects.requireNonNull(p1, ""p1 is null"");
        Objects.requireNonNull(p2, ""p2 is null"");
        Objects.requireNonNull(p3, ""p3 is null"");
        return fromArray(p1, p2, p3).flatMap((Function)Functions.identity(), true, 3);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> mergeDelayError(
            Publisher<? extends T> p1, Publisher<? extends T> p2, 
            Publisher<? extends T> p3, Publisher<? extends T> p4) {
        Objects.requireNonNull(p1, ""p1 is null"");
        Objects.requireNonNull(p2, ""p2 is null"");
        Objects.requireNonNull(p3, ""p3 is null"");
        Objects.requireNonNull(p4, ""p4 is null"");
        return fromArray(p1, p2, p3, p4).flatMap((Function)Functions.identity(), true, 4);
    }

    
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(""unchecked"")
    public static <T> Flowable<T> never() {
        return (Flowable<T>)NEVER;
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Flowable<Integer> range(int start, int count) {
        if (count < 0) {
            throw new IllegalArgumentException(""count >= 0 required but it was "" + count);
        } else
        if (count == 0) {
            return empty();
        } else
        if (count == 1) {
            return just(start);
        } else
        if ((long)start + (count - 1) > Integer.MAX_VALUE) {
            throw new IllegalArgumentException(""Integer overflow"");
        }
        return new FlowableRange(start, count);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2) {
        return sequenceEqual(p1, p2, Objects.equalsPredicate(), bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, BiPredicate<? super T, ? super T> isEqual) {
        return sequenceEqual(p1, p2, isEqual, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, BiPredicate<? super T, ? super T> isEqual, int bufferSize) {
        Objects.requireNonNull(p1, ""p1 is null"");
        Objects.requireNonNull(p2, ""p2 is null"");
        Objects.requireNonNull(isEqual, ""isEqual is null"");
        validateBufferSize(bufferSize, ""bufferSize"");
        return new FlowableSequenceEqual<T>(p1, p2, isEqual, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, int bufferSize) {
        return sequenceEqual(p1, p2, Objects.equalsPredicate(), bufferSize);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> switchOnNext(int bufferSize, Publisher<? extends Publisher<? extends T>> sources) {
        return fromPublisher(sources).switchMap((Function)Functions.identity(), bufferSize);
    }

    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources) {
        return fromPublisher(sources).switchMap((Function)Functions.identity());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Flowable<Long> timer(long delay, TimeUnit unit) {
        return timer(delay, unit, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Flowable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {
        if (delay < 0) {
            delay = 0L;
        }
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");

        return new FlowableTimer(delay, unit, scheduler);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T, D> Flowable<T> using(Supplier<? extends D> resourceSupplier, Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> disposer) {
        return using(resourceSupplier, sourceSupplier, disposer, true);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T, D> Flowable<T> using(Supplier<? extends D> resourceSupplier, Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> disposer, boolean eager) {
        Objects.requireNonNull(resourceSupplier, ""resourceSupplier is null"");
        Objects.requireNonNull(sourceSupplier, ""sourceSupplier is null"");
        Objects.requireNonNull(disposer, ""disposer is null"");
        return new FlowableUsing<T, D>(resourceSupplier, sourceSupplier, disposer, eager);
    }

    private static void validateBufferSize(int bufferSize, String paramName) {
        if (bufferSize <= 0) {
            throw new IllegalArgumentException(paramName + "" > 0 required but it was "" + bufferSize);
        }
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T, R> Flowable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {
        Objects.requireNonNull(zipper, ""zipper is null"");
        Objects.requireNonNull(sources, ""sources is null"");
        return new FlowableZip<T, R>(null, sources, zipper, bufferSize(), false);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T, R> Flowable<R> zip(Publisher<? extends Publisher<? extends T>> sources, final Function<? super Object[], ? extends R> zipper) {
        Objects.requireNonNull(zipper, ""zipper is null"");
        return fromPublisher(sources).toList().flatMap(new Function<List<Publisher<? extends T>>, Publisher<? extends R>>() {
            @Override
            public Publisher<? extends R> apply(List<Publisher<? extends T>> list) {
                return zipIterable(zipper, false, bufferSize(), list);
            }
        });
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, R> Flowable<R> zip(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            BiFunction<? super T1, ? super T2, ? extends R> zipper) {
        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, R> Flowable<R> zip(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError) {
        return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), p1, p2);
    }

    
    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, R> Flowable<R> zip(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
            BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError, int bufferSize) {
        return zipArray(Functions.toFunction(zipper), delayError, bufferSize, p1, p2);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, R> Flowable<R> zip(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3, 
            Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper) {
        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, R> Flowable<R> zip(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
            Publisher<? extends T4> p4,
            Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipper) {
        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, T5, R> Flowable<R> zip(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
            Publisher<? extends T4> p4, Publisher<? extends T5> p5,
            Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> zipper) {
        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> zip(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
            Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
            Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> zipper) {
        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> zip(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
            Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
            Publisher<? extends T7> p7,
            Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> zipper) {
        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6, p7);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> zip(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
            Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
            Publisher<? extends T7> p7, Publisher<? extends T8> p8,
            Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> zipper) {
        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> zip(
            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
            Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
            Publisher<? extends T7> p7, Publisher<? extends T8> p8, Publisher<? extends T9> p9,
            Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> zipper) {
        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8, p9);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T, R> Flowable<R> zipArray(Function<? super Object[], ? extends R> zipper, 
            boolean delayError, int bufferSize, Publisher<? extends T>... sources) {
        if (sources.length == 0) {
            return empty();
        }
        Objects.requireNonNull(zipper, ""zipper is null"");
        validateBufferSize(bufferSize, ""bufferSize"");
        return new FlowableZip<T, R>(sources, null, zipper, bufferSize, delayError);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T, R> Flowable<R> zipIterable(Function<? super Object[], ? extends R> zipper,
            boolean delayError, int bufferSize, 
            Iterable<? extends Publisher<? extends T>> sources) {
        Objects.requireNonNull(zipper, ""zipper is null"");
        Objects.requireNonNull(sources, ""sources is null"");
        validateBufferSize(bufferSize, ""bufferSize"");
        return new FlowableZip<T, R>(null, sources, zipper, bufferSize, delayError);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<Boolean> all(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, ""predicate is null"");
        return new FlowableAll<T>(this, predicate);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> ambWith(Publisher<? extends T> other) {
        Objects.requireNonNull(other, ""other is null"");
        return amb(this, other);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<Boolean> any(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, ""predicate is null"");
        return new FlowableAny<T>(this, predicate);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> asObservable() {
        return create(new Publisher<T>() {
            @Override
            public void subscribe(Subscriber<? super T> s) {
                Flowable.this.subscribe(s);
            }
        });
    }

    /**
     * Hides the identity of this Flowable and its Subscription.
     * <p>Allows hiding extra features such as {@link Processor}'s
     * {@link Subscriber} methods or preventing certain identity-based 
     * optimizations (fusion).
     * @return the new Flowable instance
     * 
     * @since 2.0
     */
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> hide() {
        return new FlowableHide<T>(this);
    }

    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<List<T>> buffer(int count) {
        return buffer(count, count);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<List<T>> buffer(int count, int skip) {
        return buffer(count, skip, new Supplier<List<T>>() {
            @Override
            public List<T> get() {
                return new ArrayList<T>();
            }
        });
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, int skip, Supplier<U> bufferSupplier) {
        return new FlowableBuffer<T, U>(this, count, skip, bufferSupplier);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, Supplier<U> bufferSupplier) {
        return buffer(count, count, bufferSupplier);
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {
        return buffer(timespan, timeskip, unit, Schedulers.computation(), new Supplier<List<T>>() {
            @Override
            public List<T> get() {
                return new ArrayList<T>();
            }
        });
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {
        return buffer(timespan, timeskip, unit, scheduler, new Supplier<List<T>>() {
            @Override
            public List<T> get() {
                return new ArrayList<T>();
            }
        });
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final <U extends Collection<? super T>> Flowable<U> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, Supplier<U> bufferSupplier) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        Objects.requireNonNull(bufferSupplier, ""bufferSupplier is null"");
        return new FlowableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false);
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit) {
        return buffer(timespan, unit, Integer.MAX_VALUE, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, int count) {
        return buffer(timespan, unit, count, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, int count, Scheduler scheduler) {
        return buffer(timespan, unit, count, scheduler, new Supplier<List<T>>() {
            @Override
            public List<T> get() {
                return new ArrayList<T>();
            }
        }, false);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final <U extends Collection<? super T>> Flowable<U> buffer(
            long timespan, TimeUnit unit, 
            int count, Scheduler scheduler, 
            Supplier<U> bufferSupplier, 
            boolean restartTimerOnMaxSize) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        Objects.requireNonNull(bufferSupplier, ""bufferSupplier is null"");
        if (count <= 0) {
            throw new IllegalArgumentException(""count > 0 required but it was "" + count);
        }
        return new FlowableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler) {
        return buffer(timespan, unit, Integer.MAX_VALUE, scheduler, new Supplier<List<T>>() {
            @Override
            public List<T> get() {
                return new ArrayList<T>();
            }
        }, false);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <TOpening, TClosing> Flowable<List<T>> buffer(
            Flowable<? extends TOpening> bufferOpenings, 
            Function<? super TOpening, ? extends Publisher<? extends TClosing>> bufferClosingSelector) {
        return buffer(bufferOpenings, bufferClosingSelector, new Supplier<List<T>>() {
            @Override
            public List<T> get() {
                return new ArrayList<T>();
            }
        });
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <TOpening, TClosing, U extends Collection<? super T>> Flowable<U> buffer(
            Flowable<? extends TOpening> bufferOpenings, 
            Function<? super TOpening, ? extends Publisher<? extends TClosing>> bufferClosingSelector,
            Supplier<U> bufferSupplier) {
        Objects.requireNonNull(bufferOpenings, ""bufferOpenings is null"");
        Objects.requireNonNull(bufferClosingSelector, ""bufferClosingSelector is null"");
        Objects.requireNonNull(bufferSupplier, ""bufferSupplier is null"");
        return new FlowableBufferBoundary<T, U, TOpening, TClosing>(this, bufferOpenings, bufferClosingSelector, bufferSupplier);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <B> Flowable<List<T>> buffer(Publisher<B> boundary) {
        /*
         * XXX: javac complains if this is not manually cast, Eclipse is fine
         */
        return buffer(boundary, new Supplier<List<T>>() {
            @Override
            public List<T> get() {
                return new ArrayList<T>();
            }
        });
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <B> Flowable<List<T>> buffer(Publisher<B> boundary, final int initialCapacity) {
        return buffer(boundary, new Supplier<List<T>>() {
            @Override
            public List<T> get() {
                return new ArrayList<T>(initialCapacity);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Publisher<B> boundary, Supplier<U> bufferSupplier) {
        Objects.requireNonNull(boundary, ""boundary is null"");
        Objects.requireNonNull(bufferSupplier, ""bufferSupplier is null"");
        return new FlowableBufferExactBoundary<T, U, B>(this, boundary, bufferSupplier);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <B> Flowable<List<T>> buffer(Supplier<? extends Publisher<B>> boundarySupplier) {
        return buffer(boundarySupplier, new Supplier<List<T>>() {
            @Override
            public List<T> get() {
                return new ArrayList<T>();
            }
        });
        
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Supplier<? extends Publisher<B>> boundarySupplier, Supplier<U> bufferSupplier) {
        Objects.requireNonNull(boundarySupplier, ""boundarySupplier is null"");
        Objects.requireNonNull(bufferSupplier, ""bufferSupplier is null"");
        return new FlowableBufferBoundarySupplier<T, U, B>(this, boundarySupplier, bufferSupplier);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> cache() {
        return FlowableCache.from(this);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> cache(int capacityHint) {
        if (capacityHint <= 0) {
            throw new IllegalArgumentException(""capacityHint > 0 required but it was "" + capacityHint);
        }
        return FlowableCache.from(this, capacityHint);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<U> cast(final Class<U> clazz) {
        Objects.requireNonNull(clazz, ""clazz is null"");
        return map(new Function<T, U>() {
            @Override
            public U apply(T v) {
                return clazz.cast(v);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<U> collect(Supplier<? extends U> initialValueSupplier, BiConsumer<? super U, ? super T> collector) {
        Objects.requireNonNull(initialValueSupplier, ""initialValueSupplier is null"");
        Objects.requireNonNull(collector, ""collectior is null"");
        return new FlowableCollect<T, U>(this, initialValueSupplier, collector);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<U> collectInto(final U initialValue, BiConsumer<? super U, ? super T> collector) {
        Objects.requireNonNull(initialValue, ""initialValue is null"");
        return collect(new Supplier<U>() {
            @Override
            public U get() {
                return initialValue;
            }
        }, collector);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    // TODO generics
    public final <R> Flowable<R> compose(Transformer<T, R> composer) {
        return fromPublisher(to(composer));
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {
        return concatMap(mapper, 2);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) {
        Objects.requireNonNull(mapper, ""mapper is null"");
        if (this instanceof ScalarCallable) {
            @SuppressWarnings(""unchecked"")
            T v = ((ScalarCallable<T>)this).call();
            if (v == null) {
                return empty();
            }
            return ScalarXMap.scalarXMap(v, mapper);
        }
        if (prefetch <= 0) {
            throw new IllegalArgumentException(""prefetch > 0 required but it was "" + prefetch);
        }
        return new FlowableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {
        return concatMapDelayError(mapper, 2, true);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch, boolean tillTheEnd) {
        Objects.requireNonNull(mapper, ""mapper is null"");
        if (this instanceof ScalarCallable) {
            @SuppressWarnings(""unchecked"")
            T v = ((ScalarCallable<T>)this).call();
            if (v == null) {
                return empty();
            }
            return ScalarXMap.scalarXMap(v, mapper);
        }
        if (prefetch <= 0) {
            throw new IllegalArgumentException(""prefetch > 0 required but it was "" + prefetch);
        }
        return new FlowableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.IMMEDIATE);
    }


    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper) {
        return concatMapEager(mapper, bufferSize(), bufferSize());
    }

    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper, 
            int maxConcurrency, int prefetch) {
        if (maxConcurrency <= 0) {
            throw new IllegalArgumentException(""maxConcurrency > 0 required but it was "" + maxConcurrency);
        }
        validateBufferSize(prefetch, ""prefetch"");
        return new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, ErrorMode.IMMEDIATE);
    }

    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean tillTheEnd) {
        return concatMapEagerDelayError(mapper, bufferSize(), bufferSize(), tillTheEnd);
    }

    public final <R> Flowable<R> concatMapEagerDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, 
            int maxConcurrency, int prefetch, boolean tillTheEnd) {
        return new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {
        return concatMapIterable(mapper, 2);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<U> concatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int prefetch) {
        Objects.requireNonNull(mapper, ""mapper is null"");
        return new FlowableFlattenIterable<T, U>(this, mapper, prefetch);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> concatWith(Publisher<? extends T> other) {
        Objects.requireNonNull(other, ""other is null"");
        return concat(this, other);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<Boolean> contains(final Object o) {
        Objects.requireNonNull(o, ""o is null"");
        return any(new Predicate<T>() {
            @Override
            public boolean test(T v) {
                return Objects.equals(v, o);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<Long> count() {
        return new FlowableCount<T>(this);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceSelector) {
        Objects.requireNonNull(debounceSelector, ""debounceSelector is null"");
        return new FlowableDebounce<T, U>(this, debounceSelector);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> debounce(long timeout, TimeUnit unit) {
        return debounce(timeout, unit, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return new FlowableDebounceTimed<T>(this, timeout, unit, scheduler);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> defaultIfEmpty(T value) {
        Objects.requireNonNull(value, ""value is null"");
        return switchIfEmpty(just(value));
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    // TODO a more efficient implementation if necessary
    public final <U> Flowable<T> delay(final Function<? super T, ? extends Publisher<U>> itemDelay) {
        Objects.requireNonNull(itemDelay, ""itemDelay is null"");
        return flatMap(new Function<T, Publisher<T>>() {
            @Override
            public Publisher<T> apply(final T v) {
                return fromPublisher(itemDelay.apply(v)).take(1).map(new Function<U, T>() {
                    @Override
                    public T apply(U u) {
                        return v;
                    }
                }).defaultIfEmpty(v);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> delay(long delay, TimeUnit unit) {
        return delay(delay, unit, Schedulers.computation(), false);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> delay(long delay, TimeUnit unit, boolean delayError) {
        return delay(delay, unit, Schedulers.computation(), delayError);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {
        return delay(delay, unit, scheduler, false);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        
        return new FlowableDelay<T>(this, delay, unit, scheduler, delayError);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, V> Flowable<T> delay(Supplier<? extends Publisher<U>> delaySupplier,
            Function<? super T, ? extends Publisher<V>> itemDelay) {
        return delaySubscription(delaySupplier).delay(itemDelay);
    }
    
    /**
     * Returns an Observable that delays the subscription to this Observable
     * until the other Observable emits an element or completes normally.
     * <p>
     * <dl>
     *  <dt><b>Backpressure:</b></dt>
     *  <dd>The operator forwards the backpressure requests to this Observable once
     *  the subscription happens and requests Long.MAX_VALUE from the other Observable</dd>
     *  <dt><b>Scheduler:</b></dt>
     *  <dd>This method does not operate by default on a particular {@link Scheduler}.</dd>
     * </dl>
     * 
     * @param <U> the value type of the other Observable, irrelevant
     * @param other the other Observable that should trigger the subscription
     *        to this Observable.
     * @return an Observable that delays the subscription to this Observable
     *         until the other Observable emits an element or completes normally.
     */
    @Experimental
    public final <U> Flowable<T> delaySubscription(Publisher<U> other) {
        Objects.requireNonNull(other, ""other is null"");
        return new FlowableDelaySubscriptionOther<T, U>(this, other);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> delaySubscription(long delay, TimeUnit unit) {
        return delaySubscription(delay, unit, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    // TODO a more efficient implementation if necessary
    public final Flowable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        
        return timer(delay, unit, scheduler).flatMap(new Function<Long, Publisher<T>>() {
            @Override
            public Publisher<T> apply(Long v) {
                return Flowable.this;
            }
        });
    }

    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<T> delaySubscription(final Supplier<? extends Publisher<U>> delaySupplier) {
        Objects.requireNonNull(delaySupplier, ""delaySupplier is null"");
        return fromCallable(new Callable<Object>() {
            @Override
            public Object call() {
                return delaySupplier.get();
            }
        })  
        .flatMap((Function)Functions.identity())  
        .take(1)  
        .cast(Object.class) // need a common supertype, the value is not relevant  
        .defaultIfEmpty(OBJECT) // in case the publisher is empty  
        .flatMap(new Function() {
            @Override
            public Object apply(Object v) {
                return Flowable.this;
            }
        });  
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <T2> Flowable<T2> dematerialize() {
        @SuppressWarnings(""unchecked"")
        Flowable<Try<Optional<T2>>> m = (Flowable<Try<Optional<T2>>>)this;
        return new FlowableDematerialize<T2>(m);
    }

    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> distinct() {
        return distinct((Function)Functions.identity(), new Supplier<Collection<T>>() {
            @Override
            public Collection<T> get() {
                return new HashSet<T>();
            }
        });
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector) {
        return distinct(keySelector, new Supplier<Collection<K>>() {
            @Override
            public Collection<K> get() {
                return new HashSet<K>();
            }
        });
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector, Supplier<? extends Collection<? super K>> collectionSupplier) {
        Objects.requireNonNull(keySelector, ""keySelector is null"");
        Objects.requireNonNull(collectionSupplier, ""collectionSupplier is null"");
        return FlowableDistinct.withCollection(this, keySelector, collectionSupplier);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> distinctUntilChanged() {
        return FlowableDistinct.<T>untilChanged(this);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K> Flowable<T> distinctUntilChanged(Function<? super T, K> keySelector) {
        Objects.requireNonNull(keySelector, ""keySelector is null"");
        return FlowableDistinct.untilChanged(this, keySelector);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K> Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {
        Objects.requireNonNull(comparer, ""comparer is null"");
        return new FlowableDistinctUntilChanged<T>(this, comparer);
    }
    
    
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnCancel(Runnable onCancel) {
        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyLongConsumer(), onCancel);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnComplete(Runnable onComplete) {
        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(), onComplete, Functions.emptyRunnable());
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    private Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Runnable onComplete, Runnable onAfterTerminate) {
        Objects.requireNonNull(onNext, ""onNext is null"");
        Objects.requireNonNull(onError, ""onError is null"");
        Objects.requireNonNull(onComplete, ""onComplete is null"");
        Objects.requireNonNull(onAfterTerminate, ""onAfterTerminate is null"");
        return new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate);
    }
    
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnEach(final Consumer<? super Try<Optional<T>>> consumer) {
        Objects.requireNonNull(consumer, ""consumer is null"");
        return doOnEach(
                new Consumer<T>() {
                    @Override
                    public void accept(T v) {
                        consumer.accept(Try.ofValue(Optional.of(v)));
                    }
                },
                new Consumer<Throwable>() {
                    @Override
                    public void accept(Throwable e) {
                        consumer.accept(Try.<Optional<T>>ofError(e));
                    }
                },
                new Runnable() {
                    @Override
                    public void run() {
                        consumer.accept(Try.ofValue(Optional.<T>empty()));
                    }
                },
                Functions.emptyRunnable()
                );
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnEach(final Subscriber<? super T> observer) {
        Objects.requireNonNull(observer, ""observer is null"");
        return doOnEach(new Consumer<T>() {
            @Override
            public void accept(T v) {
                observer.onNext(v);
            }
        }, new Consumer<Throwable>() {
            @Override
            public void accept(Throwable e) {
                observer.onError(e);
            }
        }, new Runnable() {
            @Override
            public void run() {
                observer.onComplete();
            }
        }, Functions.emptyRunnable());
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnError(Consumer<? super Throwable> onError) {
        return doOnEach(Functions.emptyConsumer(), onError, Functions.emptyRunnable(), Functions.emptyRunnable());
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnLifecycle(final Consumer<? super Subscription> onSubscribe, final LongConsumer onRequest, final Runnable onCancel) {
        Objects.requireNonNull(onSubscribe, ""onSubscribe is null"");
        Objects.requireNonNull(onRequest, ""onRequest is null"");
        Objects.requireNonNull(onCancel, ""onCancel is null"");
        return lift(new Operator<T, T>() {
            @Override
            public Subscriber<? super T> apply(Subscriber<? super T> s) {
                return new SubscriptionLambdaSubscriber<T>(s, onSubscribe, onRequest, onCancel);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnNext(Consumer<? super T> onNext) {
        return doOnEach(onNext, Functions.emptyConsumer(), Functions.emptyRunnable(), Functions.emptyRunnable());
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnRequest(LongConsumer onRequest) {
        return doOnLifecycle(Functions.emptyConsumer(), onRequest, Functions.emptyRunnable());
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {
        return doOnLifecycle(onSubscribe, Functions.emptyLongConsumer(), Functions.emptyRunnable());
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnTerminate(final Runnable onTerminate) {
        return doOnEach(Functions.emptyConsumer(), new Consumer<Throwable>() {
            @Override
            public void accept(Throwable e) {
                onTerminate.run();
            }
        }, onTerminate, Functions.emptyRunnable());
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> elementAt(long index) {
        if (index < 0) {
            throw new IndexOutOfBoundsException(""index >= 0 required but it was "" + index);
        }
        return new FlowableElementAt<T>(this, index, null);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> elementAt(long index, T defaultValue) {
        if (index < 0) {
            throw new IndexOutOfBoundsException(""index >= 0 required but it was "" + index);
        }
        Objects.requireNonNull(defaultValue, ""defaultValue is null"");
        return new FlowableElementAt<T>(this, index, defaultValue);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> endWith(Iterable<? extends T> values) {
        return concatArray(this, fromIterable(values));
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> endWith(Publisher<? extends T> other) {
        Objects.requireNonNull(other, ""other is null"");
        return concatArray(this, other);
    }


    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> endWith(T value) {
        Objects.requireNonNull(value, ""value is null"");
        return concatArray(this, just(value));
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> endWithArray(T... values) {
        Flowable<T> fromArray = fromArray(values);
        if (fromArray == empty()) {
            return this;
        }
        return concatArray(this, fromArray);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> filter(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, ""predicate is null"");
        return new FlowableFilter<T>(this, predicate);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doAfterTerminate(Runnable onFinally) {
        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(), Functions.emptyRunnable(), onFinally);
    }

    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> first() {
        return take(1).single();
    }

    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> first(T defaultValue) {
        return take(1).single(defaultValue);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {
        return flatMap(mapper, false, bufferSize(), bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors) {
        return flatMap(mapper, delayErrors, bufferSize(), bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors, int maxConcurrency) {
        return flatMap(mapper, delayErrors, maxConcurrency, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, 
            boolean delayErrors, int maxConcurrency, int bufferSize) {
        Objects.requireNonNull(mapper, ""mapper is null"");
        if (this instanceof ScalarCallable) {
            @SuppressWarnings(""unchecked"")
            T v = ((ScalarCallable<T>)this).call();
            if (v == null) {
                return empty();
            }
            return ScalarXMap.scalarXMap(v, mapper);
        }
        if (maxConcurrency <= 0) {
            throw new IllegalArgumentException(""maxConcurrency > 0 required but it was "" + maxConcurrency);
        }
        validateBufferSize(bufferSize, ""bufferSize"");
        return new FlowableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> flatMap(
            Function<? super T, ? extends Publisher<? extends R>> onNextMapper, 
            Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper, 
            Supplier<? extends Publisher<? extends R>> onCompleteSupplier) {
        Objects.requireNonNull(onNextMapper, ""onNextMapper is null"");
        Objects.requireNonNull(onErrorMapper, ""onErrorMapper is null"");
        Objects.requireNonNull(onCompleteSupplier, ""onCompleteSupplier is null"");
        // FIXME run flatMap directly
        return merge(new FlowableMapNotification<T, R>(this, onNextMapper, onErrorMapper, onCompleteSupplier));
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> flatMap(
            Function<? super T, ? extends Publisher<? extends R>> onNextMapper, 
            Function<Throwable, ? extends Publisher<? extends R>> onErrorMapper, 
            Supplier<? extends Publisher<? extends R>> onCompleteSupplier, 
            int maxConcurrency) {
        Objects.requireNonNull(onNextMapper, ""onNextMapper is null"");
        Objects.requireNonNull(onErrorMapper, ""onErrorMapper is null"");
        Objects.requireNonNull(onCompleteSupplier, ""onCompleteSupplier is null"");
        // FIXME run flatMap directly
        return merge(new FlowableMapNotification<T, R>(this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int maxConcurrency) {
        return flatMap(mapper, false, maxConcurrency, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> resultSelector) {
        return flatMap(mapper, resultSelector, false, bufferSize(), bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError) {
        return flatMap(mapper, combiner, delayError, bufferSize(), bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError, int maxConcurrency) {
        return flatMap(mapper, combiner, delayError, maxConcurrency, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, R> Flowable<R> flatMap(final Function<? super T, ? extends Publisher<? extends U>> mapper, final BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError, int maxConcurrency, int bufferSize) {
        Objects.requireNonNull(mapper, ""mapper is null"");
        Objects.requireNonNull(combiner, ""combiner is null"");
        return flatMap(new Function<T, Publisher<R>>() {
            @Override
            public Publisher<R> apply(final T t) {
                Flowable<U> u = fromPublisher(mapper.apply(t));
                return u.map(new Function<U, R>() {
                    @Override
                    public R apply(U w) {
                        return combiner.apply(t, w);
                    }
                });
            }
        }, delayError, maxConcurrency, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, int maxConcurrency) {
        return flatMap(mapper, combiner, false, maxConcurrency, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper) {
        return flatMapIterable(mapper, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, final BiFunction<? super T, ? super U, ? extends V> resultSelector) {
        Objects.requireNonNull(mapper, ""mapper is null"");
        Objects.requireNonNull(resultSelector, ""resultSelector is null"");
        return flatMap(new Function<T, Publisher<U>>() {
            @Override
            public Publisher<U> apply(T t) {
                return new FlowableFromIterable<U>(mapper.apply(t));
            }
        }, resultSelector, false, bufferSize(), bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, final BiFunction<? super T, ? super U, ? extends V> resultSelector, int prefetch) {
        Objects.requireNonNull(mapper, ""mapper is null"");
        Objects.requireNonNull(resultSelector, ""resultSelector is null"");
        return flatMap(new Function<T, Publisher<U>>() {
            @Override
            public Publisher<U> apply(T t) {
                return new FlowableFromIterable<U>(mapper.apply(t));
            }
        }, resultSelector, false, bufferSize(), prefetch);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int bufferSize) {
        return new FlowableFlattenIterable<T, U>(this, mapper, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable forEach(Consumer<? super T> onNext) {
        return subscribe(onNext);
    }

    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable forEachWhile(Predicate<? super T> onNext) {
        return forEachWhile(onNext, RxJavaPlugins.errorConsumer(), Functions.emptyRunnable());
    }

    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) {
        return forEachWhile(onNext, onError, Functions.emptyRunnable());
    }

    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable forEachWhile(final Predicate<? super T> onNext, final Consumer<? super Throwable> onError,
            final Runnable onComplete) {
        Objects.requireNonNull(onNext, ""onNext is null"");
        Objects.requireNonNull(onError, ""onError is null"");
        Objects.requireNonNull(onComplete, ""onComplete is null"");

        final AtomicReference<Subscription> subscription = new AtomicReference<Subscription>();
        return subscribe(new Consumer<T>() {
            @Override
            public void accept(T v) {
                if (!onNext.test(v)) {
                    subscription.get().cancel();
                    onComplete.run();
                }
            }
        }, onError, onComplete, new Consumer<Subscription>() {
            @Override
            public void accept(Subscription s) {
                subscription.lazySet(s);
                s.request(Long.MAX_VALUE);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {
        return groupBy(keySelector, Functions.<T>identity(), false, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {
        return groupBy(keySelector, Functions.<T>identity(), delayError, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, 
            Function<? super T, ? extends V> valueSelector) {
        return groupBy(keySelector, valueSelector, false, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, 
            Function<? super T, ? extends V> valueSelector, boolean delayError) {
        return groupBy(keySelector, valueSelector, false, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, 
            Function<? super T, ? extends V> valueSelector, 
            boolean delayError, int bufferSize) {
        Objects.requireNonNull(keySelector, ""keySelector is null"");
        Objects.requireNonNull(valueSelector, ""valueSelector is null"");
        validateBufferSize(bufferSize, ""bufferSize"");

        return new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin(
            Publisher<? extends TRight> other,
            Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd,
            Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,
            BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector
                    ) {
        return new FlowableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>(
                this, other, leftEnd, rightEnd, resultSelector);
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> ignoreElements() {
        return new FlowableIgnoreElements<T>(this);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<Boolean> isEmpty() {
        return all(new Predicate<T>() {
            @Override
            public boolean test(T v) {
                return false;
            }
        });
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join(
            Publisher<? extends TRight> other,
            Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd,
            Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,
            BiFunction<? super T, ? super TRight, ? extends R> resultSelector
                    ) {
        return new FlowableJoin<T, TRight, TLeftEnd, TRightEnd, R>(
                this, other, leftEnd, rightEnd, resultSelector);
    }
    

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> last() {
        return takeLast(1).single();
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> last(T defaultValue) {
        return takeLast(1).single(defaultValue);
    }

    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> lift(Operator<? extends R, ? super T> lifter) {
        Objects.requireNonNull(lifter, ""lifter is null"");
        // using onSubscribe so the fusing has access to the underlying raw Publisher
        return new FlowableLift<R, T>(this, lifter);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> map(Function<? super T, ? extends R> mapper) {
        Objects.requireNonNull(mapper, ""mapper is null"");
        return new FlowableMap<T, R>(this, mapper);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<Try<Optional<T>>> materialize() {
        return new FlowableMaterialize<T>(this);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> mergeWith(Publisher<? extends T> other) {
        Objects.requireNonNull(other, ""other is null"");
        return merge(this, other);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @Deprecated
    public final Flowable<Flowable<T>> nest() {
        return just(this);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> observeOn(Scheduler scheduler) {
        return observeOn(scheduler, false, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError) {
        return observeOn(scheduler, delayError, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        validateBufferSize(bufferSize, ""bufferSize"");
        return new FlowableObserveOn<T>(this, scheduler, delayError, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<U> ofType(final Class<U> clazz) {
        Objects.requireNonNull(clazz, ""clazz is null"");
        return filter(new Predicate<T>() {
            @Override
            public boolean test(T c) {
                return clazz.isInstance(c);
            }
        }).cast(clazz);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onBackpressureBuffer() {
        return onBackpressureBuffer(bufferSize(), false, true);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onBackpressureBuffer(boolean delayError) {
        return onBackpressureBuffer(bufferSize(), true, true);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onBackpressureBuffer(int bufferSize) {
        return onBackpressureBuffer(bufferSize, false, false);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onBackpressureBuffer(int bufferSize, boolean delayError) {
        return onBackpressureBuffer(bufferSize, true, false);
    }

    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onBackpressureBuffer(int bufferSize, boolean delayError, boolean unbounded) {
        validateBufferSize(bufferSize, ""bufferSize"");
        return new FlowableOnBackpressureBuffer<T>(this, bufferSize, unbounded, delayError, Functions.emptyRunnable());
    }

    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onBackpressureBuffer(int bufferSize, boolean delayError, boolean unbounded, Runnable onOverflow) {
        Objects.requireNonNull(onOverflow, ""onOverflow is null"");
        return new FlowableOnBackpressureBuffer<T>(this, bufferSize, unbounded, delayError, onOverflow);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onBackpressureBuffer(int bufferSize, Runnable onOverflow) {
        return onBackpressureBuffer(bufferSize, false, false, onOverflow);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onBackpressureDrop() {
        return new FlowableOnBackpressureDrop<T>(this);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onBackpressureDrop(Consumer<? super T> onDrop) {
        Objects.requireNonNull(onDrop, ""onDrop is null"");
        return new FlowableOnBackpressureDrop<T>(this, onDrop);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onBackpressureLatest() {
        return new FlowableOnBackpressureLatest<T>(this);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) {
        Objects.requireNonNull(resumeFunction, ""resumeFunction is null"");
        return new FlowableOnErrorNext<T>(this, resumeFunction, false);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onErrorResumeNext(final Publisher<? extends T> next) {
        Objects.requireNonNull(next, ""next is null"");
        return onErrorResumeNext(new Function<Throwable, Publisher<? extends T>>() {
            @Override
            public Publisher<? extends T> apply(Throwable e) {
                return next;
            }
        });
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {
        Objects.requireNonNull(valueSupplier, ""valueSupplier is null"");
        return new FlowableOnErrorReturn<T>(this, valueSupplier);
    }

    // TODO would result in ambiguity with onErrorReturn(Function)
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onErrorReturnValue(final T value) {
        Objects.requireNonNull(value, ""value is null"");
        return onErrorReturn(new Function<Throwable, T>() {
            @Override
            public T apply(Throwable e) {
                return value;
            }
        });
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onExceptionResumeNext(final Publisher<? extends T> next) {
        Objects.requireNonNull(next, ""next is null"");
        return new FlowableOnErrorNext<T>(this, new Function<Throwable, Publisher<? extends T>>() {
            @Override
            public Publisher<? extends T> apply(Throwable e) {
                return next;
            }
        }, true);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> onTerminateDetach() {
        return new FlowableDetach<T>(this);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final ConnectableFlowable<T> publish() {
        return publish(bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {
        return publish(selector, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<R>> selector, int bufferSize) {
        validateBufferSize(bufferSize, ""bufferSize"");
        Objects.requireNonNull(selector, ""selector is null"");
        return FlowablePublish.create(this, selector, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final ConnectableFlowable<T> publish(int bufferSize) {
        validateBufferSize(bufferSize, ""bufferSize"");
        return FlowablePublish.create(this, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> reduce(BiFunction<T, T, T> reducer) {
        return scan(reducer).last();
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {
        return scan(seed, reducer).last();
    }

    // Naming note, a plain scan would cause ambiguity with the value-seeded version
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> reduceWith(Supplier<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {
        return scanWith(seedSupplier, reducer).last();
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> repeat() {
        return repeat(Long.MAX_VALUE);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> repeat(long times) {
        if (times < 0) {
            throw new IllegalArgumentException(""times >= 0 required but it was "" + times);
        }
        if (times == 0) {
            return empty();
        }
        return new FlowableRepeat<T>(this, times);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> repeatUntil(BooleanSupplier stop) {
        Objects.requireNonNull(stop, ""stop is null"");
        return new FlowableRepeatUntil<T>(this, stop);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {
        Objects.requireNonNull(handler, ""handler is null"");
        
        Function<Flowable<Try<Optional<Object>>>, Publisher<?>> f = new Function<Flowable<Try<Optional<Object>>>, Publisher<?>>() {
            @Override
            public Publisher<?> apply(Flowable<Try<Optional<Object>>> no) {
                return handler.apply(no.map(new Function<Try<Optional<Object>>, Object>() {
                    @Override
                    public Object apply(Try<Optional<Object>> v) {
                        return 0;
                    }
                }));
            }
        }
        ;
        
        return new FlowableRedo<T>(this, f);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final ConnectableFlowable<T> replay() {
        return FlowableReplay.createFrom(this);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {
        Objects.requireNonNull(selector, ""selector is null"");
        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {
            @Override
            public ConnectableFlowable<T> get() {
                return replay();
            }
        }, selector);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize) {
        Objects.requireNonNull(selector, ""selector is null"");
        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {
            @Override
            public ConnectableFlowable<T> get() {
                return replay(bufferSize);
            }
        }, selector);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, int bufferSize, long time, TimeUnit unit) {
        return replay(selector, bufferSize, time, unit, Schedulers.computation());
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
        if (bufferSize < 0) {
            throw new IllegalArgumentException(""bufferSize < 0"");
        }
        Objects.requireNonNull(selector, ""selector is null"");
        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {
            @Override
            public ConnectableFlowable<T> get() {
                return replay(bufferSize, time, unit, scheduler);
            }
        }, selector);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final Scheduler scheduler) {
        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {
            @Override
            public ConnectableFlowable<T> get() {
                return replay(bufferSize);
            }
        }, 
        new Function<Flowable<T>, Publisher<R>>() {
            @Override
            public Publisher<R> apply(Flowable<T> t) {
                return fromPublisher(selector.apply(t)).observeOn(scheduler);
            }
        });
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, long time, TimeUnit unit) {
        return replay(selector, time, unit, Schedulers.computation());
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final long time, final TimeUnit unit, final Scheduler scheduler) {
        Objects.requireNonNull(selector, ""selector is null"");
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {
            @Override
            public ConnectableFlowable<T> get() {
                return replay(time, unit, scheduler);
            }
        }, selector);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final Scheduler scheduler) {
        Objects.requireNonNull(selector, ""selector is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return FlowableReplay.multicastSelector(new Supplier<ConnectableFlowable<T>>() {
            @Override
            public ConnectableFlowable<T> get() {
                return replay();
            }
        }, 
        new Function<Flowable<T>, Publisher<R>>() {
            @Override
            public Publisher<R> apply(Flowable<T> t) {
                return fromPublisher(selector.apply(t)).observeOn(scheduler);
            }
        });
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final ConnectableFlowable<T> replay(final int bufferSize) {
        return FlowableReplay.create(this, bufferSize);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final ConnectableFlowable<T> replay(int bufferSize, long time, TimeUnit unit) {
        return replay(bufferSize, time, unit, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final ConnectableFlowable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        if (bufferSize < 0) {
            throw new IllegalArgumentException(""bufferSize < 0"");
        }
        return FlowableReplay.create(this, time, unit, scheduler, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final ConnectableFlowable<T> replay(final int bufferSize, final Scheduler scheduler) {
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return FlowableReplay.observeOn(replay(bufferSize), scheduler);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final ConnectableFlowable<T> replay(long time, TimeUnit unit) {
        return replay(time, unit, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final ConnectableFlowable<T> replay(final long time, final TimeUnit unit, final Scheduler scheduler) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return FlowableReplay.create(this, time, unit, scheduler);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final ConnectableFlowable<T> replay(final Scheduler scheduler) {
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return FlowableReplay.observeOn(replay(), scheduler);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> retry() {
        return retry(Long.MAX_VALUE, Functions.alwaysTrue());
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {
        Objects.requireNonNull(predicate, ""predicate is null"");
        
        return new FlowableRetryBiPredicate<T>(this, predicate);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> retry(long times) {
        return retry(times, Functions.alwaysTrue());
    }
    
    // Retries at most times or until the predicate returns false, whichever happens first
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> retry(long times, Predicate<? super Throwable> predicate) {
        if (times < 0) {
            throw new IllegalArgumentException(""times >= 0 required but it was "" + times);
        }
        Objects.requireNonNull(predicate, ""predicate is null"");

        return new FlowableRetryPredicate<T>(this, times, predicate);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> retry(Predicate<? super Throwable> predicate) {
        return retry(Long.MAX_VALUE, predicate);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> retryUntil(final BooleanSupplier stop) {
        Objects.requireNonNull(stop, ""stop is null"");
        return retry(Long.MAX_VALUE, new Predicate<Throwable>() {
            @Override
            public boolean test(Throwable e) {
                return !stop.getAsBoolean();
            }
        });
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> retryWhen(
            final Function<? super Flowable<? extends Throwable>, ? extends Publisher<?>> handler) {
        Objects.requireNonNull(handler, ""handler is null"");
        
        Function<Flowable<Try<Optional<Object>>>, Publisher<?>> f = new Function<Flowable<Try<Optional<Object>>>, Publisher<?>>() {
            @Override
            public Publisher<?> apply(Flowable<Try<Optional<Object>>> no) {
                Flowable<Throwable> map = no.takeWhile(new Predicate<Try<Optional<Object>>>() {
                    @Override
                    public boolean test(Try<Optional<Object>> e) {
                        return e.hasError();
                    }
                }).map(new Function<Try<Optional<Object>>, Throwable>() {
                    @Override
                    public Throwable apply(Try<Optional<Object>> t) {
                        return t.error();
                    }
                });
                return handler.apply(map);
            }
        }
        ;
        
        return new FlowableRedo<T>(this, f);
    }
    
    // TODO decide if safe subscription or unsafe should be the default
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void safeSubscribe(Subscriber<? super T> s) {
        Objects.requireNonNull(s, ""s is null"");
        if (s instanceof SafeSubscriber) {
            subscribeActual(s);
        } else {
            subscribeActual(new SafeSubscriber<T>(s));
        }
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> sample(long period, TimeUnit unit) {
        return sample(period, unit, Schedulers.computation());
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return new FlowableSampleTimed<T>(this, period, unit, scheduler);
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<T> sample(Publisher<U> sampler) {
        Objects.requireNonNull(sampler, ""sampler is null"");
        return new FlowableSamplePublisher<T>(this, sampler);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> scan(BiFunction<T, T, T> accumulator) {
        Objects.requireNonNull(accumulator, ""accumulator is null"");
        return new FlowableScan<T>(this, accumulator);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> scan(final R seed, BiFunction<R, ? super T, R> accumulator) {
        Objects.requireNonNull(seed, ""seed is null"");
        return scanWith(new Supplier<R>() {
            @Override
            public R get() {
                return seed;
            }
        }, accumulator);
    }
    
    // Naming note, a plain scan would cause ambiguity with the value-seeded version
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> scanWith(Supplier<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {
        Objects.requireNonNull(seedSupplier, ""seedSupplier is null"");
        Objects.requireNonNull(accumulator, ""accumulator is null"");
        return new FlowableScanSeed<T, R>(this, seedSupplier, accumulator);
    }
    
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> serialize() {
        return lift(new Operator<T, T>() {
            @Override
            public Subscriber<? super T> apply(Subscriber<? super T> s) {
                return new SerializedSubscriber<T>(s);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> share() {
        return publish().refCount();
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> single() {
        return new FlowableSingle<T>(this, null);
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> single(T defaultValue) {
        Objects.requireNonNull(defaultValue, ""defaultValue is null"");
        return new FlowableSingle<T>(this, defaultValue);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> skip(long n) {
//        if (n < 0) {
//            throw new IllegalArgumentException(""n >= 0 required but it was "" + n);
//        } else
        // FIXME negative skip allowed?!
        if (n <= 0) {
            return this;
        }
        return new FlowableSkip<T>(this, n);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> skip(long time, TimeUnit unit) {
        // TODO consider inlining this behavior
        return skipUntil(timer(time, unit));
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {
        // TODO consider inlining this behavior
        return skipUntil(timer(time, unit, scheduler));
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> skipLast(int n) {
        if (n < 0) {
            throw new IndexOutOfBoundsException(""n >= 0 required but it was "" + n);
        } else
            if (n == 0) {
                return this;
            }
        return new FlowableSkipLast<T>(this, n);
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<T> skipLast(long time, TimeUnit unit) {
        return skipLast(time, unit, Schedulers.trampoline(), false, bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<T> skipLast(long time, TimeUnit unit, boolean delayError) {
        return skipLast(time, unit, Schedulers.trampoline(), delayError, bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {
        return skipLast(time, unit, scheduler, false, bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {
        return skipLast(time, unit, scheduler, delayError, bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        validateBufferSize(bufferSize, ""bufferSize"");
     // the internal buffer holds pairs of (timestamp, value) so double the default buffer size
        int s = bufferSize << 1; 
        return new FlowableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<T> skipUntil(Publisher<U> other) {
        Objects.requireNonNull(other, ""other is null"");
        return new FlowableSkipUntil<T, U>(this, other);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> skipWhile(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, ""predicate is null"");
        return new FlowableSkipWhile<T>(this, predicate);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> startWith(Iterable<? extends T> values) {
        return concatArray(fromIterable(values), this);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> startWith(Publisher<? extends T> other) {
        Objects.requireNonNull(other, ""other is null"");
        return concatArray(other, this);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> startWith(T value) {
        Objects.requireNonNull(value, ""value is null"");
        return concatArray(just(value), this);
    }

    @SuppressWarnings(""unchecked"")
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> startWithArray(T... values) {
        Flowable<T> fromArray = fromArray(values);
        if (fromArray == empty()) {
            return this;
        }
        return concatArray(fromArray, this);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe() {
        return subscribe(Functions.emptyConsumer(), RxJavaPlugins.errorConsumer(), Functions.emptyRunnable(), new Consumer<Subscription>() {
            @Override
            public void accept(Subscription s) {
                s.request(Long.MAX_VALUE);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer<? super T> onNext) {
        return subscribe(onNext, RxJavaPlugins.errorConsumer(), Functions.emptyRunnable(), new Consumer<Subscription>() {
            @Override
            public void accept(Subscription s) {
                s.request(Long.MAX_VALUE);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {
        return subscribe(onNext, onError, Functions.emptyRunnable(), new Consumer<Subscription>() {
            @Override
            public void accept(Subscription s) {
                s.request(Long.MAX_VALUE);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, 
            Runnable onComplete) {
        return subscribe(onNext, onError, onComplete, new Consumer<Subscription>() {
            @Override
            public void accept(Subscription s) {
                s.request(Long.MAX_VALUE);
            }
        });
    }
    
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, 
            Runnable onComplete, Consumer<? super Subscription> onSubscribe) {
        Objects.requireNonNull(onNext, ""onNext is null"");
        Objects.requireNonNull(onError, ""onError is null"");
        Objects.requireNonNull(onComplete, ""onComplete is null"");
        Objects.requireNonNull(onSubscribe, ""onSubscribe is null"");

        LambdaSubscriber<T> ls = new LambdaSubscriber<T>(onNext, onError, onComplete, onSubscribe);

        unsafeSubscribe(ls);

        return ls;
    }

    // TODO decide if safe subscription or unsafe should be the default
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @Override
    public final void subscribe(Subscriber<? super T> s) {
        Objects.requireNonNull(s, ""s is null"");
        try {
            s = RxJavaPlugins.onSubscribe(this, s);

            if (s == null) {
                throw new NullPointerException(""Plugin returned null Subscriber"");
            }
            
            subscribeActual(s);
        } catch (NullPointerException e) { // NOPMD
            throw e;
        } catch (Throwable e) {
            // TODO throw if fatal?
            // can't call onError because no way to know if a Subscription has been set or not
            // can't call onSubscribe because the call might have set a Subscription already
            RxJavaPlugins.onError(e);
            
            NullPointerException npe = new NullPointerException(""Actually not, but can't throw other exceptions due to RS"");
            npe.initCause(e);
            throw npe;
        }
    }
    
    protected abstract void subscribeActual(Subscriber<? super T> s);
    
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> subscribeOn(Scheduler scheduler) {
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return new FlowableSubscribeOn<T>(this, scheduler);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> switchIfEmpty(Publisher<? extends T> other) {
        Objects.requireNonNull(other, ""other is null"");
        return new FlowableSwitchIfEmpty<T>(this, other);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {
        return switchMap(mapper, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> Flowable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {
        Objects.requireNonNull(mapper, ""mapper is null"");
        if (this instanceof ScalarCallable) {
            @SuppressWarnings(""unchecked"")
            T v = ((ScalarCallable<T>)this).call();
            if (v == null) {
                return empty();
            }
            return ScalarXMap.scalarXMap(v, mapper);
        }
        validateBufferSize(bufferSize, ""bufferSize"");
        return new FlowableSwitchMap<T, R>(this, mapper, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.SPECIAL) // may trigger UNBOUNDED_IN
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> take(long n) {
        if (n < 0) {
            throw new IllegalArgumentException(""n >= required but it was "" + n);
        } else
        if (n == 0) {
         // FIXME may want to subscribe an cancel immediately
//            return lift(s -> CancelledSubscriber.INSTANCE);
            return empty(); 
        }
        return new FlowableTake<T>(this, n);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> take(long time, TimeUnit unit) {
        // TODO consider inlining this behavior
        return takeUntil(timer(time, unit));
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler) {
        // TODO consider inlining this behavior
        return takeUntil(timer(time, unit, scheduler));
    }
    
    @BackpressureSupport(BackpressureKind.SPECIAL) // may trigger UNBOUNDED_IN
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> takeFirst(Predicate<? super T> predicate) {
        return filter(predicate).take(1);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> takeLast(int n) {
        if (n < 0) {
            throw new IndexOutOfBoundsException(""n >= required but it was "" + n);
        } else
        if (n == 0) {
            return ignoreElements();
        } else
        if (n == 1) {
            return new FlowableTakeLastOne<T>(this);
        }
        return new FlowableTakeLast<T>(this, n);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<T> takeLast(long count, long time, TimeUnit unit) {
        return takeLast(count, time, unit, Schedulers.trampoline(), false, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) {
        return takeLast(count, time, unit, scheduler, false, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        validateBufferSize(bufferSize, ""bufferSize"");
        if (count < 0) {
            throw new IndexOutOfBoundsException(""count >= 0 required but it was "" + count);
        }
        return new FlowableTakeLastTimed<T>(this, count, time, unit, scheduler, bufferSize, delayError);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<T> takeLast(long time, TimeUnit unit) {
        return takeLast(time, unit, Schedulers.trampoline(), false, bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<T> takeLast(long time, TimeUnit unit, boolean delayError) {
        return takeLast(time, unit, Schedulers.trampoline(), delayError, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler) {
        return takeLast(time, unit, scheduler, false, bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {
        return takeLast(time, unit, scheduler, delayError, bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
        return takeLast(Long.MAX_VALUE, time, unit, scheduler, delayError, bufferSize);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<List<T>> takeLastBuffer(int count) {
        return takeLast(count).toList();
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<List<T>> takeLastBuffer(int count, long time, TimeUnit unit) {
        return takeLast(count, time, unit).toList();
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<List<T>> takeLastBuffer(int count, long time, TimeUnit unit, Scheduler scheduler) {
        return takeLast(count, time, unit, scheduler).toList();
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<List<T>> takeLastBuffer(long time, TimeUnit unit) {
        return takeLast(time, unit).toList();
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<List<T>> takeLastBuffer(long time, TimeUnit unit, Scheduler scheduler) {
        return takeLast(time, unit, scheduler).toList();
    }
    
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> takeUntil(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, ""predicate is null"");
        return new FlowableTakeUntilPredicate<T>(this, predicate);
    }
    
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U> Flowable<T> takeUntil(Publisher<U> other) {
        Objects.requireNonNull(other, ""other is null"");
        return new FlowableTakeUntil<T, U>(this, other);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> takeWhile(Predicate<? super T> predicate) {
        Objects.requireNonNull(predicate, ""predicate is null"");
        return new FlowableTakeWhile<T>(this, predicate);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> throttleFirst(long windowDuration, TimeUnit unit) {
        return throttleFirst(windowDuration, unit, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return new FlowableThrottleFirstTimed<T>(this, skipDuration, unit, scheduler);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit) {
        return sample(intervalDuration, unit);
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {
        return sample(intervalDuration, unit, scheduler);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit) {
        return debounce(timeout, unit);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {
        return debounce(timeout, unit, scheduler);
    }
    
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<Timed<T>> timeInterval() {
        return timeInterval(TimeUnit.MILLISECONDS, Schedulers.trampoline());
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<Timed<T>> timeInterval(Scheduler scheduler) {
        return timeInterval(TimeUnit.MILLISECONDS, scheduler);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<Timed<T>> timeInterval(TimeUnit unit) {
        return timeInterval(unit, Schedulers.trampoline());
    }
    
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return new FlowableTimeInterval<T>(this, unit, scheduler);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> timeoutSelector) {
        return timeout0(null, timeoutSelector, null);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> timeoutSelector, Flowable<? extends T> other) {
        Objects.requireNonNull(other, ""other is null"");
        return timeout0(null, timeoutSelector, other);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit) {
        return timeout0(timeout, timeUnit, null, Schedulers.computation());
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Flowable<? extends T> other) {
        Objects.requireNonNull(other, ""other is null"");
        return timeout0(timeout, timeUnit, other, Schedulers.computation());
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Flowable<? extends T> other, Scheduler scheduler) {
        Objects.requireNonNull(other, ""other is null"");
        return timeout0(timeout, timeUnit, other, scheduler);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {
        return timeout0(timeout, timeUnit, null, scheduler);
    }
    
    public final <U, V> Flowable<T> timeout(Supplier<? extends Publisher<U>> firstTimeoutSelector, 
            Function<? super T, ? extends Publisher<V>> timeoutSelector) {
        Objects.requireNonNull(firstTimeoutSelector, ""firstTimeoutSelector is null"");
        return timeout0(firstTimeoutSelector, timeoutSelector, null);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, V> Flowable<T> timeout(
            Supplier<? extends Publisher<U>> firstTimeoutSelector, 
            Function<? super T, ? extends Publisher<V>> timeoutSelector, 
                    Publisher<? extends T> other) {
        Objects.requireNonNull(firstTimeoutSelector, ""firstTimeoutSelector is null"");
        Objects.requireNonNull(other, ""other is null"");
        return timeout0(firstTimeoutSelector, timeoutSelector, other);
    }

    private Flowable<T> timeout0(long timeout, TimeUnit timeUnit, Flowable<? extends T> other, 
            Scheduler scheduler) {
        Objects.requireNonNull(timeUnit, ""timeUnit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return new FlowableTimeoutTimed<T>(this, timeout, timeUnit, scheduler, other);
    }

    private <U, V> Flowable<T> timeout0(
            Supplier<? extends Publisher<U>> firstTimeoutSelector, 
            Function<? super T, ? extends Publisher<V>> timeoutSelector, 
                    Publisher<? extends T> other) {
        Objects.requireNonNull(timeoutSelector, ""timeoutSelector is null"");
        return new FlowableTimeout<T, U, V>(this, firstTimeoutSelector, timeoutSelector, other);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<Timed<T>> timestamp() {
        return timestamp(TimeUnit.MILLISECONDS, Schedulers.trampoline());
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<Timed<T>> timestamp(Scheduler scheduler) {
        return timestamp(TimeUnit.MILLISECONDS, scheduler);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)
    public final Flowable<Timed<T>> timestamp(TimeUnit unit) {
        return timestamp(unit, Schedulers.trampoline());
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) {
        Objects.requireNonNull(unit, ""unit is null"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return map(new Function<T, Timed<T>>() {
            @Override
            public Timed<T> apply(T v) {
                return new Timed<T>(v, scheduler.now(unit), unit);
            }
        });
    }

    // TODO generics
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <R> R to(Function<? super Flowable<T>, R> converter) {
        return converter.apply(this);
    }

    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final BlockingFlowable<T> toBlocking() {
        return BlockingFlowable.from(this);
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable toCompletable() {
        return Completable.fromFlowable(this);
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<List<T>> toList() {
        return new FlowableToList<T, List<T>>(this);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<List<T>> toList(final int capacityHint) {
        if (capacityHint <= 0) {
            throw new IllegalArgumentException(""capacityHint > 0 required but it was "" + capacityHint);
        }
        return new FlowableToList<T, List<T>>(this, new Supplier<List<T>>() {
            @Override
            public List<T> get() {
                return new ArrayList<T>(capacityHint);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U extends Collection<? super T>> Flowable<U> toList(Supplier<U> collectionSupplier) {
        Objects.requireNonNull(collectionSupplier, ""collectionSupplier is null"");
        return new FlowableToList<T, U>(this, collectionSupplier);
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K> Flowable<Map<K, T>> toMap(final Function<? super T, ? extends K> keySelector) {
        Objects.requireNonNull(keySelector, ""keySelector is null"");
        return collect(new Supplier<Map<K, T>>() {
            @Override
            public Map<K, T> get() {
                return new HashMap<K, T>();
            }
        }, new BiConsumer<Map<K, T>, T>() {
            @Override
            public void accept(Map<K, T> m, T t) {
                K key = keySelector.apply(t);
                m.put(key, t);
            }
        });
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K, V> Flowable<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector, final Function<? super T, ? extends V> valueSelector) {
        Objects.requireNonNull(keySelector, ""keySelector is null"");
        Objects.requireNonNull(valueSelector, ""valueSelector is null"");
        return collect(new Supplier<Map<K, V>>() {
            @Override
            public Map<K, V> get() {
                return new HashMap<K, V>();
            }
        }, new BiConsumer<Map<K, V>, T>() {
            @Override
            public void accept(Map<K, V> m, T t) {
                K key = keySelector.apply(t);
                V value = valueSelector.apply(t);
                m.put(key, value);
            }
        });
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K, V> Flowable<Map<K, V>> toMap(final Function<? super T, ? extends K> keySelector, 
            final Function<? super T, ? extends V> valueSelector,
            final Supplier<? extends Map<K, V>> mapSupplier) {
        Objects.requireNonNull(keySelector, ""keySelector is null"");
        Objects.requireNonNull(valueSelector, ""valueSelector is null"");
        return collect(mapSupplier, new BiConsumer<Map<K, V>, T>() {
            @Override
            public void accept(Map<K, V> m, T t) {
                K key = keySelector.apply(t);
                V value = valueSelector.apply(t);
                m.put(key, value);
            }
        });
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K> Flowable<Map<K, Collection<T>>> toMultimap(Function<? super T, ? extends K> keySelector) {
        Function<? super T, ? extends T> valueSelector = Functions.identity();
        Supplier<Map<K, Collection<T>>> mapSupplier = new Supplier<Map<K, Collection<T>>>() {
            @Override
            public Map<K, Collection<T>> get() {
                return new HashMap<K, Collection<T>>();
            }
        };
        Function<K, Collection<T>> collectionFactory = new Function<K, Collection<T>>() {
            @Override
            public Collection<T> apply(K k) {
                return new ArrayList<T>();
            }
        };
        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector) {
        Supplier<Map<K, Collection<V>>> mapSupplier = new Supplier<Map<K, Collection<V>>>() {
            @Override
            public Map<K, Collection<V>> get() {
                return new HashMap<K, Collection<V>>();
            }
        };
        Function<K, Collection<V>> collectionFactory = new Function<K, Collection<V>>() {
            @Override
            public Collection<V> apply(K k) {
                return new ArrayList<V>();
            }
        };
        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(""unchecked"")
    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(
            final Function<? super T, ? extends K> keySelector, 
            final Function<? super T, ? extends V> valueSelector, 
            final Supplier<? extends Map<K, Collection<V>>> mapSupplier,
            final Function<? super K, ? extends Collection<? super V>> collectionFactory) {
        Objects.requireNonNull(keySelector, ""keySelector is null"");
        Objects.requireNonNull(valueSelector, ""valueSelector is null"");
        Objects.requireNonNull(mapSupplier, ""mapSupplier is null"");
        Objects.requireNonNull(collectionFactory, ""collectionFactory is null"");
        return collect(mapSupplier, new BiConsumer<Map<K, Collection<V>>, T>() {
            @Override
            public void accept(Map<K, Collection<V>> m, T t) {
                K key = keySelector.apply(t);

                Collection<V> coll = m.get(key);
                if (coll == null) {
                    coll = (Collection<V>)collectionFactory.apply(key);
                    m.put(key, coll);
                }

                V value = valueSelector.apply(t);

                coll.add(value);
            }
        });
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <K, V> Flowable<Map<K, Collection<V>>> toMultimap(
            Function<? super T, ? extends K> keySelector, 
            Function<? super T, ? extends V> valueSelector,
            Supplier<Map<K, Collection<V>>> mapSupplier
            ) {
        return toMultimap(keySelector, valueSelector, mapSupplier, new Function<K, Collection<V>>() {
            @Override
            public Collection<V> apply(K k) {
                return new ArrayList<V>();
            }
        });
    }
    
    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Observable<T> toObservable() {
        return Observable.fromPublisher(this);
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single<T> toSingle() {
        return Single.fromPublisher(this);
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ ""unchecked"", ""rawtypes""})
    public final Flowable<List<T>> toSortedList() {
        return toSortedList(new Comparator<T>() {
            @Override
            public int compare(T o1, T o2) {
                return ((Comparable)o1).compareTo(o2);
            }
        });
    }
    
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<List<T>> toSortedList(final Comparator<? super T> comparator) {
        Objects.requireNonNull(comparator, ""comparator is null"");
        return toList().map(new Function<List<T>, List<T>>() {
            @Override
            public List<T> apply(List<T> v) {
                Collections.sort(v, comparator);
                return v;
            }
        });
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<List<T>> toSortedList(final Comparator<? super T> comparator, int capacityHint) {
        Objects.requireNonNull(comparator, ""comparator is null"");
        return toList(capacityHint).map(new Function<List<T>, List<T>>() {
            @Override
            public List<T> apply(List<T> v) {
                Collections.sort(v, comparator);
                return v;
            }
        });
    }

    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ ""unchecked"", ""rawtypes""})
    public final Flowable<List<T>> toSortedList(int capacityHint) {
        return toSortedList(new Comparator<T>() {
            @Override
            public int compare(T o1, T o2) {
                return ((Comparable)o1).compareTo(o2);
            }
        }, capacityHint);
    }

    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    // TODO decide if safe subscription or unsafe should be the default
    public final void unsafeSubscribe(Subscriber<? super T> s) {
        Objects.requireNonNull(s, ""s is null"");
        subscribeActual(s);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<T> unsubscribeOn(Scheduler scheduler) {
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        return new FlowableUnsubscribeOn<T>(this, scheduler);
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<Flowable<T>> window(long count) {
        return window(count, count, bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<Flowable<T>> window(long count, long skip) {
        return window(count, skip, bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<Flowable<T>> window(long count, long skip, int bufferSize) {
        if (skip <= 0) {
            throw new IllegalArgumentException(""skip > 0 required but it was "" + skip);
        }
        if (count <= 0) {
            throw new IllegalArgumentException(""count > 0 required but it was "" + count);
        }
        validateBufferSize(bufferSize, ""bufferSize"");
        return new FlowableWindow<T>(this, count, skip, bufferSize);
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit) {
        return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {
        return window(timespan, timeskip, unit, scheduler, bufferSize());
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {
        validateBufferSize(bufferSize, ""bufferSize"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        Objects.requireNonNull(unit, ""unit is null"");
        return new FlowableWindowTimed<T>(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit) {
        return window(timespan, unit, Schedulers.computation(), Long.MAX_VALUE, false);
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit, 
            long count) {
        return window(timespan, unit, Schedulers.computation(), count, false);
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit, 
            long count, boolean restart) {
        return window(timespan, unit, Schedulers.computation(), count, restart);
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit, 
            Scheduler scheduler) {
        return window(timespan, unit, scheduler, Long.MAX_VALUE, false);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit, 
            Scheduler scheduler, long count) {
        return window(timespan, unit, scheduler, count, false);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit, 
            Scheduler scheduler, long count, boolean restart) {
        return window(timespan, unit, scheduler, count, restart, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable<Flowable<T>> window(
            long timespan, TimeUnit unit, Scheduler scheduler, 
            long count, boolean restart, int bufferSize) {
        validateBufferSize(bufferSize, ""bufferSize"");
        Objects.requireNonNull(scheduler, ""scheduler is null"");
        Objects.requireNonNull(unit, ""unit is null"");
        if (count <= 0) {
            throw new IllegalArgumentException(""count > 0 required but it was "" + count);
        }
        return new FlowableWindowTimed<T>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart);
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundary) {
        return window(boundary, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundary, int bufferSize) {
        Objects.requireNonNull(boundary, ""boundary is null"");
        return new FlowableWindowBoundary<T, B>(this, boundary, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, V> Flowable<Flowable<T>> window(
            Publisher<U> windowOpen, 
            Function<? super U, ? extends Publisher<V>> windowClose) {
        return window(windowOpen, windowClose, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, V> Flowable<Flowable<T>> window(
            Publisher<U> windowOpen, 
            Function<? super U, ? extends Publisher<V>> windowClose, int bufferSize) {
        Objects.requireNonNull(windowOpen, ""windowOpen is null"");
        Objects.requireNonNull(windowClose, ""windowClose is null"");
        return new FlowableWindowBoundarySelector<T, U, V>(this, windowOpen, windowClose, bufferSize);
    }
    
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <B> Flowable<Flowable<T>> window(Supplier<? extends Publisher<B>> boundary) {
        return window(boundary, bufferSize());
    }

    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <B> Flowable<Flowable<T>> window(Supplier<? extends Publisher<B>> boundary, int bufferSize) {
        Objects.requireNonNull(boundary, ""boundary is null"");
        return new FlowableWindowBoundarySupplier<T, B>(this, boundary, bufferSize);
    }

    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, R> Flowable<R> withLatestFrom(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> combiner) {
        Objects.requireNonNull(other, ""other is null"");
        Objects.requireNonNull(combiner, ""combiner is null"");

        return new FlowableWithLatestFrom<T, U, R>(this, combiner, other);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, R> Flowable<R> zipWith(Iterable<U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {
        Objects.requireNonNull(other, ""other is null"");
        Objects.requireNonNull(zipper, ""zipper is null"");
        return new FlowableZipIterable<T, U, R>(this, other, zipper);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper) {
        Objects.requireNonNull(other, ""other is null"");
        return zip(this, other, zipper);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError) {
        return zip(this, other, zipper, delayError);
    }

    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError, int bufferSize) {
        return zip(this, other, zipper, delayError, bufferSize);
    }

    // -------------------------------------------------------------------------
    // Fluent test support, super handy and reduces test preparation boilerplate
    // -------------------------------------------------------------------------
    /**
     * Creates a TestSubscriber that requests Long.MAX_VALUE and subscribes
     * it to this Flowable.
     * @return the new TestSubscriber instance
     */
    public final TestSubscriber<T> test() { // NoPMD
        TestSubscriber<T> ts = new TestSubscriber<T>();
        subscribe(ts);
        return ts;
    }
    
    /**
     * Creates a TestSubscriber with the given initial request amount and subscribes
     * it to this Flowable.
     * @param initialRequest the initial request amount, positive
     * @return the new TestSubscriber instance
     */
    public final TestSubscriber<T> test(long initialRequest) { // NoPMD
        TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest);
        subscribe(ts);
        return ts;
    }

    /**
     * Creates a TestSubscriber with the given initial request amount, fusion mode
     * and optionally in cancelled state, then subscribes it to this Flowable.
     * @param initialRequest the initial request amount, positive
     * @param fusionMode the requested fusion mode, see {@link QueueSubscription} constants.
     * @param cancelled if true, the TestSubscriber will be cancelled before subscribing to this
     * Flowable.
     * @return the new TestSubscriber instance
     */
    public final TestSubscriber<T> test(long initialRequest, int fusionMode, boolean cancelled) { // NoPMD
        TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest);
        ts.setInitialFusionMode(fusionMode);
        if (cancelled) {
            ts.cancel();
        }
        subscribe(ts);
        return ts;
    }
    
}",    private static void validateBufferSize(int bufferSize),"    private static void validateBufferSize(int bufferSize, String paramName)"
3634c92cb6a8199b8022ffb3bd8e2a65da9c18f0,"/**
 * Copyright 2016 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import java.util.concurrent.atomic.*;

import org.reactivestreams.*;

import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.BackpressureHelper;

public final class FlowableOnBackpressureLatest<T> extends AbstractFlowableWithUpstream<T, T> {

    public FlowableOnBackpressureLatest(Publisher<T> source) {
        super(source);
    }

    @Override
    protected void subscribeActual(Subscriber<? super T> s) {
        source.subscribe(new BackpressureLatestSubscriber<T>(s));
    }

    static final class BackpressureLatestSubscriber<T> extends AtomicInteger implements Subscriber<T>, Subscription {

        private static final long serialVersionUID = 163080509307634843L;

        final Subscriber<? super T> actual;

        Subscription s;

        volatile boolean done;
        Throwable error;

        volatile boolean cancelled;

        final AtomicLong requested = new AtomicLong();

        final AtomicReference<T> current = new AtomicReference<T>();

        BackpressureLatestSubscriber(Subscriber<? super T> actual) {
            this.actual = actual;
        }

        @Override
        public void onSubscribe(Subscription s) {
            if (SubscriptionHelper.validate(this.s, s)) {
                this.s = s;
                actual.onSubscribe(this);
                s.request(Long.MAX_VALUE);
            }
        }

        @Override
        public void onNext(T t) {
            current.lazySet(t);
            drain();
        }

        @Override
        public void onError(Throwable t) {
            error = t;
            done = true;
            drain();
        }

        @Override
        public void onComplete() {
            done = true;
            drain();
        }

        @Override
        public void request(long n) {
            if (SubscriptionHelper.validate(n)) {
                BackpressureHelper.add(requested, n);
                drain();
            }
        }

        @Override
        public void cancel() {
            if (!cancelled) {
                cancelled = true;
                s.cancel();

                if (getAndIncrement() == 0) {
                    current.lazySet(null);
                }
            }
        }

        void drain() {
            if (getAndIncrement() != 0) {
                return;
            }
            final Subscriber<? super T> a = actual;
            int missed = 1;
            final AtomicLong r = requested;
            final AtomicReference<T> q = current;

            for (;;) {
                long e = 0L;

                while (e != r.get()) {
                    boolean d = done;
                    T v = q.getAndSet(null);
                    boolean empty = v == null;

                    if (checkTerminated(d, empty, a, q)) {
                        return;
                    }

                    if (empty) {
                        break;
                    }

                    a.onNext(v);

                    e++;
                }

                if (e == r.get() && checkTerminated(done, q.get() == null, a, q)) {
                    return;
                }

                if (e != 0L) {
                    BackpressureHelper.produced(r, e);
                }

                missed = addAndGet(-missed);
                if (missed == 0) {
                    break;
                }
            }
        }

        boolean checkTerminated(boolean d, boolean empty, Subscriber<?> a, AtomicReference<T> q) {
            if (cancelled) {
                q.lazySet(null);
                return true;
            }

            if (d) {
                Throwable e = error;
                if (e != null) {
                    q.lazySet(null);
                    a.onError(e);
                    return true;
                } else
                if (empty) {
                    a.onComplete();
                    return true;
                }
            }

            return false;
        }
    }
}
","        boolean checkTerminated(boolean d, boolean empty, Subscriber<?> a)","        boolean checkTerminated(boolean d, boolean empty, Subscriber<?> a, AtomicReference<T> q)"
41cfbf643459306069411b43ee5ab2287576e6e5,"/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.processors;

import io.reactivex.annotations.CheckReturnValue;
import java.util.concurrent.atomic.*;

import io.reactivex.annotations.Experimental;
import io.reactivex.annotations.Nullable;
import org.reactivestreams.*;

import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.fuseable.QueueSubscription;
import io.reactivex.internal.queue.SpscLinkedArrayQueue;
import io.reactivex.internal.subscriptions.*;
import io.reactivex.internal.util.BackpressureHelper;
import io.reactivex.plugins.RxJavaPlugins;

/**
 * Processor that allows only a single Subscriber to subscribe to it during its lifetime.
 *
 * <p>This processor buffers notifications and replays them to the Subscriber as requested.
 *
 * <p>This processor holds an unbounded internal buffer.
 *
 * <p>If more than one Subscriber attempts to subscribe to this Processor, they
 * will receive an IllegalStateException if this Processor hasn't terminated yet,
 * or the Subscribers receive the terminal event (error or completion) if this
 * Processor has terminated.
 * <p>
 * <img width=""640"" height=""370"" src=""https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/UnicastProcessor.png"" alt="""">
 *
 * @param <T> the value type received and emitted by this Processor subclass
 * @since 2.0
 */
public final class UnicastProcessor<T> extends FlowableProcessor<T> {

    final SpscLinkedArrayQueue<T> queue;

    final AtomicReference<Runnable> onTerminate;

    final boolean delayError;

    volatile boolean done;

    Throwable error;

    final AtomicReference<Subscriber<? super T>> actual;

    volatile boolean cancelled;

    final AtomicBoolean once;

    final BasicIntQueueSubscription<T> wip;

    final AtomicLong requested;

    boolean enableOperatorFusion;

    /**
     * Creates an UnicastSubject with an internal buffer capacity hint 16.
     * @param <T> the value type
     * @return an UnicastSubject instance
     */
    @CheckReturnValue
    public static <T> UnicastProcessor<T> create() {
        return new UnicastProcessor<T>(bufferSize());
    }

    /**
     * Creates an UnicastProcessor with the given internal buffer capacity hint.
     * @param <T> the value type
     * @param capacityHint the hint to size the internal unbounded buffer
     * @return an UnicastProcessor instance
     */
    @CheckReturnValue
    public static <T> UnicastProcessor<T> create(int capacityHint) {
        return new UnicastProcessor<T>(capacityHint);
    }

    /**
     * Creates an UnicastProcessor with default internal buffer capacity hint and delay error flag.
     * @param <T> the value type
     * @param delayError deliver pending onNext events before onError
     * @return an UnicastProcessor instance
     * @since 2.0.8 - experimental
     */
    @CheckReturnValue
    @Experimental
    public static <T> UnicastProcessor<T> create(boolean delayError) {
        return new UnicastProcessor<T>(bufferSize(), null, delayError);
    }

    /**
     * Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for
     * the case when the single Subscriber cancels its subscription.
     *
     * <p>The callback, if not null, is called exactly once and
     * non-overlapped with any active replay.
     *
     * @param <T> the value type
     * @param capacityHint the hint to size the internal unbounded buffer
     * @param onCancelled the non null callback
     * @return an UnicastProcessor instance
     */
    @CheckReturnValue
    public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) {
        ObjectHelper.requireNonNull(onCancelled, ""onTerminate"");
        return new UnicastProcessor<T>(capacityHint, onCancelled);
    }

    /**
     * Creates an UnicastProcessor with the given internal buffer capacity hint, delay error flag and a callback for
     * the case when the single Subscriber cancels its subscription.
     *
     * <p>The callback, if not null, is called exactly once and
     * non-overlapped with any active replay.
     *
     * @param <T> the value type
     * @param capacityHint the hint to size the internal unbounded buffer
     * @param onCancelled the non null callback
     * @param delayError deliver pending onNext events before onError
     * @return an UnicastProcessor instance
     * @since 2.0.8 - experimental
     */
    @CheckReturnValue
    @Experimental
    public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled, boolean delayError) {
        ObjectHelper.requireNonNull(onCancelled, ""onTerminate"");
        return new UnicastProcessor<T>(capacityHint, onCancelled, delayError);
    }

    /**
     * Creates an UnicastProcessor with the given capacity hint.
     * @param capacityHint the capacity hint for the internal, unbounded queue
     * @since 2.0
     */
    UnicastProcessor(int capacityHint) {
        this(capacityHint,null, true);
    }

    /**
     * Creates an UnicastProcessor with the given capacity hint and callback
     * for when the Processor is terminated normally or its single Subscriber cancels.
     * @param capacityHint the capacity hint for the internal, unbounded queue
     * @param onTerminate the callback to run when the Processor is terminated or cancelled, null not allowed
     * @since 2.0
     */
    UnicastProcessor(int capacityHint, Runnable onTerminate) {
        this(capacityHint, onTerminate, true);
    }

    /**
     * Creates an UnicastProcessor with the given capacity hint and callback
     * for when the Processor is terminated normally or its single Subscriber cancels.
     * @param capacityHint the capacity hint for the internal, unbounded queue
     * @param onTerminate the callback to run when the Processor is terminated or cancelled, null not allowed
     * @param delayError deliver pending onNext events before onError
     * @since 2.0.8 - experimental
     */
    UnicastProcessor(int capacityHint, Runnable onTerminate, boolean delayError) {
        this.queue = new SpscLinkedArrayQueue<T>(ObjectHelper.verifyPositive(capacityHint, ""capacityHint""));
        this.onTerminate = new AtomicReference<Runnable>(onTerminate);
        this.delayError = delayError;
        this.actual = new AtomicReference<Subscriber<? super T>>();
        this.once = new AtomicBoolean();
        this.wip = new UnicastQueueSubscription();
        this.requested = new AtomicLong();
    }

    void doTerminate() {
        Runnable r = onTerminate.get();
        if (r != null && onTerminate.compareAndSet(r, null)) {
            r.run();
        }
    }

    void drainRegular(Subscriber<? super T> a) {
        int missed = 1;

        final SpscLinkedArrayQueue<T> q = queue;
        final boolean failFast = !delayError;
        for (;;) {

            long r = requested.get();
            long e = 0L;

            while (r != e) {
                boolean d = done;

                T t = q.poll();
                boolean empty = t == null;

                if (checkTerminated(failFast, d, empty, a, q)) {
                    return;
                }

                if (empty) {
                    break;
                }

                a.onNext(t);

                e++;
            }

            if (r == e && checkTerminated(failFast, done, q.isEmpty(), a, q)) {
                return;
            }

            if (e != 0 && r != Long.MAX_VALUE) {
                requested.addAndGet(-e);
            }

            missed = wip.addAndGet(-missed);
            if (missed == 0) {
                break;
            }
        }
    }

    void drainFused(Subscriber<? super T> a) {
        int missed = 1;

        final SpscLinkedArrayQueue<T> q = queue;
        final boolean failFast = !delayError;
        for (;;) {

            if (cancelled) {
                q.clear();
                actual.lazySet(null);
                return;
            }

            boolean d = done;

            if (failFast && d && error != null) {
                q.clear();
                actual.lazySet(null);
                a.onError(error);
                return;
            }
            a.onNext(null);

            if (d) {
                actual.lazySet(null);

                Throwable ex = error;
                if (ex != null) {
                    a.onError(ex);
                } else {
                    a.onComplete();
                }
                return;
            }

            missed = wip.addAndGet(-missed);
            if (missed == 0) {
                break;
            }
        }
    }

    void drain() {
        if (wip.getAndIncrement() != 0) {
            return;
        }

        int missed = 1;

        Subscriber<? super T> a = actual.get();
        for (;;) {
            if (a != null) {

                if (enableOperatorFusion) {
                    drainFused(a);
                } else {
                    drainRegular(a);
                }
                return;
            }

            missed = wip.addAndGet(-missed);
            if (missed == 0) {
                break;
            }
            a = actual.get();
        }
    }

    boolean checkTerminated(boolean failFast, boolean d, boolean empty, Subscriber<? super T> a, SpscLinkedArrayQueue<T> q) {
        if (cancelled) {
            q.clear();
            actual.lazySet(null);
            return true;
        }

        if (d) {
            if (failFast && error != null) {
                q.clear();
                actual.lazySet(null);
                a.onError(error);
                return true;
            }
            if (empty) {
                Throwable e = error;
                actual.lazySet(null);
                if (e != null) {
                    a.onError(e);
                } else {
                    a.onComplete();
                }
                return true;
            }
        }

        return false;
    }

    @Override
    public void onSubscribe(Subscription s) {
        if (done || cancelled) {
            s.cancel();
        } else {
            s.request(Long.MAX_VALUE);
        }
    }

    @Override
    public void onNext(T t) {
        if (done || cancelled) {
            return;
        }

        if (t == null) {
            onError(new NullPointerException(""onNext called with null. Null values are generally not allowed in 2.x operators and sources.""));
            return;
        }

        queue.offer(t);
        drain();
    }

    @Override
    public void onError(Throwable t) {
        if (done || cancelled) {
            RxJavaPlugins.onError(t);
            return;
        }

        if (t == null) {
            t = new NullPointerException(""onError called with null. Null values are generally not allowed in 2.x operators and sources."");
        }

        error = t;
        done = true;

        doTerminate();

        drain();
    }

    @Override
    public void onComplete() {
        if (done || cancelled) {
            return;
        }

        done = true;

        doTerminate();

        drain();
    }

    @Override
    protected void subscribeActual(Subscriber<? super T> s) {
        if (!once.get() && once.compareAndSet(false, true)) {

            s.onSubscribe(wip);
            actual.set(s);
            if (cancelled) {
                actual.lazySet(null);
            } else {
                drain();
            }
        } else {
            EmptySubscription.error(new IllegalStateException(""This processor allows only a single Subscriber""), s);
        }
    }

    final class UnicastQueueSubscription extends BasicIntQueueSubscription<T> {


        private static final long serialVersionUID = -4896760517184205454L;

        @Nullable
        @Override
        public T poll() {
            return queue.poll();
        }

        @Override
        public boolean isEmpty() {
            return queue.isEmpty();
        }

        @Override
        public void clear() {
            queue.clear();
        }

        @Override
        public int requestFusion(int requestedMode) {
            if ((requestedMode & QueueSubscription.ASYNC) != 0) {
                enableOperatorFusion = true;
                return QueueSubscription.ASYNC;
            }
            return QueueSubscription.NONE;
        }

        @Override
        public void request(long n) {
            if (SubscriptionHelper.validate(n)) {
                BackpressureHelper.add(requested, n);
                drain();
            }
        }

        @Override
        public void cancel() {
            if (cancelled) {
                return;
            }
            cancelled = true;

            doTerminate();

            if (!enableOperatorFusion) {
                if (wip.getAndIncrement() == 0) {
                    queue.clear();
                    actual.lazySet(null);
                }
            }
        }
    }

    @Override
    public boolean hasSubscribers() {
        return actual.get() != null;
    }

    @Override
    public Throwable getThrowable() {
        if (done) {
            return error;
        }
        return null;
    }

    @Override
    public boolean hasComplete() {
        return done && error == null;
    }

    @Override
    public boolean hasThrowable() {
        return done && error != null;
    }
}
","    boolean checkTerminated(boolean d, boolean empty, Subscriber<? super T> a, SpscLinkedArrayQueue<T> q)","    boolean checkTerminated(boolean failFast, boolean d, boolean empty, Subscriber<? super T> a, SpscLinkedArrayQueue<T> q)"
