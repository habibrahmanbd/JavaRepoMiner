Commit SHA,Java File,Old function signature,New function signature
28d3cb2aa26a37d1595d69f241063e91d2ec994b,"/**
 * The MIT License
 * Copyright (c) 2014 Ilkka Seppälä
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the ""Software""), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package com.iluwatar.hexagonal.notifications;

import com.iluwatar.hexagonal.domain.PlayerDetails;

/**
 * 
 * Provides notifications for lottery events.
 *
 */
public interface LotteryNotifications {
  
  void notifyTicketSubmitted(PlayerDetails details);
  void notifyNoWin(PlayerDetails details);
  void notifyPrize(PlayerDetails details, int prizeAmount);

}
",  void notifyPrize(PlayerDetails details),"  void notifyPrize(PlayerDetails details, int prizeAmount)"
dbd605e3786eb0d90ded55436976784865328d53,"/**
 * The MIT License Copyright (c) 2014 Ilkka Seppälä
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package com.iluwatar.event.asynchronous;

import java.util.Iterator;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 
 * EventManager handles and maintains a pool of event threads. {@link Event} threads are created upon user request. Thre
 * are two types of events; Asynchronous and Synchronous. There can be multiple Asynchronous events running at once but
 * only one Synchronous event running at a time. Currently supported event operations are: start, stop, and getStatus.
 * Once an event is complete, it then notifies EventManager through a listener. The EventManager then takes the event
 * out of the pool.
 *
 */
public class EventManager implements ThreadCompleteListener {

  public static final int MAX_RUNNING_EVENTS = 1000; // Just don't wanna have too many running events. :)
  public static final int MIN_ID = 1;
  public static final int MAX_ID = MAX_RUNNING_EVENTS;
  public static final int MAX_EVENT_TIME = 1800; // in seconds / 30 minutes.
  private int currentlyRunningSyncEvent = -1;
  private Random rand;
  private Map<Integer, Event> eventPool;

  /**
   * EventManager constructor.
   *
   */
  public EventManager() {
    rand = new Random(1);
    eventPool = new ConcurrentHashMap<Integer, Event>(MAX_RUNNING_EVENTS);

  }

  /**
   * Create a Synchronous event.
   * 
   * @param eventTime Time an event should run for.
   * @return eventId
   * @throws MaxNumOfEventsAllowedException When too many events are running at a time.
   * @throws InvalidOperationException No new synchronous events can be created when one is already running.
   * @throws LongRunningEventException Long running events are not allowed in the app.
   */
  public int create(int eventTime)
      throws MaxNumOfEventsAllowedException, InvalidOperationException, LongRunningEventException {
    if (currentlyRunningSyncEvent != -1) {
      throw new InvalidOperationException(
          ""Event ["" + currentlyRunningSyncEvent + ""] is still running. Please wait until it finishes and try again."");
    }

    int eventId = createEvent(eventTime, true);
    currentlyRunningSyncEvent = eventId;

    return eventId;
  }

  /**
   * Create an Asynchronous event.
   * 
   * @param eventTime Time an event should run for.
   * @return eventId
   * @throws MaxNumOfEventsAllowedException When too many events are running at a time.
   * @throws LongRunningEventException Long running events are not allowed in the app.
   */
  public int createAsync(int eventTime) throws MaxNumOfEventsAllowedException, LongRunningEventException {
    return createEvent(eventTime, false);
  }

  private int createEvent(int eventTime, boolean isSynchronous)
      throws MaxNumOfEventsAllowedException, LongRunningEventException {
    if (eventPool.size() == MAX_RUNNING_EVENTS) {
      throw new MaxNumOfEventsAllowedException(""Too many events are running at the moment. Please try again later."");
    }

    if (eventTime >= MAX_EVENT_TIME) {
      throw new LongRunningEventException(
          ""Maximum event time allowed is "" + MAX_EVENT_TIME + "" seconds. Please try again."");
    }

    int newEventId = generateId();

    Event newEvent = new Event(newEventId, eventTime, isSynchronous);
    newEvent.addListener(this);
    eventPool.put(newEventId, newEvent);

    return newEventId;
  }

  /**
   * Starts event.
   * 
   * @param eventId The event that needs to be started.
   * @throws EventDoesNotExistException If event does not exist in our eventPool.
   */
  public void start(int eventId) throws EventDoesNotExistException {
    if (!eventPool.containsKey(eventId)) {
      throw new EventDoesNotExistException(eventId + "" does not exist."");
    }

    eventPool.get(eventId).start();
  }

  /**
   * Stops event.
   * 
   * @param eventId The event that needs to be stopped.
   * @throws EventDoesNotExistException If event does not exist in our eventPool.
   */
  public void cancel(int eventId) throws EventDoesNotExistException {
    if (!eventPool.containsKey(eventId)) {
      throw new EventDoesNotExistException(eventId + "" does not exist."");
    }

    if (eventId == currentlyRunningSyncEvent) {
      currentlyRunningSyncEvent = -1;
    }

    eventPool.get(eventId).stop();
    eventPool.remove(eventId);
  }

  /**
   * Get status of a running event.
   * 
   * @param eventId The event to inquire status of.
   * @throws EventDoesNotExistException If event does not exist in our eventPool.
   */
  public void status(int eventId) throws EventDoesNotExistException {
    if (!eventPool.containsKey(eventId)) {
      throw new EventDoesNotExistException(eventId + "" does not exist."");
    }

    eventPool.get(eventId).status();
  }

  /**
   * Gets status of all running events.
   */
  @SuppressWarnings(""rawtypes"")
  public void statusOfAllEvents() {
    Iterator it = eventPool.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry pair = (Map.Entry) it.next();
      ((Event) pair.getValue()).status();
    }
  }

  /**
   * Stop all running events.
   */
  @SuppressWarnings(""rawtypes"")
  public void shutdown() {
    Iterator it = eventPool.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry pair = (Map.Entry) it.next();
      ((Event) pair.getValue()).stop();
    }
  }

  /**
   * Returns a pseudo-random number between min and max, inclusive. The difference between min and max can be at most
   * <code>Integer.MAX_VALUE - 1</code>.
   */
  private int generateId() {
    // nextInt is normally exclusive of the top value,
    // so add 1 to make it inclusive
    int randomNum = rand.nextInt((MAX_ID - MIN_ID) + 1) + MIN_ID;
    while (eventPool.containsKey(randomNum)) {
      randomNum = rand.nextInt((MAX_ID - MIN_ID) + 1) + MIN_ID;
    }

    return randomNum;
  }

  /**
   * Callback from an {@link Event} (once it is complete). The Event is then removed from the pool.
   */
  @Override
  public void completedEventHandler(int eventId) {
    eventPool.get(eventId).status();
    if (eventPool.get(eventId).isSynchronous()) {
      currentlyRunningSyncEvent = -1;
    }
    eventPool.remove(eventId);
  }

  /**
   * Getter method for event pool.
   */
  public Map<Integer, Event> getEventPool() {
    return eventPool;
  }

  /**
   * Get number of currently running Synchronous events.
   */
  public int numOfCurrentlyRunningSyncEvent() {
    return currentlyRunningSyncEvent;
  }
}
",  private int createEvent(int eventTime),"  private int createEvent(int eventTime, boolean isSynchronous)"
a1a40880873bc40f977a3cef7d5b9f45c70c9312,"/**
 * The MIT License
 * Copyright (c) 2014-2016 Ilkka Seppälä
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the ""Software""), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.iluwatar.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Optional;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import javax.sql.DataSource;

/**
 * An implementation of {@link CustomerDao} that persists customers in RDBMS. 
 *
 */
public class DbCustomerDao implements CustomerDao {

  private final DataSource dataSource;

  /**
   * Creates an instance of {@link DbCustomerDao} which uses provided <code>dataSource</code>
   * to store and retrieve customer information.
   * 
   * @param dataSource a non-null dataSource.
   */
  public DbCustomerDao(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  /**
   * @return a lazily populated stream of customers. Note the stream returned must be closed to 
   *     free all the acquired resources. The stream keeps an open connection to the database till
   *     it is complete or is closed manually.
   */
  @Override
  public Stream<Customer> getAll() throws Exception {

    Connection connection;
    try {
      connection = getConnection();
      PreparedStatement statement = connection.prepareStatement(""SELECT * FROM CUSTOMERS"");  //NOSONAR
      ResultSet resultSet = statement.executeQuery(); //NOSONAR
      return StreamSupport.stream(new Spliterators.AbstractSpliterator<Customer>(Long.MAX_VALUE, 
          Spliterator.ORDERED) {

        @Override
        public boolean tryAdvance(Consumer<? super Customer> action) {
          try {
            if (!resultSet.next()) {
              return false;
            }
            action.accept(createCustomer(resultSet));
            return true;
          } catch (SQLException e) {
            throw new RuntimeException(e);
          }
        }
      }, false).onClose(() -> mutedClose(connection, statement, resultSet));
    } catch (SQLException e) {
      throw new Exception(e.getMessage(), e);
    }
  }

  private Connection getConnection() throws SQLException {
    return dataSource.getConnection();
  }

  private void mutedClose(Connection connection, PreparedStatement statement, ResultSet resultSet) {
    try {
      resultSet.close();
      statement.close();
      connection.close();
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }

  private Customer createCustomer(ResultSet resultSet) throws SQLException {
    return new Customer(resultSet.getInt(""ID""), 
        resultSet.getString(""FNAME""), 
        resultSet.getString(""LNAME""));
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Optional<Customer> getById(int id) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""SELECT * FROM CUSTOMERS WHERE ID = ?"")) {

      statement.setInt(1, id);
      ResultSet resultSet = statement.executeQuery();
      if (resultSet.next()) {
        return Optional.of(createCustomer(resultSet));
      } else {
        return Optional.empty();
      }
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean add(Customer customer) throws Exception {
    if (getById(customer.getId()).isPresent()) {
      return false;
    }

    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""INSERT INTO CUSTOMERS VALUES (?,?,?)"")) {
      statement.setInt(1, customer.getId());
      statement.setString(2, customer.getFirstName());
      statement.setString(3, customer.getLastName());
      statement.execute();
      return true;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean update(Customer customer) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""UPDATE CUSTOMERS SET FNAME = ?, LNAME = ? WHERE ID = ?"")) {
      statement.setString(1, customer.getFirstName());
      statement.setString(2, customer.getLastName());
      statement.setInt(3, customer.getId());
      return statement.executeUpdate() > 0;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean delete(Customer customer) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""DELETE FROM CUSTOMERS WHERE ID = ?"")) {
      statement.setInt(1, customer.getId());
      return statement.executeUpdate() > 0;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }
}
",  private void mutedClose(Connection connection),"  private void mutedClose(Connection connection, PreparedStatement statement, ResultSet resultSet)"
68d094a84712d85370bdf723cc7b5309b72d1fb2,"/**
 * The MIT License
 * Copyright (c) 2014-2016 Ilkka Seppälä
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the ""Software""), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.iluwatar.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Optional;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import javax.sql.DataSource;

/**
 * An implementation of {@link CustomerDao} that persists customers in RDBMS. 
 *
 */
public class DbCustomerDao implements CustomerDao {

  private final DataSource dataSource;

  /**
   * Creates an instance of {@link DbCustomerDao} which uses provided <code>dataSource</code>
   * to store and retrieve customer information.
   * 
   * @param dataSource a non-null dataSource.
   */
  public DbCustomerDao(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  /**
   * @return a lazily populated stream of customers. Note the stream returned must be closed to 
   *     free all the acquired resources. The stream keeps an open connection to the database till
   *     it is complete or is closed manually.
   */
  @Override
  public Stream<Customer> getAll() throws Exception {

    Connection connection;
    try {
      connection = getConnection();
      PreparedStatement statement = connection.prepareStatement(""SELECT * FROM CUSTOMERS"");  //NOSONAR
      ResultSet resultSet = statement.executeQuery(); //NOSONAR
      return StreamSupport.stream(new Spliterators.AbstractSpliterator<Customer>(Long.MAX_VALUE, 
          Spliterator.ORDERED) {

        @Override
        public boolean tryAdvance(Consumer<? super Customer> action) {
          try {
            if (!resultSet.next()) {
              return false;
            }
            action.accept(createCustomer(resultSet));
            return true;
          } catch (SQLException e) {
            throw new RuntimeException(e);
          }
        }
      }, false).onClose(() -> mutedClose(connection, statement, resultSet));
    } catch (SQLException e) {
      throw new Exception(e.getMessage(), e);
    }
  }

  private Connection getConnection() throws SQLException {
    return dataSource.getConnection();
  }

  private void mutedClose(Connection connection, PreparedStatement statement, ResultSet resultSet) {
    try {
      resultSet.close();
      statement.close();
      connection.close();
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }

  private Customer createCustomer(ResultSet resultSet) throws SQLException {
    return new Customer(resultSet.getInt(""ID""), 
        resultSet.getString(""FNAME""), 
        resultSet.getString(""LNAME""));
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Optional<Customer> getById(int id) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""SELECT * FROM CUSTOMERS WHERE ID = ?"")) {

      statement.setInt(1, id);
      ResultSet resultSet = statement.executeQuery();
      if (resultSet.next()) {
        return Optional.of(createCustomer(resultSet));
      } else {
        return Optional.empty();
      }
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean add(Customer customer) throws Exception {
    if (getById(customer.getId()).isPresent()) {
      return false;
    }

    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""INSERT INTO CUSTOMERS VALUES (?,?,?)"")) {
      statement.setInt(1, customer.getId());
      statement.setString(2, customer.getFirstName());
      statement.setString(3, customer.getLastName());
      statement.execute();
      return true;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean update(Customer customer) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""UPDATE CUSTOMERS SET FNAME = ?, LNAME = ? WHERE ID = ?"")) {
      statement.setString(1, customer.getFirstName());
      statement.setString(2, customer.getLastName());
      statement.setInt(3, customer.getId());
      return statement.executeUpdate() > 0;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean delete(Customer customer) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""DELETE FROM CUSTOMERS WHERE ID = ?"")) {
      statement.setInt(1, customer.getId());
      return statement.executeUpdate() > 0;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }
}
",  private void mutedClose(Connection connection),"  private void mutedClose(Connection connection, PreparedStatement statement, ResultSet resultSet)"
671230d798be738b6a5fcfbdc74b0c1873c39085,"/**
 * The MIT License
 * Copyright (c) 2014-2016 Ilkka Seppälä
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the ""Software""), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.iluwatar.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Optional;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import javax.sql.DataSource;

/**
 * An implementation of {@link CustomerDao} that persists customers in RDBMS. 
 *
 */
public class DbCustomerDao implements CustomerDao {

  private final DataSource dataSource;

  /**
   * Creates an instance of {@link DbCustomerDao} which uses provided <code>dataSource</code>
   * to store and retrieve customer information.
   * 
   * @param dataSource a non-null dataSource.
   */
  public DbCustomerDao(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  /**
   * @return a lazily populated stream of customers. Note the stream returned must be closed to 
   *     free all the acquired resources. The stream keeps an open connection to the database till
   *     it is complete or is closed manually.
   */
  @Override
  public Stream<Customer> getAll() throws Exception {

    Connection connection;
    try {
      connection = getConnection();
      PreparedStatement statement = connection.prepareStatement(""SELECT * FROM CUSTOMERS"");  //NOSONAR
      ResultSet resultSet = statement.executeQuery(); //NOSONAR
      return StreamSupport.stream(new Spliterators.AbstractSpliterator<Customer>(Long.MAX_VALUE, 
          Spliterator.ORDERED) {

        @Override
        public boolean tryAdvance(Consumer<? super Customer> action) {
          try {
            if (!resultSet.next()) {
              return false;
            }
            action.accept(createCustomer(resultSet));
            return true;
          } catch (SQLException e) {
            throw new RuntimeException(e);
          }
        }
      }, false).onClose(() -> mutedClose(connection, statement, resultSet));
    } catch (SQLException e) {
      throw new Exception(e.getMessage(), e);
    }
  }

  private Connection getConnection() throws SQLException {
    return dataSource.getConnection();
  }

  private void mutedClose(Connection connection, PreparedStatement statement, ResultSet resultSet) {
    try {
      resultSet.close();
      statement.close();
      connection.close();
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }

  private Customer createCustomer(ResultSet resultSet) throws SQLException {
    return new Customer(resultSet.getInt(""ID""), 
        resultSet.getString(""FNAME""), 
        resultSet.getString(""LNAME""));
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Optional<Customer> getById(int id) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""SELECT * FROM CUSTOMERS WHERE ID = ?"")) {

      statement.setInt(1, id);
      ResultSet resultSet = statement.executeQuery();
      if (resultSet.next()) {
        return Optional.of(createCustomer(resultSet));
      } else {
        return Optional.empty();
      }
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean add(Customer customer) throws Exception {
    if (getById(customer.getId()).isPresent()) {
      return false;
    }

    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""INSERT INTO CUSTOMERS VALUES (?,?,?)"")) {
      statement.setInt(1, customer.getId());
      statement.setString(2, customer.getFirstName());
      statement.setString(3, customer.getLastName());
      statement.execute();
      return true;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean update(Customer customer) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""UPDATE CUSTOMERS SET FNAME = ?, LNAME = ? WHERE ID = ?"")) {
      statement.setString(1, customer.getFirstName());
      statement.setString(2, customer.getLastName());
      statement.setInt(3, customer.getId());
      return statement.executeUpdate() > 0;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean delete(Customer customer) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""DELETE FROM CUSTOMERS WHERE ID = ?"")) {
      statement.setInt(1, customer.getId());
      return statement.executeUpdate() > 0;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }
}
",  private void mutedClose(Connection connection),"  private void mutedClose(Connection connection, PreparedStatement statement, ResultSet resultSet)"
565d5a0129cacc42ae7e0655c5c5c13a74ae45f0,"/**
 * The MIT License
 * Copyright (c) 2014-2016 Ilkka Seppälä
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the ""Software""), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.iluwatar.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Optional;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import javax.sql.DataSource;

/**
 * An implementation of {@link CustomerDao} that persists customers in RDBMS. 
 *
 */
public class DbCustomerDao implements CustomerDao {

  private final DataSource dataSource;

  /**
   * Creates an instance of {@link DbCustomerDao} which uses provided <code>dataSource</code>
   * to store and retrieve customer information.
   * 
   * @param dataSource a non-null dataSource.
   */
  public DbCustomerDao(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  /**
   * @return a lazily populated stream of customers. Note the stream returned must be closed to 
   *     free all the acquired resources. The stream keeps an open connection to the database till
   *     it is complete or is closed manually.
   */
  @Override
  public Stream<Customer> getAll() throws Exception {

    Connection connection;
    try {
      connection = getConnection();
      PreparedStatement statement = connection.prepareStatement(""SELECT * FROM CUSTOMERS"");  //NOSONAR
      ResultSet resultSet = statement.executeQuery(); //NOSONAR
      return StreamSupport.stream(new Spliterators.AbstractSpliterator<Customer>(Long.MAX_VALUE, 
          Spliterator.ORDERED) {

        @Override
        public boolean tryAdvance(Consumer<? super Customer> action) {
          try {
            if (!resultSet.next()) {
              return false;
            }
            action.accept(createCustomer(resultSet));
            return true;
          } catch (SQLException e) {
            throw new RuntimeException(e);
          }
        }
      }, false).onClose(() -> mutedClose(connection, statement, resultSet));
    } catch (SQLException e) {
      throw new Exception(e.getMessage(), e);
    }
  }

  private Connection getConnection() throws SQLException {
    return dataSource.getConnection();
  }

  private void mutedClose(Connection connection, PreparedStatement statement, ResultSet resultSet) {
    try {
      resultSet.close();
      statement.close();
      connection.close();
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }

  private Customer createCustomer(ResultSet resultSet) throws SQLException {
    return new Customer(resultSet.getInt(""ID""), 
        resultSet.getString(""FNAME""), 
        resultSet.getString(""LNAME""));
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Optional<Customer> getById(int id) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""SELECT * FROM CUSTOMERS WHERE ID = ?"")) {

      statement.setInt(1, id);
      ResultSet resultSet = statement.executeQuery();
      if (resultSet.next()) {
        return Optional.of(createCustomer(resultSet));
      } else {
        return Optional.empty();
      }
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean add(Customer customer) throws Exception {
    if (getById(customer.getId()).isPresent()) {
      return false;
    }

    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""INSERT INTO CUSTOMERS VALUES (?,?,?)"")) {
      statement.setInt(1, customer.getId());
      statement.setString(2, customer.getFirstName());
      statement.setString(3, customer.getLastName());
      statement.execute();
      return true;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean update(Customer customer) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""UPDATE CUSTOMERS SET FNAME = ?, LNAME = ? WHERE ID = ?"")) {
      statement.setString(1, customer.getFirstName());
      statement.setString(2, customer.getLastName());
      statement.setInt(3, customer.getId());
      return statement.executeUpdate() > 0;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean delete(Customer customer) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""DELETE FROM CUSTOMERS WHERE ID = ?"")) {
      statement.setInt(1, customer.getId());
      return statement.executeUpdate() > 0;
    } catch (SQLException ex) {
      throw new Exception(ex.getMessage(), ex);
    }
  }
}
",  private void mutedClose(Connection connection),"  private void mutedClose(Connection connection, PreparedStatement statement, ResultSet resultSet)"
ce88fd723e0983145454b796677b1bd7c72a740c,"/**
 * The MIT License
 * Copyright (c) 2014-2016 Ilkka Seppälä
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the ""Software""), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.iluwatar.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Optional;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import javax.sql.DataSource;

import org.apache.log4j.Logger;

/**
 * An implementation of {@link CustomerDao} that persists customers in RDBMS.
 *
 */
public class DbCustomerDao implements CustomerDao {

  private static final Logger LOGGER = Logger.getLogger(DbCustomerDao.class);

  private final DataSource dataSource;

  /**
   * Creates an instance of {@link DbCustomerDao} which uses provided <code>dataSource</code>
   * to store and retrieve customer information.
   * 
   * @param dataSource a non-null dataSource.
   */
  public DbCustomerDao(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  /**
   * @return a lazily populated stream of customers. Note the stream returned must be closed to 
   *     free all the acquired resources. The stream keeps an open connection to the database till
   *     it is complete or is closed manually.
   */
  @Override
  public Stream<Customer> getAll() throws Exception {

    Connection connection;
    try {
      connection = getConnection();
      PreparedStatement statement = connection.prepareStatement(""SELECT * FROM CUSTOMERS""); // NOSONAR
      ResultSet resultSet = statement.executeQuery(); // NOSONAR
      return StreamSupport.stream(new Spliterators.AbstractSpliterator<Customer>(Long.MAX_VALUE, 
          Spliterator.ORDERED) {

        @Override
        public boolean tryAdvance(Consumer<? super Customer> action) {
          try {
            if (!resultSet.next()) {
              return false;
            }
            action.accept(createCustomer(resultSet));
            return true;
          } catch (SQLException e) {
            throw new RuntimeException(e); // NOSONAR
          }
        }
      }, false).onClose(() -> mutedClose(connection, statement, resultSet));
    } catch (SQLException e) {
      throw new CustomException(e.getMessage(), e);
    }
  }

  private Connection getConnection() throws SQLException {
    return dataSource.getConnection();
  }

  private void mutedClose(Connection connection, PreparedStatement statement, ResultSet resultSet) {
    try {
      resultSet.close();
      statement.close();
      connection.close();
    } catch (SQLException e) {
      LOGGER.info(""Exception thrown "" + e.getMessage());
    }
  }

  private Customer createCustomer(ResultSet resultSet) throws SQLException {
    return new Customer(resultSet.getInt(""ID""), 
        resultSet.getString(""FNAME""), 
        resultSet.getString(""LNAME""));
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Optional<Customer> getById(int id) throws Exception {

    ResultSet resultSet = null;

    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""SELECT * FROM CUSTOMERS WHERE ID = ?"")) {

      statement.setInt(1, id);
      resultSet = statement.executeQuery();
      if (resultSet.next()) {
        return Optional.of(createCustomer(resultSet));
      } else {
        return Optional.empty();
      }
    } catch (SQLException ex) {
      throw new CustomException(ex.getMessage(), ex);
    } finally {
      if (resultSet != null) {
        resultSet.close();
      }
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean add(Customer customer) throws Exception {
    if (getById(customer.getId()).isPresent()) {
      return false;
    }

    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""INSERT INTO CUSTOMERS VALUES (?,?,?)"")) {
      statement.setInt(1, customer.getId());
      statement.setString(2, customer.getFirstName());
      statement.setString(3, customer.getLastName());
      statement.execute();
      return true;
    } catch (SQLException ex) {
      throw new CustomException(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean update(Customer customer) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""UPDATE CUSTOMERS SET FNAME = ?, LNAME = ? WHERE ID = ?"")) {
      statement.setString(1, customer.getFirstName());
      statement.setString(2, customer.getLastName());
      statement.setInt(3, customer.getId());
      return statement.executeUpdate() > 0;
    } catch (SQLException ex) {
      throw new CustomException(ex.getMessage(), ex);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean delete(Customer customer) throws Exception {
    try (Connection connection = getConnection();
        PreparedStatement statement = 
            connection.prepareStatement(""DELETE FROM CUSTOMERS WHERE ID = ?"")) {
      statement.setInt(1, customer.getId());
      return statement.executeUpdate() > 0;
    } catch (SQLException ex) {
      throw new CustomException(ex.getMessage(), ex);
    }
  }
}
",  private void mutedClose(Connection connection),"  private void mutedClose(Connection connection, PreparedStatement statement, ResultSet resultSet)"
